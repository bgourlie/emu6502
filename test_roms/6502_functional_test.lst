AS65 Assembler for R6502 [1.42].  Copyright 1994-2007, Frank A. Kingswood                                                Page    1
---------------------------------------------------- 6502_functional_test.a65 ----------------------------------------------------

6102 lines read, no errors in pass 1.
                        ;
                        ; 6 5 0 2   F U N C T I O N A L   T E S T
                        ;
                        ; Copyright (C) 2012-2015  Klaus Dormann
                        ;
                        ; This program is free software: you can redistribute it and/or modify
                        ; it under the terms of the GNU General Public License as published by
                        ; the Free Software Foundation, either version 3 of the License, or
                        ; (at your option) any later version.
                        ;
                        ; This program is distributed in the hope that it will be useful,
                        ; but WITHOUT ANY WARRANTY; without even the implied warranty of
                        ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                        ; GNU General Public License for more details.
                        ;
                        ; You should have received a copy of the GNU General Public License
                        ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
                        
                        
                        ; This program is designed to test all opcodes of a 6502 emulator using all
                        ; addressing modes with focus on propper setting of the processor status
                        ; register bits.
                        ; 
                        ; version 04-dec-2017
                        ; contact info at http://2m5.de or email K@2m5.de
                        ;
                        ; assembled with AS65 from http://www.kingswood-consulting.co.uk/assemblers/
                        ; command line switches: -l -m -s2 -w -h0
                        ;                         |  |  |   |  no page headers in listing
                        ;                         |  |  |   wide listing (133 char/col)
                        ;                         |  |  write intel hex file instead of binary
                        ;                         |  expand macros in listing
                        ;                         generate pass2 listing
                        ;
                        ; No IO - should be run from a monitor with access to registers.
                        ; To run load intel hex image with a load command, than alter PC to 400 hex
                        ; (code_segment) and enter a go command.
                        ; Loop on program counter determines error or successful completion of test.
                        ; Check listing for relevant traps (jump/branch *).
                        ; Please note that in early tests some instructions will have to be used before
                        ; they are actually tested!
                        ;
                        ; RESET, NMI or IRQ should not occur and will be trapped if vectors are enabled.
                        ; Tests documented behavior of the original NMOS 6502 only! No unofficial
                        ; opcodes. Additional opcodes of newer versions of the CPU (65C02, 65816) will
                        ; not be tested. Decimal ops will only be tested with valid BCD operands and
                        ; N V Z flags will be ignored.
                        ;
                        ; Debugging hints:
                        ;     Most of the code is written sequentially. if you hit a trap, check the
                        ;   immediately preceeding code for the instruction to be tested. Results are
                        ;   tested first, flags are checked second by pushing them onto the stack and
                        ;   pulling them to the accumulator after the result was checked. The "real"
                        ;   flags are no longer valid for the tested instruction at this time!
                        ;     If the tested instruction was indexed, the relevant index (X or Y) must
                        ;   also be checked. Opposed to the flags, X and Y registers are still valid.
                        ;
                        ; versions:
                        ;   28-jul-2012  1st version distributed for testing
                        ;   29-jul-2012  fixed references to location 0, now #0
                        ;                added license - GPLv3
                        ;   30-jul-2012  added configuration options
                        ;   01-aug-2012  added trap macro to allow user to change error handling
                        ;   01-dec-2012  fixed trap in branch field must be a branch
                        ;   02-mar-2013  fixed PLA flags not tested
                        ;   19-jul-2013  allowed ROM vectors to be loaded when load_data_direct = 0
                        ;                added test sequence check to detect if tests jump their fence
                        ;   23-jul-2013  added RAM integrity check option
                        ;   16-aug-2013  added error report to standard output option
                        ;   13-dec-2014  added binary/decimal opcode table switch test
                        ;   14-dec-2014  improved relative address test
                        ;   23-aug-2015  added option to disable self modifying tests
                        ;   24-aug-2015  all self modifying immediate opcodes now execute in data RAM
                        ;                added small branch offset pretest
                        ;   21-oct-2015  added option to disable decimal mode ADC & SBC tests
                        ;   04-dec-2017  fixed BRK only tested with interrupts enabled
                        ;                added option to skip the remainder of a failing test
                        ;                in report.i65
                        
                        
                        ; C O N F I G U R A T I O N
                        
                        ;ROM_vectors writable (0=no, 1=yes)
                        ;if ROM vectors can not be used interrupts will not be trapped
                        ;as a consequence BRK can not be tested but will be emulated to test RTI
0001 =                  ROM_vectors = 1
                        
                        ;load_data_direct (0=move from code segment, 1=load directly)
                        ;loading directly is preferred but may not be supported by your platform
                        ;0 produces only consecutive object code, 1 is not suitable for a binary image
0000 =                  load_data_direct = 0
                        
                        ;I_flag behavior (0=force enabled, 1=force disabled, 2=prohibit change, 3=allow
                        ;change) 2 requires extra code and is not recommended. SEI & CLI can only be
                        ;tested if you allow changing the interrupt status (I_flag = 3)
0003 =                  I_flag = 3
                        
                        ;configure memory - try to stay away from memory used by the system
                        ;zero_page memory start address, $50 (80) consecutive Bytes required
                        ;                                add 2 if I_flag = 2
000a =                  zero_page = $a  
                        
                        ;data_segment memory start address, $6A (106) consecutive Bytes required
0200 =                  data_segment = $200  
                            if (data_segment & $ff) != 0
                                ERROR ERROR ERROR low byte of data_segment MUST be $00 !!
                            endif  
                        
                        ;code_segment memory start address, 13kB of consecutive space required
                        ;                                   add 2.5 kB if I_flag = 2
0400 =                  code_segment = $400  
                        
                        ;self modifying code may be disabled to allow running in ROM
                        ;0=part of the code is self modifying and must reside in RAM
                        ;1=tests disabled: branch range
0000 =                  disable_selfmod = 0
                        
                        ;report errors through I/O channel (0=use standard self trap loops, 1=include
                        ;report.i65 as I/O channel, add 3.5 kB)
0000 =                  report = 0
                        
                        ;RAM integrity test option. Checks for undesired RAM writes.
                        ;set lowest non RAM or RAM mirror address page (-1=disable, 0=64k, $40=16k)
                        ;leave disabled if a monitor, OS or background interrupt is allowed to alter RAM
ffff =                  ram_top = -1
                        
                        ;disable test decimal mode ADC & SBC, 0=enable, 1=disable,
                        ;2=disable including decimal flag in processor status
0001 =                  disable_decimal = 1
                        
                                noopt       ;do not take shortcuts
                        
                        ;macros for error & success traps to allow user modification
                        ;example:
                        ;trap    macro
                        ;        jsr my_error_handler
                        ;        endm
                        ;trap_eq macro
                        ;        bne skip\?
                        ;        trap           ;failed equal (zero)
                        ;skip\?
                        ;        endm
                        ;
                        ; my_error_handler should pop the calling address from the stack and report it.
                        ; putting larger portions of code (more than 3 bytes) inside the trap macro
                        ; may lead to branch range problems for some tests.
                            if report = 0
                        trap    macro
                                jmp *           ;failed anyway
                                endm
                        trap_eq macro
                                beq *           ;failed equal (zero)
                                endm
                        trap_ne macro
                                bne *           ;failed not equal (non zero)
                                endm
                        trap_cs macro
                                bcs *           ;failed carry set
                                endm
                        trap_cc macro
                                bcc *           ;failed carry clear
                                endm
                        trap_mi macro
                                bmi *           ;failed minus (bit 7 set)
                                endm
                        trap_pl macro
                                bpl *           ;failed plus (bit 7 clear)
                                endm
                        trap_vs macro
                                bvs *           ;failed overflow set
                                endm
                        trap_vc macro
                                bvc *           ;failed overflow clear
                                endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jmp *           ;test passed, no errors
                                endm
                            endif
                            if report = 1
                        trap    macro
                                jsr report_error
                                endm
                        trap_eq macro
                                bne skip\?
                                trap           ;failed equal (zero)
                        skip\?
                                endm
                        trap_ne macro
                                beq skip\?
                                trap            ;failed not equal (non zero)
                        skip\?
                                endm
                        trap_cs macro
                                bcc skip\?
                                trap            ;failed carry set
                        skip\?
                                endm
                        trap_cc macro
                                bcs skip\?
                                trap            ;failed carry clear
                        skip\?
                                endm
                        trap_mi macro
                                bpl skip\?
                                trap            ;failed minus (bit 7 set)
                        skip\?
                                endm
                        trap_pl macro
                                bmi skip\?
                                trap            ;failed plus (bit 7 clear)
                        skip\?
                                endm
                        trap_vs macro
                                bvc skip\?
                                trap            ;failed overflow set
                        skip\?
                                endm
                        trap_vc macro
                                bvs skip\?
                                trap            ;failed overflow clear
                        skip\?
                                endm
                        ; please observe that during the test the stack gets invalidated
                        ; therefore a RTS inside the success macro is not possible
                        success macro
                                jsr report_success
                                endm
                            endif
                        
                        
0001 =                  carry   equ %00000001   ;flag bits in status
0002 =                  zero    equ %00000010
0004 =                  intdis  equ %00000100
0008 =                  decmode equ %00001000
0010 =                  break   equ %00010000
0020 =                  reserv  equ %00100000
0040 =                  overfl  equ %01000000
0080 =                  minus   equ %10000000
                        
0001 =                  fc      equ carry
0002 =                  fz      equ zero
0003 =                  fzc     equ carry+zero
0040 =                  fv      equ overfl
0042 =                  fvz     equ overfl+zero
0080 =                  fn      equ minus
0081 =                  fnc     equ minus+carry
0082 =                  fnz     equ minus+zero
0083 =                  fnzc    equ minus+zero+carry
00c0 =                  fnv     equ minus+overfl
                        
0030 =                  fao     equ break+reserv    ;bits always on after PHP, BRK
0034 =                  fai     equ fao+intdis      ;+ forced interrupt disable
0038 =                  faod    equ fao+decmode     ;+ ignore decimal
003c =                  faid    equ fai+decmode     ;+ ignore decimal
00ff =                  m8      equ $ff             ;8 bit mask
00fb =                  m8i     equ $ff&~intdis     ;8 bit mask - interrupt disable
                        
                        ;macros to allow masking of status bits.
                        ;masking test of decimal bit
                        ;masking of interrupt enable/disable on load and compare
                        ;masking of always on bits after PHP or BRK (unused & break) on compare
                            if disable_decimal < 2
                                if I_flag = 0
                        load_flag   macro
                                    lda #\1&m8i         ;force enable interrupts (mask I)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8i   ;I_flag is always enabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 1
                        load_flag   macro
                                    lda #\1|intdis      ;force disable interrupts
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fai)&m8    ;I_flag is always disabled + always on bits
                                    endm
                        eor_flag    macro
                                    eor #(\1|fai)       ;invert expected flags + always on bits + I
                                    endm
                                endif
                                if I_flag = 2
                        load_flag   macro
                                    lda #\1
                                    ora flag_I_on       ;restore I-flag
                                    and flag_I_off
                                    endm
                        cmp_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    cmp #(\1|fao)&m8i   ;expected flags + always on bits, mask I
                                    endm
                        eor_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    eor #(\1&m8i|fao)   ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 3
                        load_flag   macro
                                    lda #\1             ;allow test to change I-flag (no mask)
                                    endm
                        cmp_flag    macro
                                    cmp #(\1|fao)&m8    ;expected flags + always on bits
                                    endm
                        eor_flag    macro
                                    eor #\1|fao         ;invert expected flags + always on bits
                                    endm
                                endif
                            else
                                if I_flag = 0
                        load_flag   macro
                                    lda #\1&m8i         ;force enable interrupts (mask I)
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8i  ;I_flag is always enabled + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1&m8i|faod)  ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 1
                        load_flag   macro
                                    lda #\1|intdis      ;force disable interrupts
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faid)&m8   ;I_flag is always disabled + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1|faid)      ;invert expected flags + always on bits + I
                                    endm
                                endif
                                if I_flag = 2
                        load_flag   macro
                                    lda #\1
                                    ora flag_I_on       ;restore I-flag
                                    and flag_I_off
                                    endm
                        cmp_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8i  ;expected flags + always on bits, mask I
                                    endm
                        eor_flag    macro
                                    eor flag_I_on       ;I_flag is never changed
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #(\1&m8i|faod)  ;mask I, invert expected flags + always on bits
                                    endm
                                endif
                                if I_flag = 3
                        load_flag   macro
                                    lda #\1             ;allow test to change I-flag (no mask)
                                    endm
                        cmp_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    cmp #(\1|faod)&m8   ;expected flags + always on bits
                                    endm
                        eor_flag    macro
                                    ora #decmode        ;ignore decimal mode bit
                                    eor #\1|faod        ;invert expected flags + always on bits
                                    endm
                                endif
                            endif
                        
                        ;macros to set (register|memory|zeropage) & status
                        set_stat    macro       ;setting flags in the processor status register
                                    load_flag \1
                                    pha         ;use stack to load status
                                    plp
                                    endm
                        
                        set_a       macro       ;precharging accu & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda #\1     ;precharge accu
                                    plp
                                    endm
                        
                        set_x       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldx #\1     ;precharge index x
                                    plp
                                    endm
                        
                        set_y       macro       ;precharging index & status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    ldy #\1     ;precharge index y
                                    plp
                                    endm
                        
                        set_ax      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;precharge accu
                                    plp
                                    endm
                        
                        set_ay      macro       ;precharging indexed accu & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,y    ;precharge accu
                                    plp
                                    endm
                        
                        set_z       macro       ;precharging indexed zp & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to zeropage
                                    sta zpt
                                    plp
                                    endm
                        
                        set_zx      macro       ;precharging zp,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed zeropage
                                    sta zpt,x
                                    plp
                                    endm
                        
                        set_abs     macro       ;precharging indexed memory & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to memory
                                    sta abst
                                    plp
                                    endm
                        
                        set_absx    macro       ;precharging abs,x & immediate status
                                    load_flag \2
                                    pha         ;use stack to load status
                                    lda \1,x    ;load to indexed memory
                                    sta abst,x
                                    plp
                                    endm
                        
                        ;macros to test (register|memory|zeropage) & status & (mask)
                        tst_stat    macro       ;testing flags in the processor status register
                                    php         ;save status
                                    pla         ;use stack to retrieve status
                                    pha
                                    cmp_flag \1
                                    trap_ne
                                    plp         ;restore status
                                    endm
                                    
                        tst_a       macro       ;testing result in accu & flags
                                    php         ;save flags
                                    cmp #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_x       macro       ;testing result in x index & flags
                                    php         ;save flags
                                    cpx #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_y       macro       ;testing result in y index & flags
                                    php         ;save flags
                                    cpy #\1     ;test result
                                    trap_ne
                                    pla         ;load status
                                    pha
                                    cmp_flag \2
                                    trap_ne
                                    plp         ;restore status
                                    endm
                        
                        tst_ax      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne     ;
                                    endm
                        
                        tst_ay      macro       ;indexed testing result in accu & flags
                                    php         ;save flags
                                    cmp \1,y    ;test result
                                    trap_ne     ;
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,y    ;test flags
                                    trap_ne
                                    endm
                                
                        tst_z       macro       ;indexed testing result in zp & flags
                                    php         ;save flags
                                    lda zpt
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_zx      macro       ;testing result in zp,x & flags
                                    php         ;save flags
                                    lda zpt,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_abs     macro       ;indexed testing result in memory & flags
                                    php         ;save flags
                                    lda abst
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                        
                        tst_absx    macro       ;testing result in abs,x & flags
                                    php         ;save flags
                                    lda abst,x
                                    cmp \1,x    ;test result
                                    trap_ne
                                    pla         ;load status
                                    eor_flag \3
                                    cmp \2,x    ;test flags
                                    trap_ne
                                    endm
                                    
                        ; RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                        ;   uses zpt word as indirect pointer, zpt+2 word as checksum
                                if ram_top > -1
                        check_ram   macro 
                                    cld
                                    lda #0
                                    sta zpt         ;set low byte of indirect pointer
                                    sta zpt+3       ;checksum high byte
                                  if disable_selfmod = 0
                                    sta range_adr   ;reset self modifying code
                                  endif
                                    clc
                                    ldx #zp_bss-zero_page ;zeropage - write test area
                        ccs3\?      adc zero_page,x
                                    bcc ccs2\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs2\?      inx
                                    bne ccs3\?
                                    ldx #hi(abs1)   ;set high byte of indirect pointer
                                    stx zpt+1
                                    ldy #lo(abs1)   ;data after write & execute test area
                        ccs5\?      adc (zpt),y
                                    bcc ccs4\?
                                    inc zpt+3       ;carry to high byte
                                    clc
                        ccs4\?      iny
                                    bne ccs5\?
                                    inx             ;advance RAM high address
                                    stx zpt+1
                                    cpx #ram_top
                                    bne ccs5\?
                                    sta zpt+2       ;checksum low is
                                    cmp ram_chksm   ;checksum low expected
                                    trap_ne         ;checksum mismatch
                                    lda zpt+3       ;checksum high is
                                    cmp ram_chksm+1 ;checksum high expected
                                    trap_ne         ;checksum mismatch
                                    endm            
                                else
                        check_ram   macro
                                    ;RAM check disabled - RAM size not set
                                    endm
                                endif
                        
                        next_test   macro           ;make sure, tests don't jump the fence
                                    lda test_case   ;previous test
                                    cmp #test_num
                                    trap_ne         ;test is out of sequence
                        test_num = test_num + 1
                                    lda #test_num   ;*** next tests' number
                                    sta test_case
                                    ;check_ram       ;uncomment to find altered RAM after each test
                                    endm
                        
                            if load_data_direct = 1
                                data
                            else
                                bss                 ;uninitialized segment, copy of data at end of code!
                            endif
000a =                          org zero_page
                        ;break test interrupt save
000a =                  irq_a   ds  1               ;a register
000b =                  irq_x   ds  1               ;x register
                            if I_flag = 2
                        ;masking for I bit in status
                        flag_I_on   ds  1           ;or mask to load flags   
                        flag_I_off  ds  1           ;and mask to load flags
                            endif
000c =                  zpt                         ;5 bytes store/modify test area
                        ;add/subtract operand generation and result/flag prediction
000c =                  adfc    ds  1               ;carry flag before op
000d =                  ad1     ds  1               ;operand 1 - accumulator
000e =                  ad2     ds  1               ;operand 2 - memory / immediate
000f =                  adrl    ds  1               ;expected result bits 0-7
0010 =                  adrh    ds  1               ;expected result bit 8 (carry)
0011 =                  adrf    ds  1               ;expected flags NV0000ZC (only binary mode)
0012 =                  sb2     ds  1               ;operand 2 complemented for subtract
0013 =                  zp_bss
0013 =                  zp1     db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
0017 =                  zp7f    db  $7f             ;test pattern for compare  
                        ;logical zeropage operands
0018 =                  zpOR    db  0,$1f,$71,$80   ;test pattern for OR
001c =                  zpAN    db  $0f,$ff,$7f,$80 ;test pattern for AND
0020 =                  zpEO    db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
0024 =                  ind1    dw  abs1            ;indirect pointer to pattern in absolute memory
0026 =                          dw  abs1+1
0028 =                          dw  abs1+2
002a =                          dw  abs1+3
002c =                          dw  abs7f
002e =                  inw1    dw  abs1-$f8        ;indirect pointer for wrap-test pattern
0030 =                  indt    dw  abst            ;indirect pointer to store area in absolute memory
0032 =                          dw  abst+1
0034 =                          dw  abst+2
0036 =                          dw  abst+3
0038 =                  inwt    dw  abst-$f8        ;indirect pointer for wrap-test store
003a =                  indAN   dw  absAN           ;indirect pointer to AND pattern in absolute memory
003c =                          dw  absAN+1
003e =                          dw  absAN+2
0040 =                          dw  absAN+3
0042 =                  indEO   dw  absEO           ;indirect pointer to EOR pattern in absolute memory
0044 =                          dw  absEO+1
0046 =                          dw  absEO+2
0048 =                          dw  absEO+3
004a =                  indOR   dw  absOR           ;indirect pointer to OR pattern in absolute memory
004c =                          dw  absOR+1
004e =                          dw  absOR+2
0050 =                          dw  absOR+3
                        ;add/subtract indirect pointers
0052 =                  adi2    dw  ada2            ;indirect pointer to operand 2 in absolute memory
0054 =                  sbi2    dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
0056 =                  adiy2   dw  ada2-$ff        ;with offset for indirect indexed
0058 =                  sbiy2   dw  sba2-$ff
005a =                  zp_bss_end
                           
0200 =                          org data_segment
0200 =                  test_case   ds  1           ;current test number
0201 =                  ram_chksm   ds  2           ;checksum for RAM integrity test
                        ;add/subtract operand copy - abs tests write area
0203 =                  abst                        ;5 bytes store/modify test area
0203 =                  ada2    ds  1               ;operand 2
0204 =                  sba2    ds  1               ;operand 2 complemented for subtract
0205 =                          ds  3               ;fill remaining bytes
0208 =                  data_bss
                            if load_data_direct = 1
                        ex_andi and #0              ;execute immediate opcodes
                                rts
                        ex_eori eor #0              ;execute immediate opcodes
                                rts
                        ex_orai ora #0              ;execute immediate opcodes
                                rts
                        ex_adci adc #0              ;execute immediate opcodes
                                rts
                        ex_sbci sbc #0              ;execute immediate opcodes
                                rts
                            else
0208 =                  ex_andi ds  3
020b =                  ex_eori ds  3
020e =                  ex_orai ds  3
0211 =                  ex_adci ds  3
0214 =                  ex_sbci ds  3
                            endif
0217 =                  abs1    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
021b =                  abs7f   db  $7f             ;test pattern for compare
                        ;loads
021c =                  fLDx    db  fn,fn,0,fz      ;expected flags for load
                        ;shifts
0220 =                  rASL                        ;expected result ASL & ROL -carry  
0220 =                  rROL    db  $86,$04,$82,0   ; "
0224 =                  rROLc   db  $87,$05,$83,1   ;expected result ROL +carry
0228 =                  rLSR                        ;expected result LSR & ROR -carry
0228 =                  rROR    db  $61,$41,$20,0   ; "
022c =                  rRORc   db  $e1,$c1,$a0,$80 ;expected result ROR +carry
0230 =                  fASL                        ;expected flags for shifts
0230 =                  fROL    db  fnc,fc,fn,fz    ;no carry in
0234 =                  fROLc   db  fnc,fc,fn,0     ;carry in
0238 =                  fLSR
0238 =                  fROR    db  fc,0,fc,fz      ;no carry in
023c =                  fRORc   db  fnc,fn,fnc,fn   ;carry in
                        ;increments (decrements)
0240 =                  rINC    db  $7f,$80,$ff,0,1 ;expected result for INC/DEC
0245 =                  fINC    db  0,fn,fn,fz,0    ;expected flags for INC/DEC
                        ;logical memory operand
024a =                  absOR   db  0,$1f,$71,$80   ;test pattern for OR
024e =                  absAN   db  $0f,$ff,$7f,$80 ;test pattern for AND
0252 =                  absEO   db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;logical accu operand
0256 =                  absORa  db  0,$f1,$1f,0     ;test pattern for OR
025a =                  absANa  db  $f0,$ff,$ff,$ff ;test pattern for AND
025e =                  absEOa  db  $ff,$f0,$f0,$0f ;test pattern for EOR
                        ;logical results
0262 =                  absrlo  db  0,$ff,$7f,$80
0266 =                  absflo  db  fz,fn,0,fn
026a =                  data_bss_end
                        
                        
                                code
0400 =                          org code_segment
0400 : d8               start   cld
0401 : a2ff                     ldx #$ff
0403 : 9a                       txs
0404 : a900                     lda #0          ;*** test 0 = initialize
0406 : 8d0002                   sta test_case
0000 =                  test_num = 0
                        
                        ;stop interrupts before initializing BSS
                            if I_flag = 1
                                sei
                            endif
                            
                        ;initialize I/O for report channel
                            if report = 1
                                jsr report_init
                            endif
                            
                        ;pretest small branch offset
0409 : a205                     ldx #5
040b : 4c3304                   jmp psb_test
040e :                  psb_bwok
040e : a005                     ldy #5
0410 : d008                     bne psb_forw
                                trap        ;branch should be taken
0412 : 4c1204          >        jmp *           ;failed anyway
                        
0415 : 88                       dey         ;forward landing zone
0416 : 88                       dey
0417 : 88                       dey
0418 : 88                       dey
0419 : 88                       dey
041a :                  psb_forw
041a : 88                       dey
041b : 88                       dey
041c : 88                       dey
041d : 88                       dey
041e : 88                       dey
041f : f017                     beq psb_fwok
                                trap        ;forward offset
0421 : 4c2104          >        jmp *           ;failed anyway
                        
                        
0424 : ca                       dex         ;backward landing zone
0425 : ca                       dex
0426 : ca                       dex
0427 : ca                       dex
0428 : ca                       dex
0429 :                  psb_back
0429 : ca                       dex
042a : ca                       dex
042b : ca                       dex
042c : ca                       dex
042d : ca                       dex
042e : f0de                     beq psb_bwok
                                trap        ;backward offset
0430 : 4c3004          >        jmp *           ;failed anyway
                        
0433 :                  psb_test
0433 : d0f4                     bne psb_back
                                trap        ;branch should be taken
0435 : 4c3504          >        jmp *           ;failed anyway
                        
0438 :                  psb_fwok
                                
                        ;initialize BSS segment
                            if load_data_direct != 1
0438 : a246                     ldx #zp_end-zp_init-1
043a : bd2536           ld_zp   lda zp_init,x
043d : 9513                     sta zp_bss,x
043f : ca                       dex
0440 : 10f8                     bpl ld_zp
0442 : a261                     ldx #data_end-data_init-1
0444 : bd6c36           ld_data lda data_init,x
0447 : 9d0802                   sta data_bss,x
044a : ca                       dex
044b : 10f7                     bpl ld_data
                              if ROM_vectors = 1
044d : a205                     ldx #5
044f : bdce36           ld_vect lda vec_init,x
0452 : 9dfaff                   sta vec_bss,x
0455 : ca                       dex
0456 : 10f7                     bpl ld_vect
                              endif
                            endif
                        
                        ;retain status of interrupt flag
                            if I_flag = 2
                                php
                                pla
                                and #4          ;isolate flag
                                sta flag_I_on   ;or mask
                                eor #lo(~4)     ;reverse
                                sta flag_I_off  ;and mask
                            endif
                                
                        ;generate checksum for RAM integrity test
                            if ram_top > -1
                                lda #0 
                                sta zpt         ;set low byte of indirect pointer
                                sta ram_chksm+1 ;checksum high byte
                              if disable_selfmod = 0
                                sta range_adr   ;reset self modifying code
                              endif
                                clc
                                ldx #zp_bss-zero_page ;zeropage - write test area
                        gcs3    adc zero_page,x
                                bcc gcs2
                                inc ram_chksm+1 ;carry to high byte
                                clc
                        gcs2    inx
                                bne gcs3
                                ldx #hi(abs1)   ;set high byte of indirect pointer
                                stx zpt+1
                                ldy #lo(abs1)   ;data after write & execute test area
                        gcs5    adc (zpt),y
                                bcc gcs4
                                inc ram_chksm+1 ;carry to high byte
                                clc
                        gcs4    iny
                                bne gcs5
                                inx             ;advance RAM high address
                                stx zpt+1
                                cpx #ram_top
                                bne gcs5
                                sta ram_chksm   ;checksum complete
                            endif
                                next_test            
0458 : ad0002          >            lda test_case   ;previous test
045b : c900            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
045d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0001 =                 >test_num = test_num + 1
045f : a901            >            lda #test_num   ;*** next tests' number
0461 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                            if disable_selfmod = 0
                        ;testing relative addressing with BEQ
0464 : a0fe                     ldy #$fe        ;testing maximum range, not -1/-2 (invalid/self adr)
0466 :                  range_loop
0466 : 88                       dey             ;next relative address
0467 : 98                       tya
0468 : aa                       tax             ;precharge count to end of loop
0469 : 1008                     bpl range_fw    ;calculate relative address
046b : 18                       clc             ;avoid branch self or to relative address of branch
046c : 6902                     adc #2
046e : ea                       nop             ;offset landing zone - tolerate +/-5 offset to branch
046f : ea                       nop
0470 : ea                       nop
0471 : ea                       nop
0472 : ea                       nop
0473 :                  range_fw
0473 : ea                       nop
0474 : ea                       nop
0475 : ea                       nop
0476 : ea                       nop
0477 : ea                       nop
0478 : 497f                     eor #$7f        ;complement except sign
047a : 8d0605                   sta range_adr   ;load into test target
047d : a900                     lda #0          ;should set zero flag in status register
047f : 4c0505                   jmp range_op
                                
0482 : ca                       dex             ; offset landing zone - backward branch too far
0483 : ca                       dex
0484 : ca                       dex
0485 : ca                       dex
0486 : ca                       dex
                                ;relative address target field with branch under test in the middle
0487 : ca                       dex             ;-128 - max backward
0488 : ca                       dex
0489 : ca                       dex
048a : ca                       dex
048b : ca                       dex
048c : ca                       dex
048d : ca                       dex
048e : ca                       dex
048f : ca                       dex             ;-120
0490 : ca                       dex
0491 : ca                       dex
0492 : ca                       dex
0493 : ca                       dex
0494 : ca                       dex
0495 : ca                       dex
0496 : ca                       dex
0497 : ca                       dex
0498 : ca                       dex
0499 : ca                       dex             ;-110
049a : ca                       dex
049b : ca                       dex
049c : ca                       dex
049d : ca                       dex
049e : ca                       dex
049f : ca                       dex
04a0 : ca                       dex
04a1 : ca                       dex
04a2 : ca                       dex
04a3 : ca                       dex             ;-100
04a4 : ca                       dex
04a5 : ca                       dex
04a6 : ca                       dex
04a7 : ca                       dex
04a8 : ca                       dex
04a9 : ca                       dex
04aa : ca                       dex
04ab : ca                       dex
04ac : ca                       dex
04ad : ca                       dex             ;-90
04ae : ca                       dex
04af : ca                       dex
04b0 : ca                       dex
04b1 : ca                       dex
04b2 : ca                       dex
04b3 : ca                       dex
04b4 : ca                       dex
04b5 : ca                       dex
04b6 : ca                       dex
04b7 : ca                       dex             ;-80
04b8 : ca                       dex
04b9 : ca                       dex
04ba : ca                       dex
04bb : ca                       dex
04bc : ca                       dex
04bd : ca                       dex
04be : ca                       dex
04bf : ca                       dex
04c0 : ca                       dex
04c1 : ca                       dex             ;-70
04c2 : ca                       dex
04c3 : ca                       dex
04c4 : ca                       dex
04c5 : ca                       dex
04c6 : ca                       dex
04c7 : ca                       dex
04c8 : ca                       dex
04c9 : ca                       dex
04ca : ca                       dex
04cb : ca                       dex             ;-60
04cc : ca                       dex
04cd : ca                       dex
04ce : ca                       dex
04cf : ca                       dex
04d0 : ca                       dex
04d1 : ca                       dex
04d2 : ca                       dex
04d3 : ca                       dex
04d4 : ca                       dex
04d5 : ca                       dex             ;-50
04d6 : ca                       dex
04d7 : ca                       dex
04d8 : ca                       dex
04d9 : ca                       dex
04da : ca                       dex
04db : ca                       dex
04dc : ca                       dex
04dd : ca                       dex
04de : ca                       dex
04df : ca                       dex             ;-40
04e0 : ca                       dex
04e1 : ca                       dex
04e2 : ca                       dex
04e3 : ca                       dex
04e4 : ca                       dex
04e5 : ca                       dex
04e6 : ca                       dex
04e7 : ca                       dex
04e8 : ca                       dex
04e9 : ca                       dex             ;-30
04ea : ca                       dex
04eb : ca                       dex
04ec : ca                       dex
04ed : ca                       dex
04ee : ca                       dex
04ef : ca                       dex
04f0 : ca                       dex
04f1 : ca                       dex
04f2 : ca                       dex
04f3 : ca                       dex             ;-20
04f4 : ca                       dex
04f5 : ca                       dex
04f6 : ca                       dex
04f7 : ca                       dex
04f8 : ca                       dex
04f9 : ca                       dex
04fa : ca                       dex
04fb : ca                       dex
04fc : ca                       dex
04fd : ca                       dex             ;-10
04fe : ca                       dex
04ff : ca                       dex
0500 : ca                       dex
0501 : ca                       dex
0502 : ca                       dex
0503 : ca                       dex
0504 : ca                       dex             ;-3
0505 :                  range_op                ;test target with zero flag=0, z=1 if previous dex
0506 =                  range_adr   = *+1       ;modifiable relative address
0505 : f03e                     beq *+64        ;+64 if called without modification
0507 : ca                       dex             ;+0
0508 : ca                       dex
0509 : ca                       dex
050a : ca                       dex
050b : ca                       dex
050c : ca                       dex
050d : ca                       dex
050e : ca                       dex
050f : ca                       dex
0510 : ca                       dex
0511 : ca                       dex             ;+10
0512 : ca                       dex
0513 : ca                       dex
0514 : ca                       dex
0515 : ca                       dex
0516 : ca                       dex
0517 : ca                       dex
0518 : ca                       dex
0519 : ca                       dex
051a : ca                       dex
051b : ca                       dex             ;+20
051c : ca                       dex
051d : ca                       dex
051e : ca                       dex
051f : ca                       dex
0520 : ca                       dex
0521 : ca                       dex
0522 : ca                       dex
0523 : ca                       dex
0524 : ca                       dex
0525 : ca                       dex             ;+30
0526 : ca                       dex
0527 : ca                       dex
0528 : ca                       dex
0529 : ca                       dex
052a : ca                       dex
052b : ca                       dex
052c : ca                       dex
052d : ca                       dex
052e : ca                       dex
052f : ca                       dex             ;+40
0530 : ca                       dex
0531 : ca                       dex
0532 : ca                       dex
0533 : ca                       dex
0534 : ca                       dex
0535 : ca                       dex
0536 : ca                       dex
0537 : ca                       dex
0538 : ca                       dex
0539 : ca                       dex             ;+50
053a : ca                       dex
053b : ca                       dex
053c : ca                       dex
053d : ca                       dex
053e : ca                       dex
053f : ca                       dex
0540 : ca                       dex
0541 : ca                       dex
0542 : ca                       dex
0543 : ca                       dex             ;+60
0544 : ca                       dex
0545 : ca                       dex
0546 : ca                       dex
0547 : ca                       dex
0548 : ca                       dex
0549 : ca                       dex
054a : ca                       dex
054b : ca                       dex
054c : ca                       dex
054d : ca                       dex             ;+70
054e : ca                       dex
054f : ca                       dex
0550 : ca                       dex
0551 : ca                       dex
0552 : ca                       dex
0553 : ca                       dex
0554 : ca                       dex
0555 : ca                       dex
0556 : ca                       dex
0557 : ca                       dex             ;+80
0558 : ca                       dex
0559 : ca                       dex
055a : ca                       dex
055b : ca                       dex
055c : ca                       dex
055d : ca                       dex
055e : ca                       dex
055f : ca                       dex
0560 : ca                       dex
0561 : ca                       dex             ;+90
0562 : ca                       dex
0563 : ca                       dex
0564 : ca                       dex
0565 : ca                       dex
0566 : ca                       dex
0567 : ca                       dex
0568 : ca                       dex
0569 : ca                       dex
056a : ca                       dex
056b : ca                       dex             ;+100
056c : ca                       dex
056d : ca                       dex
056e : ca                       dex
056f : ca                       dex
0570 : ca                       dex
0571 : ca                       dex
0572 : ca                       dex
0573 : ca                       dex
0574 : ca                       dex
0575 : ca                       dex             ;+110
0576 : ca                       dex
0577 : ca                       dex
0578 : ca                       dex
0579 : ca                       dex
057a : ca                       dex
057b : ca                       dex
057c : ca                       dex
057d : ca                       dex
057e : ca                       dex
057f : ca                       dex             ;+120
0580 : ca                       dex
0581 : ca                       dex
0582 : ca                       dex
0583 : ca                       dex
0584 : ca                       dex
0585 : ca                       dex
0586 : ea                       nop             ;offset landing zone - forward branch too far
0587 : ea                       nop
0588 : ea                       nop
0589 : ea                       nop
058a : ea                       nop
058b : f008                     beq range_ok    ;+127 - max forward
                                trap            ; bad range
058d : 4c8d05          >        jmp *           ;failed anyway
                        
0590 : ea                       nop             ;offset landing zone - tolerate +/-5 offset to branch
0591 : ea                       nop
0592 : ea                       nop
0593 : ea                       nop
0594 : ea                       nop
0595 :                  range_ok
0595 : ea                       nop
0596 : ea                       nop
0597 : ea                       nop
0598 : ea                       nop
0599 : ea                       nop
059a : c000                     cpy #0
059c : f003                     beq range_end   
059e : 4c6604                   jmp range_loop
05a1 :                  range_end               ;range test successful
                            endif
                                next_test
05a1 : ad0002          >            lda test_case   ;previous test
05a4 : c901            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
05a6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0002 =                 >test_num = test_num + 1
05a8 : a902            >            lda #test_num   ;*** next tests' number
05aa : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;partial test BNE & CMP, CPX, CPY immediate
05ad : c001                     cpy #1          ;testing BNE true
05af : d003                     bne test_bne
                                trap 
05b1 : 4cb105          >        jmp *           ;failed anyway
                        
05b4 :                  test_bne
05b4 : a900                     lda #0 
05b6 : c900                     cmp #0          ;test compare immediate 
                                trap_ne
05b8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
05ba : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
05bc : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
05be : c901                     cmp #1
                                trap_eq 
05c0 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
05c2 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
05c4 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
05c6 : aa                       tax 
05c7 : e000                     cpx #0          ;test compare x immediate
                                trap_ne
05c9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
05cb : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
05cd : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
05cf : e001                     cpx #1
                                trap_eq 
05d1 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
05d3 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
05d5 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
05d7 : a8                       tay 
05d8 : c000                     cpy #0          ;test compare y immediate
                                trap_ne
05da : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                trap_cc
05dc : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_mi
05de : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
05e0 : c001                     cpy #1
                                trap_eq 
05e2 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_cs
05e4 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_pl
05e6 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                next_test
05e8 : ad0002          >            lda test_case   ;previous test
05eb : c902            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
05ed : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0003 =                 >test_num = test_num + 1
05ef : a903            >            lda #test_num   ;*** next tests' number
05f1 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        ;testing stack operations PHA PHP PLA PLP
                                    
05f4 : a2ff                     ldx #$ff        ;initialize stack
05f6 : 9a                       txs
05f7 : a955                     lda #$55
05f9 : 48                       pha
05fa : a9aa                     lda #$aa
05fc : 48                       pha
05fd : cdfe01                   cmp $1fe        ;on stack ?
                                trap_ne
0600 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0602 : ba                       tsx
0603 : 8a                       txa             ;overwrite accu
0604 : c9fd                     cmp #$fd        ;sp decremented?
                                trap_ne
0606 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0608 : 68                       pla
0609 : c9aa                     cmp #$aa        ;successful retreived from stack?
                                trap_ne
060b : d0fe            >        bne *           ;failed not equal (non zero)
                        
060d : 68                       pla
060e : c955                     cmp #$55
                                trap_ne
0610 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0612 : cdff01                   cmp $1ff        ;remains on stack?
                                trap_ne
0615 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0617 : ba                       tsx
0618 : e0ff                     cpx #$ff        ;sp incremented?
                                trap_ne
061a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
061c : ad0002          >            lda test_case   ;previous test
061f : c903            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0621 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0004 =                 >test_num = test_num + 1
0623 : a904            >            lda #test_num   ;*** next tests' number
0625 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ;testing branch decisions BPL BMI BVC BVS BCC BCS BNE BEQ
                                set_stat $ff    ;all on
                       >            load_flag $ff    
0628 : a9ff            >            lda #$ff                 ;allow test to change I-flag (no mask)
                       >
062a : 48              >            pha         ;use stack to load status
062b : 28              >            plp
                        
062c : 101a                     bpl nbr1        ;branches should not be taken
062e : 501b                     bvc nbr2
0630 : 901c                     bcc nbr3
0632 : d01d                     bne nbr4
0634 : 3003                     bmi br1         ;branches should be taken
                                trap 
0636 : 4c3606          >        jmp *           ;failed anyway
                        
0639 : 7003             br1     bvs br2
                                trap 
063b : 4c3b06          >        jmp *           ;failed anyway
                        
063e : b003             br2     bcs br3
                                trap 
0640 : 4c4006          >        jmp *           ;failed anyway
                        
0643 : f00f             br3     beq br4
                                trap 
0645 : 4c4506          >        jmp *           ;failed anyway
                        
0648 :                  nbr1
                                trap            ;previous bpl taken 
0648 : 4c4806          >        jmp *           ;failed anyway
                        
064b :                  nbr2
                                trap            ;previous bvc taken
064b : 4c4b06          >        jmp *           ;failed anyway
                        
064e :                  nbr3
                                trap            ;previous bcc taken
064e : 4c4e06          >        jmp *           ;failed anyway
                        
0651 :                  nbr4
                                trap            ;previous bne taken
0651 : 4c5106          >        jmp *           ;failed anyway
                        
0654 : 08               br4     php
0655 : ba                       tsx
0656 : e0fe                     cpx #$fe        ;sp after php?
                                trap_ne
0658 : d0fe            >        bne *           ;failed not equal (non zero)
                        
065a : 68                       pla
                                cmp_flag $ff    ;returned all flags on?
065b : c9ff            >            cmp #($ff    |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
065d : d0fe            >        bne *           ;failed not equal (non zero)
                        
065f : ba                       tsx
0660 : e0ff                     cpx #$ff        ;sp after php?
                                trap_ne
0662 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0      ;all off
                       >            load_flag 0      
0664 : a900            >            lda #0                   ;allow test to change I-flag (no mask)
                       >
0666 : 48              >            pha         ;use stack to load status
0667 : 28              >            plp
                        
0668 : 301a                     bmi nbr11       ;branches should not be taken
066a : 701b                     bvs nbr12
066c : b01c                     bcs nbr13
066e : f01d                     beq nbr14
0670 : 1003                     bpl br11        ;branches should be taken
                                trap 
0672 : 4c7206          >        jmp *           ;failed anyway
                        
0675 : 5003             br11    bvc br12
                                trap 
0677 : 4c7706          >        jmp *           ;failed anyway
                        
067a : 9003             br12    bcc br13
                                trap 
067c : 4c7c06          >        jmp *           ;failed anyway
                        
067f : d00f             br13    bne br14
                                trap 
0681 : 4c8106          >        jmp *           ;failed anyway
                        
0684 :                  nbr11
                                trap            ;previous bmi taken 
0684 : 4c8406          >        jmp *           ;failed anyway
                        
0687 :                  nbr12
                                trap            ;previous bvs taken 
0687 : 4c8706          >        jmp *           ;failed anyway
                        
068a :                  nbr13
                                trap            ;previous bcs taken 
068a : 4c8a06          >        jmp *           ;failed anyway
                        
068d :                  nbr14
                                trap            ;previous beq taken 
068d : 4c8d06          >        jmp *           ;failed anyway
                        
0690 : 08               br14    php
0691 : 68                       pla
                                cmp_flag 0      ;flags off except break (pushed by sw) + reserved?
0692 : c930            >            cmp #(0      |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0694 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                ;crosscheck flags
                                set_stat zero
                       >            load_flag zero
0696 : a902            >            lda #zero             ;allow test to change I-flag (no mask)
                       >
0698 : 48              >            pha         ;use stack to load status
0699 : 28              >            plp
                        
069a : d002                     bne brzs1
069c : f003                     beq brzs2
069e :                  brzs1
                                trap            ;branch zero/non zero
069e : 4c9e06          >        jmp *           ;failed anyway
                        
06a1 : b002             brzs2   bcs brzs3
06a3 : 9003                     bcc brzs4
06a5 :                  brzs3
                                trap            ;branch carry/no carry
06a5 : 4ca506          >        jmp *           ;failed anyway
                        
06a8 : 3002             brzs4   bmi brzs5
06aa : 1003                     bpl brzs6
06ac :                  brzs5
                                trap            ;branch minus/plus
06ac : 4cac06          >        jmp *           ;failed anyway
                        
06af : 7002             brzs6   bvs brzs7
06b1 : 5003                     bvc brzs8
06b3 :                  brzs7
                                trap            ;branch overflow/no overflow
06b3 : 4cb306          >        jmp *           ;failed anyway
                        
06b6 :                  brzs8
                                set_stat carry
                       >            load_flag carry
06b6 : a901            >            lda #carry             ;allow test to change I-flag (no mask)
                       >
06b8 : 48              >            pha         ;use stack to load status
06b9 : 28              >            plp
                        
06ba : f002                     beq brcs1
06bc : d003                     bne brcs2
06be :                  brcs1
                                trap            ;branch zero/non zero
06be : 4cbe06          >        jmp *           ;failed anyway
                        
06c1 : 9002             brcs2   bcc brcs3
06c3 : b003                     bcs brcs4
06c5 :                  brcs3
                                trap            ;branch carry/no carry
06c5 : 4cc506          >        jmp *           ;failed anyway
                        
06c8 : 3002             brcs4   bmi brcs5
06ca : 1003                     bpl brcs6
06cc :                  brcs5
                                trap            ;branch minus/plus
06cc : 4ccc06          >        jmp *           ;failed anyway
                        
06cf : 7002             brcs6   bvs brcs7
06d1 : 5003                     bvc brcs8
06d3 :                  brcs7
                                trap            ;branch overflow/no overflow
06d3 : 4cd306          >        jmp *           ;failed anyway
                        
                        
06d6 :                  brcs8
                                set_stat minus
                       >            load_flag minus
06d6 : a980            >            lda #minus             ;allow test to change I-flag (no mask)
                       >
06d8 : 48              >            pha         ;use stack to load status
06d9 : 28              >            plp
                        
06da : f002                     beq brmi1
06dc : d003                     bne brmi2
06de :                  brmi1
                                trap            ;branch zero/non zero
06de : 4cde06          >        jmp *           ;failed anyway
                        
06e1 : b002             brmi2   bcs brmi3
06e3 : 9003                     bcc brmi4
06e5 :                  brmi3
                                trap            ;branch carry/no carry
06e5 : 4ce506          >        jmp *           ;failed anyway
                        
06e8 : 1002             brmi4   bpl brmi5
06ea : 3003                     bmi brmi6
06ec :                  brmi5
                                trap            ;branch minus/plus
06ec : 4cec06          >        jmp *           ;failed anyway
                        
06ef : 7002             brmi6   bvs brmi7
06f1 : 5003                     bvc brmi8
06f3 :                  brmi7
                                trap            ;branch overflow/no overflow
06f3 : 4cf306          >        jmp *           ;failed anyway
                        
06f6 :                  brmi8
                                set_stat overfl
                       >            load_flag overfl
06f6 : a940            >            lda #overfl             ;allow test to change I-flag (no mask)
                       >
06f8 : 48              >            pha         ;use stack to load status
06f9 : 28              >            plp
                        
06fa : f002                     beq brvs1
06fc : d003                     bne brvs2
06fe :                  brvs1
                                trap            ;branch zero/non zero
06fe : 4cfe06          >        jmp *           ;failed anyway
                        
0701 : b002             brvs2   bcs brvs3
0703 : 9003                     bcc brvs4
0705 :                  brvs3
                                trap            ;branch carry/no carry
0705 : 4c0507          >        jmp *           ;failed anyway
                        
0708 : 3002             brvs4   bmi brvs5
070a : 1003                     bpl brvs6
070c :                  brvs5
                                trap            ;branch minus/plus
070c : 4c0c07          >        jmp *           ;failed anyway
                        
070f : 5002             brvs6   bvc brvs7
0711 : 7003                     bvs brvs8
0713 :                  brvs7
                                trap            ;branch overflow/no overflow
0713 : 4c1307          >        jmp *           ;failed anyway
                        
0716 :                  brvs8
                                set_stat $ff-zero
                       >            load_flag $ff-zero
0716 : a9fd            >            lda #$ff-zero             ;allow test to change I-flag (no mask)
                       >
0718 : 48              >            pha         ;use stack to load status
0719 : 28              >            plp
                        
071a : f002                     beq brzc1
071c : d003                     bne brzc2
071e :                  brzc1
                                trap            ;branch zero/non zero
071e : 4c1e07          >        jmp *           ;failed anyway
                        
0721 : 9002             brzc2   bcc brzc3
0723 : b003                     bcs brzc4
0725 :                  brzc3
                                trap            ;branch carry/no carry
0725 : 4c2507          >        jmp *           ;failed anyway
                        
0728 : 1002             brzc4   bpl brzc5
072a : 3003                     bmi brzc6
072c :                  brzc5
                                trap            ;branch minus/plus
072c : 4c2c07          >        jmp *           ;failed anyway
                        
072f : 5002             brzc6   bvc brzc7
0731 : 7003                     bvs brzc8
0733 :                  brzc7
                                trap            ;branch overflow/no overflow
0733 : 4c3307          >        jmp *           ;failed anyway
                        
0736 :                  brzc8
                                set_stat $ff-carry
                       >            load_flag $ff-carry
0736 : a9fe            >            lda #$ff-carry             ;allow test to change I-flag (no mask)
                       >
0738 : 48              >            pha         ;use stack to load status
0739 : 28              >            plp
                        
073a : d002                     bne brcc1
073c : f003                     beq brcc2
073e :                  brcc1
                                trap            ;branch zero/non zero
073e : 4c3e07          >        jmp *           ;failed anyway
                        
0741 : b002             brcc2   bcs brcc3
0743 : 9003                     bcc brcc4
0745 :                  brcc3
                                trap            ;branch carry/no carry
0745 : 4c4507          >        jmp *           ;failed anyway
                        
0748 : 1002             brcc4   bpl brcc5
074a : 3003                     bmi brcc6
074c :                  brcc5
                                trap            ;branch minus/plus
074c : 4c4c07          >        jmp *           ;failed anyway
                        
074f : 5002             brcc6   bvc brcc7
0751 : 7003                     bvs brcc8
0753 :                  brcc7
                                trap            ;branch overflow/no overflow
0753 : 4c5307          >        jmp *           ;failed anyway
                        
0756 :                  brcc8
                                set_stat $ff-minus
                       >            load_flag $ff-minus
0756 : a97f            >            lda #$ff-minus             ;allow test to change I-flag (no mask)
                       >
0758 : 48              >            pha         ;use stack to load status
0759 : 28              >            plp
                        
075a : d002                     bne brpl1
075c : f003                     beq brpl2
075e :                  brpl1
                                trap            ;branch zero/non zero
075e : 4c5e07          >        jmp *           ;failed anyway
                        
0761 : 9002             brpl2   bcc brpl3
0763 : b003                     bcs brpl4
0765 :                  brpl3
                                trap            ;branch carry/no carry
0765 : 4c6507          >        jmp *           ;failed anyway
                        
0768 : 3002             brpl4   bmi brpl5
076a : 1003                     bpl brpl6
076c :                  brpl5
                                trap            ;branch minus/plus
076c : 4c6c07          >        jmp *           ;failed anyway
                        
076f : 5002             brpl6   bvc brpl7
0771 : 7003                     bvs brpl8
0773 :                  brpl7
                                trap            ;branch overflow/no overflow
0773 : 4c7307          >        jmp *           ;failed anyway
                        
0776 :                  brpl8
                                set_stat $ff-overfl
                       >            load_flag $ff-overfl
0776 : a9bf            >            lda #$ff-overfl             ;allow test to change I-flag (no mask)
                       >
0778 : 48              >            pha         ;use stack to load status
0779 : 28              >            plp
                        
077a : d002                     bne brvc1
077c : f003                     beq brvc2
077e :                  brvc1
                                trap            ;branch zero/non zero
077e : 4c7e07          >        jmp *           ;failed anyway
                        
0781 : 9002             brvc2   bcc brvc3
0783 : b003                     bcs brvc4
0785 :                  brvc3
                                trap            ;branch carry/no carry
0785 : 4c8507          >        jmp *           ;failed anyway
                        
0788 : 1002             brvc4   bpl brvc5
078a : 3003                     bmi brvc6
078c :                  brvc5
                                trap            ;branch minus/plus
078c : 4c8c07          >        jmp *           ;failed anyway
                        
078f : 7002             brvc6   bvs brvc7
0791 : 5003                     bvc brvc8
0793 :                  brvc7
                                trap            ;branch overflow/no overflow
0793 : 4c9307          >        jmp *           ;failed anyway
                        
0796 :                  brvc8
                                next_test
0796 : ad0002          >            lda test_case   ;previous test
0799 : c904            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
079b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0005 =                 >test_num = test_num + 1
079d : a905            >            lda #test_num   ;*** next tests' number
079f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; test PHA does not alter flags or accumulator but PLA does
07a2 : a255                     ldx #$55        ;x & y protected
07a4 : a0aa                     ldy #$aa
                                set_a 1,$ff     ;push
                       >            load_flag $ff     
07a6 : a9ff            >            lda #$ff                  ;allow test to change I-flag (no mask)
                       >
07a8 : 48              >            pha         ;use stack to load status
07a9 : a901            >            lda #1     ;precharge accu
07ab : 28              >            plp
                        
07ac : 48                       pha
                                tst_a 1,$ff
07ad : 08              >            php         ;save flags
07ae : c901            >            cmp #1     ;test result
                       >            trap_ne
07b0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07b2 : 68              >            pla         ;load status
07b3 : 48              >            pha
                       >            cmp_flag $ff
07b4 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
07b6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07b8 : 28              >            plp         ;restore status
                        
                                set_a 0,0
                       >            load_flag 0
07b9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
07bb : 48              >            pha         ;use stack to load status
07bc : a900            >            lda #0     ;precharge accu
07be : 28              >            plp
                        
07bf : 48                       pha
                                tst_a 0,0
07c0 : 08              >            php         ;save flags
07c1 : c900            >            cmp #0     ;test result
                       >            trap_ne
07c3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07c5 : 68              >            pla         ;load status
07c6 : 48              >            pha
                       >            cmp_flag 0
07c7 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
07c9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07cb : 28              >            plp         ;restore status
                        
                                set_a $ff,$ff
                       >            load_flag $ff
07cc : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
07ce : 48              >            pha         ;use stack to load status
07cf : a9ff            >            lda #$ff     ;precharge accu
07d1 : 28              >            plp
                        
07d2 : 48                       pha
                                tst_a $ff,$ff
07d3 : 08              >            php         ;save flags
07d4 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
07d6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07d8 : 68              >            pla         ;load status
07d9 : 48              >            pha
                       >            cmp_flag $ff
07da : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
07dc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07de : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
07df : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
07e1 : 48              >            pha         ;use stack to load status
07e2 : a901            >            lda #1     ;precharge accu
07e4 : 28              >            plp
                        
07e5 : 48                       pha
                                tst_a 1,0
07e6 : 08              >            php         ;save flags
07e7 : c901            >            cmp #1     ;test result
                       >            trap_ne
07e9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07eb : 68              >            pla         ;load status
07ec : 48              >            pha
                       >            cmp_flag 0
07ed : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
07ef : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07f1 : 28              >            plp         ;restore status
                        
                                set_a 0,$ff
                       >            load_flag $ff
07f2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
07f4 : 48              >            pha         ;use stack to load status
07f5 : a900            >            lda #0     ;precharge accu
07f7 : 28              >            plp
                        
07f8 : 48                       pha
                                tst_a 0,$ff
07f9 : 08              >            php         ;save flags
07fa : c900            >            cmp #0     ;test result
                       >            trap_ne
07fc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
07fe : 68              >            pla         ;load status
07ff : 48              >            pha
                       >            cmp_flag $ff
0800 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0802 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0804 : 28              >            plp         ;restore status
                        
                                set_a $ff,0
                       >            load_flag 0
0805 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0807 : 48              >            pha         ;use stack to load status
0808 : a9ff            >            lda #$ff     ;precharge accu
080a : 28              >            plp
                        
080b : 48                       pha
                                tst_a $ff,0
080c : 08              >            php         ;save flags
080d : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
080f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0811 : 68              >            pla         ;load status
0812 : 48              >            pha
                       >            cmp_flag 0
0813 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0815 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0817 : 28              >            plp         ;restore status
                        
                                set_a 0,$ff     ;pull
                       >            load_flag $ff     
0818 : a9ff            >            lda #$ff                  ;allow test to change I-flag (no mask)
                       >
081a : 48              >            pha         ;use stack to load status
081b : a900            >            lda #0     ;precharge accu
081d : 28              >            plp
                        
081e : 68                       pla
                                tst_a $ff,$ff-zero
081f : 08              >            php         ;save flags
0820 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0822 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0824 : 68              >            pla         ;load status
0825 : 48              >            pha
                       >            cmp_flag $ff-zero
0826 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0828 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
082a : 28              >            plp         ;restore status
                        
                                set_a $ff,0
                       >            load_flag 0
082b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
082d : 48              >            pha         ;use stack to load status
082e : a9ff            >            lda #$ff     ;precharge accu
0830 : 28              >            plp
                        
0831 : 68                       pla
                                tst_a 0,zero
0832 : 08              >            php         ;save flags
0833 : c900            >            cmp #0     ;test result
                       >            trap_ne
0835 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0837 : 68              >            pla         ;load status
0838 : 48              >            pha
                       >            cmp_flag zero
0839 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
083b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
083d : 28              >            plp         ;restore status
                        
                                set_a $fe,$ff
                       >            load_flag $ff
083e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0840 : 48              >            pha         ;use stack to load status
0841 : a9fe            >            lda #$fe     ;precharge accu
0843 : 28              >            plp
                        
0844 : 68                       pla
                                tst_a 1,$ff-zero-minus
0845 : 08              >            php         ;save flags
0846 : c901            >            cmp #1     ;test result
                       >            trap_ne
0848 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
084a : 68              >            pla         ;load status
084b : 48              >            pha
                       >            cmp_flag $ff-zero-minus
084c : c97d            >            cmp #($ff-zero-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
084e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0850 : 28              >            plp         ;restore status
                        
                                set_a 0,0
                       >            load_flag 0
0851 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0853 : 48              >            pha         ;use stack to load status
0854 : a900            >            lda #0     ;precharge accu
0856 : 28              >            plp
                        
0857 : 68                       pla
                                tst_a $ff,minus
0858 : 08              >            php         ;save flags
0859 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
085b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
085d : 68              >            pla         ;load status
085e : 48              >            pha
                       >            cmp_flag minus
085f : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0861 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0863 : 28              >            plp         ;restore status
                        
                                set_a $ff,$ff
                       >            load_flag $ff
0864 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0866 : 48              >            pha         ;use stack to load status
0867 : a9ff            >            lda #$ff     ;precharge accu
0869 : 28              >            plp
                        
086a : 68                       pla
                                tst_a 0,$ff-minus
086b : 08              >            php         ;save flags
086c : c900            >            cmp #0     ;test result
                       >            trap_ne
086e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0870 : 68              >            pla         ;load status
0871 : 48              >            pha
                       >            cmp_flag $ff-minus
0872 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0874 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0876 : 28              >            plp         ;restore status
                        
                                set_a $fe,0
                       >            load_flag 0
0877 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0879 : 48              >            pha         ;use stack to load status
087a : a9fe            >            lda #$fe     ;precharge accu
087c : 28              >            plp
                        
087d : 68                       pla
                                tst_a 1,0
087e : 08              >            php         ;save flags
087f : c901            >            cmp #1     ;test result
                       >            trap_ne
0881 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0883 : 68              >            pla         ;load status
0884 : 48              >            pha
                       >            cmp_flag 0
0885 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0887 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0889 : 28              >            plp         ;restore status
                        
088a : e055                     cpx #$55        ;x & y unchanged?
                                trap_ne
088c : d0fe            >        bne *           ;failed not equal (non zero)
                        
088e : c0aa                     cpy #$aa
                                trap_ne
0890 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0892 : ad0002          >            lda test_case   ;previous test
0895 : c905            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0897 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0006 =                 >test_num = test_num + 1
0899 : a906            >            lda #test_num   ;*** next tests' number
089b : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                         
                        ; partial pretest EOR #
                                set_a $3c,0
                       >            load_flag 0
089e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
08a0 : 48              >            pha         ;use stack to load status
08a1 : a93c            >            lda #$3c     ;precharge accu
08a3 : 28              >            plp
                        
08a4 : 49c3                     eor #$c3
                                tst_a $ff,fn
08a6 : 08              >            php         ;save flags
08a7 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
08a9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08ab : 68              >            pla         ;load status
08ac : 48              >            pha
                       >            cmp_flag fn
08ad : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
08af : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08b1 : 28              >            plp         ;restore status
                        
                                set_a $c3,0
                       >            load_flag 0
08b2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
08b4 : 48              >            pha         ;use stack to load status
08b5 : a9c3            >            lda #$c3     ;precharge accu
08b7 : 28              >            plp
                        
08b8 : 49c3                     eor #$c3
                                tst_a 0,fz
08ba : 08              >            php         ;save flags
08bb : c900            >            cmp #0     ;test result
                       >            trap_ne
08bd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08bf : 68              >            pla         ;load status
08c0 : 48              >            pha
                       >            cmp_flag fz
08c1 : c932            >            cmp #(fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
08c3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08c5 : 28              >            plp         ;restore status
                        
                                next_test
08c6 : ad0002          >            lda test_case   ;previous test
08c9 : c906            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
08cb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0007 =                 >test_num = test_num + 1
08cd : a907            >            lda #test_num   ;*** next tests' number
08cf : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; PC modifying instructions except branches (NOP, JMP, JSR, RTS, BRK, RTI)
                        ; testing NOP
08d2 : a224                     ldx #$24
08d4 : a042                     ldy #$42
                                set_a $18,0
                       >            load_flag 0
08d6 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
08d8 : 48              >            pha         ;use stack to load status
08d9 : a918            >            lda #$18     ;precharge accu
08db : 28              >            plp
                        
08dc : ea                       nop
                                tst_a $18,0
08dd : 08              >            php         ;save flags
08de : c918            >            cmp #$18     ;test result
                       >            trap_ne
08e0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08e2 : 68              >            pla         ;load status
08e3 : 48              >            pha
                       >            cmp_flag 0
08e4 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
08e6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
08e8 : 28              >            plp         ;restore status
                        
08e9 : e024                     cpx #$24
                                trap_ne
08eb : d0fe            >        bne *           ;failed not equal (non zero)
                        
08ed : c042                     cpy #$42
                                trap_ne
08ef : d0fe            >        bne *           ;failed not equal (non zero)
                        
08f1 : a2db                     ldx #$db
08f3 : a0bd                     ldy #$bd
                                set_a $e7,$ff
                       >            load_flag $ff
08f5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
08f7 : 48              >            pha         ;use stack to load status
08f8 : a9e7            >            lda #$e7     ;precharge accu
08fa : 28              >            plp
                        
08fb : ea                       nop
                                tst_a $e7,$ff
08fc : 08              >            php         ;save flags
08fd : c9e7            >            cmp #$e7     ;test result
                       >            trap_ne
08ff : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0901 : 68              >            pla         ;load status
0902 : 48              >            pha
                       >            cmp_flag $ff
0903 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0905 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0907 : 28              >            plp         ;restore status
                        
0908 : e0db                     cpx #$db
                                trap_ne
090a : d0fe            >        bne *           ;failed not equal (non zero)
                        
090c : c0bd                     cpy #$bd
                                trap_ne
090e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0910 : ad0002          >            lda test_case   ;previous test
0913 : c907            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0915 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0008 =                 >test_num = test_num + 1
0917 : a908            >            lda #test_num   ;*** next tests' number
0919 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; jump absolute
                                set_stat $0
                       >            load_flag $0
091c : a900            >            lda #$0             ;allow test to change I-flag (no mask)
                       >
091e : 48              >            pha         ;use stack to load status
091f : 28              >            plp
                        
0920 : a946                     lda #'F'
0922 : a241                     ldx #'A'
0924 : a052                     ldy #'R'        ;N=0, V=0, Z=0, C=0
0926 : 4ce034                   jmp test_far
0929 : ea                       nop
092a : ea                       nop
                                trap_ne         ;runover protection
092b : d0fe            >        bne *           ;failed not equal (non zero)
                        
092d : e8                       inx
092e : e8                       inx
092f :                  far_ret 
                                trap_eq         ;returned flags OK?
092f : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
0931 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
0933 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
0935 : 50fe            >        bvc *           ;failed overflow clear
                        
0937 : c9ec                     cmp #('F'^$aa)  ;returned registers OK?
                                trap_ne
0939 : d0fe            >        bne *           ;failed not equal (non zero)
                        
093b : e042                     cpx #('A'+1)
                                trap_ne
093d : d0fe            >        bne *           ;failed not equal (non zero)
                        
093f : c04f                     cpy #('R'-3)
                                trap_ne
0941 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0943 : ca                       dex
0944 : c8                       iny
0945 : c8                       iny
0946 : c8                       iny
0947 : 49aa                     eor #$aa        ;N=0, V=1, Z=0, C=1
0949 : 4c5209                   jmp test_near
094c : ea                       nop
094d : ea                       nop
                                trap_ne         ;runover protection
094e : d0fe            >        bne *           ;failed not equal (non zero)
                        
0950 : e8                       inx
0951 : e8                       inx
0952 :                  test_near
                                trap_eq         ;passed flags OK?
0952 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_mi
0954 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_cc
0956 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
0958 : 50fe            >        bvc *           ;failed overflow clear
                        
095a : c946                     cmp #'F'        ;passed registers OK?
                                trap_ne
095c : d0fe            >        bne *           ;failed not equal (non zero)
                        
095e : e041                     cpx #'A'
                                trap_ne
0960 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0962 : c052                     cpy #'R'
                                trap_ne
0964 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0966 : ad0002          >            lda test_case   ;previous test
0969 : c908            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
096b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0009 =                 >test_num = test_num + 1
096d : a909            >            lda #test_num   ;*** next tests' number
096f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; jump indirect
                                set_stat 0
                       >            load_flag 0
0972 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0974 : 48              >            pha         ;use stack to load status
0975 : 28              >            plp
                        
0976 : a949                     lda #'I'
0978 : a24e                     ldx #'N'
097a : a044                     ldy #'D'        ;N=0, V=0, Z=0, C=0
097c : 6c0e35                   jmp (ptr_tst_ind)
097f : ea                       nop
                                trap_ne         ;runover protection
0980 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0982 : 88                       dey
0983 : 88                       dey
0984 :                  ind_ret 
0984 : 08                       php             ;either SP or Y count will fail, if we do not hit
0985 : 88                       dey
0986 : 88                       dey
0987 : 88                       dey
0988 : 28                       plp
                                trap_eq         ;returned flags OK?
0989 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
098b : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
098d : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
098f : 50fe            >        bvc *           ;failed overflow clear
                        
0991 : c9e3                     cmp #('I'^$aa)  ;returned registers OK?
                                trap_ne
0993 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0995 : e04f                     cpx #('N'+1)
                                trap_ne
0997 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0999 : c03e                     cpy #('D'-6)
                                trap_ne
099b : d0fe            >        bne *           ;failed not equal (non zero)
                        
099d : ba                       tsx             ;SP check
099e : e0ff                     cpx #$ff
                                trap_ne
09a0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
09a2 : ad0002          >            lda test_case   ;previous test
09a5 : c909            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
09a7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000a =                 >test_num = test_num + 1
09a9 : a90a            >            lda #test_num   ;*** next tests' number
09ab : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; jump subroutine & return from subroutine
                                set_stat 0
                       >            load_flag 0
09ae : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
09b0 : 48              >            pha         ;use stack to load status
09b1 : 28              >            plp
                        
09b2 : a94a                     lda #'J'
09b4 : a253                     ldx #'S'
09b6 : a052                     ldy #'R'        ;N=0, V=0, Z=0, C=0
09b8 : 204d35                   jsr test_jsr
09ba =                  jsr_ret = *-1           ;last address of jsr = return address
09bb : 08                       php             ;either SP or Y count will fail, if we do not hit
09bc : 88                       dey
09bd : 88                       dey
09be : 88                       dey
09bf : 28                       plp
                                trap_eq         ;returned flags OK?
09c0 : f0fe            >        beq *           ;failed equal (zero)
                        
                                trap_pl
09c2 : 10fe            >        bpl *           ;failed plus (bit 7 clear)
                        
                                trap_cc
09c4 : 90fe            >        bcc *           ;failed carry clear
                        
                                trap_vc
09c6 : 50fe            >        bvc *           ;failed overflow clear
                        
09c8 : c9e0                     cmp #('J'^$aa)  ;returned registers OK?
                                trap_ne
09ca : d0fe            >        bne *           ;failed not equal (non zero)
                        
09cc : e054                     cpx #('S'+1)
                                trap_ne
09ce : d0fe            >        bne *           ;failed not equal (non zero)
                        
09d0 : c04c                     cpy #('R'-6)
                                trap_ne
09d2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
09d4 : ba                       tsx             ;sp?
09d5 : e0ff                     cpx #$ff
                                trap_ne
09d7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
09d9 : ad0002          >            lda test_case   ;previous test
09dc : c90a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
09de : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000b =                 >test_num = test_num + 1
09e0 : a90b            >            lda #test_num   ;*** next tests' number
09e2 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; break & return from interrupt
                            if ROM_vectors = 1
                                load_flag 0     ;with interrupts enabled if allowed!
09e5 : a900            >            lda #0                  ;allow test to change I-flag (no mask)
                        
09e7 : 48                       pha
09e8 : a942                     lda #'B'
09ea : a252                     ldx #'R'
09ec : a04b                     ldy #'K'
09ee : 28                       plp             ;N=0, V=0, Z=0, C=0
09ef : 00                       brk
                            else
                                lda #hi brk_ret0 ;emulated break
                                pha
                                lda #lo brk_ret0
                                pha
                                load_flag fao    ;set break & unused on stack
                                pha
                                load_flag intdis ;during interrupt
                                pha
                                lda #'B'
                                ldx #'R'
                                ldy #'K'
                                plp             ;N=0, V=0, Z=0, C=0
                                jmp irq_trap
                            endif
09f0 : 88                       dey             ;should not be executed
09f1 :                  brk_ret0                ;address of break return
09f1 : 08                       php             ;either SP or Y count will fail, if we do not hit
09f2 : 88                       dey
09f3 : 88                       dey
09f4 : 88                       dey
09f5 : c9e8                     cmp #'B'^$aa    ;returned registers OK?
                                ;the IRQ vector was never executed if A & X stay unmodified
                                trap_ne
09f7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
09f9 : e053                     cpx #'R'+1
                                trap_ne
09fb : d0fe            >        bne *           ;failed not equal (non zero)
                        
09fd : c045                     cpy #'K'-6
                                trap_ne
09ff : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a01 : 68                       pla             ;returned flags OK (unchanged)?
                                cmp_flag 0
0a02 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0a04 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a06 : ba                       tsx             ;sp?
0a07 : e0ff                     cpx #$ff
                                trap_ne
0a09 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                            if ROM_vectors = 1
                                load_flag $ff   ;with interrupts disabled if allowed!
0a0b : a9ff            >            lda #$ff                ;allow test to change I-flag (no mask)
                        
0a0d : 48                       pha
0a0e : a9bd                     lda #$ff-'B'
0a10 : a2ad                     ldx #$ff-'R'
0a12 : a0b4                     ldy #$ff-'K'
0a14 : 28                       plp             ;N=1, V=1, Z=1, C=1
0a15 : 00                       brk
                            else
                                lda #hi brk_ret1 ;emulated break
                                pha
                                lda #lo brk_ret1
                                pha
                                load_flag $ff
                                pha             ;set break & unused on stack
                                pha             ;actual flags
                                lda #$ff-'B'
                                ldx #$ff-'R'
                                ldy #$ff-'K'
                                plp             ;N=1, V=1, Z=1, C=1
                                jmp irq_trap
                            endif
0a16 : 88                       dey             ;should not be executed
0a17 :                  brk_ret1                ;address of break return
0a17 : 08                       php             ;either SP or Y count will fail, if we do not hit
0a18 : 88                       dey
0a19 : 88                       dey
0a1a : 88                       dey
0a1b : c917                     cmp #($ff-'B')^$aa  ;returned registers OK?
                                ;the IRQ vector was never executed if A & X stay unmodified
                                trap_ne
0a1d : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a1f : e0ae                     cpx #$ff-'R'+1
                                trap_ne
0a21 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a23 : c0ae                     cpy #$ff-'K'-6
                                trap_ne
0a25 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a27 : 68                       pla             ;returned flags OK (unchanged)?
                                cmp_flag $ff
0a28 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0a2a : d0fe            >        bne *           ;failed not equal (non zero)
                        
0a2c : ba                       tsx             ;sp?
0a2d : e0ff                     cpx #$ff
                                trap_ne
0a2f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                next_test
0a31 : ad0002          >            lda test_case   ;previous test
0a34 : c90b            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0a36 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000c =                 >test_num = test_num + 1
0a38 : a90c            >            lda #test_num   ;*** next tests' number
0a3a : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                         
                        ; test set and clear flags CLC CLI CLD CLV SEC SEI SED
                                set_stat $ff
                       >            load_flag $ff
0a3d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0a3f : 48              >            pha         ;use stack to load status
0a40 : 28              >            plp
                        
0a41 : 18                       clc
                                tst_stat $ff-carry
0a42 : 08              >            php         ;save status
0a43 : 68              >            pla         ;use stack to retrieve status
0a44 : 48              >            pha
                       >            cmp_flag $ff-carry
0a45 : c9fe            >            cmp #($ff-carry|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a47 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a49 : 28              >            plp         ;restore status
                        
0a4a : 38                       sec
                                tst_stat $ff
0a4b : 08              >            php         ;save status
0a4c : 68              >            pla         ;use stack to retrieve status
0a4d : 48              >            pha
                       >            cmp_flag $ff
0a4e : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a50 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a52 : 28              >            plp         ;restore status
                        
                            if I_flag = 3
0a53 : 58                       cli
                                tst_stat $ff-intdis
0a54 : 08              >            php         ;save status
0a55 : 68              >            pla         ;use stack to retrieve status
0a56 : 48              >            pha
                       >            cmp_flag $ff-intdis
0a57 : c9fb            >            cmp #($ff-intdis|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a59 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a5b : 28              >            plp         ;restore status
                        
0a5c : 78                       sei
                                tst_stat $ff
0a5d : 08              >            php         ;save status
0a5e : 68              >            pla         ;use stack to retrieve status
0a5f : 48              >            pha
                       >            cmp_flag $ff
0a60 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a62 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a64 : 28              >            plp         ;restore status
                        
                            endif
0a65 : d8                       cld
                                tst_stat $ff-decmode
0a66 : 08              >            php         ;save status
0a67 : 68              >            pla         ;use stack to retrieve status
0a68 : 48              >            pha
                       >            cmp_flag $ff-decmode
0a69 : c9f7            >            cmp #($ff-decmode|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a6b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a6d : 28              >            plp         ;restore status
                        
0a6e : f8                       sed
                                tst_stat $ff
0a6f : 08              >            php         ;save status
0a70 : 68              >            pla         ;use stack to retrieve status
0a71 : 48              >            pha
                       >            cmp_flag $ff
0a72 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a74 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a76 : 28              >            plp         ;restore status
                        
0a77 : b8                       clv
                                tst_stat $ff-overfl
0a78 : 08              >            php         ;save status
0a79 : 68              >            pla         ;use stack to retrieve status
0a7a : 48              >            pha
                       >            cmp_flag $ff-overfl
0a7b : c9bf            >            cmp #($ff-overfl|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a7d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a7f : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0a80 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0a82 : 48              >            pha         ;use stack to load status
0a83 : 28              >            plp
                        
                                tst_stat 0
0a84 : 08              >            php         ;save status
0a85 : 68              >            pla         ;use stack to retrieve status
0a86 : 48              >            pha
                       >            cmp_flag 0
0a87 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a89 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a8b : 28              >            plp         ;restore status
                        
0a8c : 38                       sec
                                tst_stat carry
0a8d : 08              >            php         ;save status
0a8e : 68              >            pla         ;use stack to retrieve status
0a8f : 48              >            pha
                       >            cmp_flag carry
0a90 : c931            >            cmp #(carry|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a92 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a94 : 28              >            plp         ;restore status
                        
0a95 : 18                       clc
                                tst_stat 0  
0a96 : 08              >            php         ;save status
0a97 : 68              >            pla         ;use stack to retrieve status
0a98 : 48              >            pha
                       >            cmp_flag 0  
0a99 : c930            >            cmp #(0  |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0a9b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0a9d : 28              >            plp         ;restore status
                        
                            if I_flag = 3
0a9e : 78                       sei
                                tst_stat intdis
0a9f : 08              >            php         ;save status
0aa0 : 68              >            pla         ;use stack to retrieve status
0aa1 : 48              >            pha
                       >            cmp_flag intdis
0aa2 : c934            >            cmp #(intdis|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0aa4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0aa6 : 28              >            plp         ;restore status
                        
0aa7 : 58                       cli
                                tst_stat 0
0aa8 : 08              >            php         ;save status
0aa9 : 68              >            pla         ;use stack to retrieve status
0aaa : 48              >            pha
                       >            cmp_flag 0
0aab : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0aad : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0aaf : 28              >            plp         ;restore status
                        
                            endif  
0ab0 : f8                       sed
                                tst_stat decmode
0ab1 : 08              >            php         ;save status
0ab2 : 68              >            pla         ;use stack to retrieve status
0ab3 : 48              >            pha
                       >            cmp_flag decmode
0ab4 : c938            >            cmp #(decmode|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ab6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ab8 : 28              >            plp         ;restore status
                        
0ab9 : d8                       cld
                                tst_stat 0  
0aba : 08              >            php         ;save status
0abb : 68              >            pla         ;use stack to retrieve status
0abc : 48              >            pha
                       >            cmp_flag 0  
0abd : c930            >            cmp #(0  |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0abf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ac1 : 28              >            plp         ;restore status
                        
                                set_stat overfl
                       >            load_flag overfl
0ac2 : a940            >            lda #overfl             ;allow test to change I-flag (no mask)
                       >
0ac4 : 48              >            pha         ;use stack to load status
0ac5 : 28              >            plp
                        
                                tst_stat overfl
0ac6 : 08              >            php         ;save status
0ac7 : 68              >            pla         ;use stack to retrieve status
0ac8 : 48              >            pha
                       >            cmp_flag overfl
0ac9 : c970            >            cmp #(overfl|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0acb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0acd : 28              >            plp         ;restore status
                        
0ace : b8                       clv
                                tst_stat 0
0acf : 08              >            php         ;save status
0ad0 : 68              >            pla         ;use stack to retrieve status
0ad1 : 48              >            pha
                       >            cmp_flag 0
0ad2 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ad4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ad6 : 28              >            plp         ;restore status
                        
                                next_test
0ad7 : ad0002          >            lda test_case   ;previous test
0ada : c90c            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0adc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000d =                 >test_num = test_num + 1
0ade : a90d            >            lda #test_num   ;*** next tests' number
0ae0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        ; testing index register increment/decrement and transfer
                        ; INX INY DEX DEY TAX TXA TAY TYA 
0ae3 : a2fe                     ldx #$fe
                                set_stat $ff
                       >            load_flag $ff
0ae5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0ae7 : 48              >            pha         ;use stack to load status
0ae8 : 28              >            plp
                        
0ae9 : e8                       inx             ;ff
                                tst_x $ff,$ff-zero
0aea : 08              >            php         ;save flags
0aeb : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0aed : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0aef : 68              >            pla         ;load status
0af0 : 48              >            pha
                       >            cmp_flag $ff-zero
0af1 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0af3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0af5 : 28              >            plp         ;restore status
                        
0af6 : e8                       inx             ;00
                                tst_x 0,$ff-minus
0af7 : 08              >            php         ;save flags
0af8 : e000            >            cpx #0     ;test result
                       >            trap_ne
0afa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0afc : 68              >            pla         ;load status
0afd : 48              >            pha
                       >            cmp_flag $ff-minus
0afe : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b00 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b02 : 28              >            plp         ;restore status
                        
0b03 : e8                       inx             ;01
                                tst_x 1,$ff-minus-zero
0b04 : 08              >            php         ;save flags
0b05 : e001            >            cpx #1     ;test result
                       >            trap_ne
0b07 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b09 : 68              >            pla         ;load status
0b0a : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0b0b : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b0d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b0f : 28              >            plp         ;restore status
                        
0b10 : ca                       dex             ;00
                                tst_x 0,$ff-minus
0b11 : 08              >            php         ;save flags
0b12 : e000            >            cpx #0     ;test result
                       >            trap_ne
0b14 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b16 : 68              >            pla         ;load status
0b17 : 48              >            pha
                       >            cmp_flag $ff-minus
0b18 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b1a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b1c : 28              >            plp         ;restore status
                        
0b1d : ca                       dex             ;ff
                                tst_x $ff,$ff-zero
0b1e : 08              >            php         ;save flags
0b1f : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0b21 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b23 : 68              >            pla         ;load status
0b24 : 48              >            pha
                       >            cmp_flag $ff-zero
0b25 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b27 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b29 : 28              >            plp         ;restore status
                        
0b2a : ca                       dex             ;fe
                                set_stat 0
                       >            load_flag 0
0b2b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0b2d : 48              >            pha         ;use stack to load status
0b2e : 28              >            plp
                        
0b2f : e8                       inx             ;ff
                                tst_x $ff,minus
0b30 : 08              >            php         ;save flags
0b31 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0b33 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b35 : 68              >            pla         ;load status
0b36 : 48              >            pha
                       >            cmp_flag minus
0b37 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b39 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b3b : 28              >            plp         ;restore status
                        
0b3c : e8                       inx             ;00
                                tst_x 0,zero
0b3d : 08              >            php         ;save flags
0b3e : e000            >            cpx #0     ;test result
                       >            trap_ne
0b40 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b42 : 68              >            pla         ;load status
0b43 : 48              >            pha
                       >            cmp_flag zero
0b44 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b46 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b48 : 28              >            plp         ;restore status
                        
0b49 : e8                       inx             ;01
                                tst_x 1,0
0b4a : 08              >            php         ;save flags
0b4b : e001            >            cpx #1     ;test result
                       >            trap_ne
0b4d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b4f : 68              >            pla         ;load status
0b50 : 48              >            pha
                       >            cmp_flag 0
0b51 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b53 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b55 : 28              >            plp         ;restore status
                        
0b56 : ca                       dex             ;00
                                tst_x 0,zero
0b57 : 08              >            php         ;save flags
0b58 : e000            >            cpx #0     ;test result
                       >            trap_ne
0b5a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b5c : 68              >            pla         ;load status
0b5d : 48              >            pha
                       >            cmp_flag zero
0b5e : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b60 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b62 : 28              >            plp         ;restore status
                        
0b63 : ca                       dex             ;ff
                                tst_x $ff,minus
0b64 : 08              >            php         ;save flags
0b65 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0b67 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b69 : 68              >            pla         ;load status
0b6a : 48              >            pha
                       >            cmp_flag minus
0b6b : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b6d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b6f : 28              >            plp         ;restore status
                        
                        
0b70 : a0fe                     ldy #$fe
                                set_stat $ff
                       >            load_flag $ff
0b72 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0b74 : 48              >            pha         ;use stack to load status
0b75 : 28              >            plp
                        
0b76 : c8                       iny             ;ff
                                tst_y $ff,$ff-zero
0b77 : 08              >            php         ;save flags
0b78 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0b7a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b7c : 68              >            pla         ;load status
0b7d : 48              >            pha
                       >            cmp_flag $ff-zero
0b7e : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b80 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b82 : 28              >            plp         ;restore status
                        
0b83 : c8                       iny             ;00
                                tst_y 0,$ff-minus
0b84 : 08              >            php         ;save flags
0b85 : c000            >            cpy #0     ;test result
                       >            trap_ne
0b87 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b89 : 68              >            pla         ;load status
0b8a : 48              >            pha
                       >            cmp_flag $ff-minus
0b8b : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b8d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b8f : 28              >            plp         ;restore status
                        
0b90 : c8                       iny             ;01
                                tst_y 1,$ff-minus-zero
0b91 : 08              >            php         ;save flags
0b92 : c001            >            cpy #1     ;test result
                       >            trap_ne
0b94 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b96 : 68              >            pla         ;load status
0b97 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0b98 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0b9a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0b9c : 28              >            plp         ;restore status
                        
0b9d : 88                       dey             ;00
                                tst_y 0,$ff-minus
0b9e : 08              >            php         ;save flags
0b9f : c000            >            cpy #0     ;test result
                       >            trap_ne
0ba1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ba3 : 68              >            pla         ;load status
0ba4 : 48              >            pha
                       >            cmp_flag $ff-minus
0ba5 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ba7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ba9 : 28              >            plp         ;restore status
                        
0baa : 88                       dey             ;ff
                                tst_y $ff,$ff-zero
0bab : 08              >            php         ;save flags
0bac : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0bae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bb0 : 68              >            pla         ;load status
0bb1 : 48              >            pha
                       >            cmp_flag $ff-zero
0bb2 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bb4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bb6 : 28              >            plp         ;restore status
                        
0bb7 : 88                       dey             ;fe
                                set_stat 0
                       >            load_flag 0
0bb8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0bba : 48              >            pha         ;use stack to load status
0bbb : 28              >            plp
                        
0bbc : c8                       iny             ;ff
                                tst_y $ff,0+minus
0bbd : 08              >            php         ;save flags
0bbe : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0bc0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bc2 : 68              >            pla         ;load status
0bc3 : 48              >            pha
                       >            cmp_flag 0+minus
0bc4 : c9b0            >            cmp #(0+minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bc6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bc8 : 28              >            plp         ;restore status
                        
0bc9 : c8                       iny             ;00
                                tst_y 0,zero
0bca : 08              >            php         ;save flags
0bcb : c000            >            cpy #0     ;test result
                       >            trap_ne
0bcd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bcf : 68              >            pla         ;load status
0bd0 : 48              >            pha
                       >            cmp_flag zero
0bd1 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bd3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bd5 : 28              >            plp         ;restore status
                        
0bd6 : c8                       iny             ;01
                                tst_y 1,0
0bd7 : 08              >            php         ;save flags
0bd8 : c001            >            cpy #1     ;test result
                       >            trap_ne
0bda : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bdc : 68              >            pla         ;load status
0bdd : 48              >            pha
                       >            cmp_flag 0
0bde : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0be0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0be2 : 28              >            plp         ;restore status
                        
0be3 : 88                       dey             ;00
                                tst_y 0,zero
0be4 : 08              >            php         ;save flags
0be5 : c000            >            cpy #0     ;test result
                       >            trap_ne
0be7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0be9 : 68              >            pla         ;load status
0bea : 48              >            pha
                       >            cmp_flag zero
0beb : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bed : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bef : 28              >            plp         ;restore status
                        
0bf0 : 88                       dey             ;ff
                                tst_y $ff,minus
0bf1 : 08              >            php         ;save flags
0bf2 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0bf4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bf6 : 68              >            pla         ;load status
0bf7 : 48              >            pha
                       >            cmp_flag minus
0bf8 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0bfa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0bfc : 28              >            plp         ;restore status
                        
                                        
0bfd : a2ff                     ldx #$ff
                                set_stat $ff
                       >            load_flag $ff
0bff : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0c01 : 48              >            pha         ;use stack to load status
0c02 : 28              >            plp
                        
0c03 : 8a                       txa
                                tst_a $ff,$ff-zero
0c04 : 08              >            php         ;save flags
0c05 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0c07 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c09 : 68              >            pla         ;load status
0c0a : 48              >            pha
                       >            cmp_flag $ff-zero
0c0b : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c0d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c0f : 28              >            plp         ;restore status
                        
0c10 : 08                       php
0c11 : e8                       inx             ;00
0c12 : 28                       plp
0c13 : 8a                       txa
                                tst_a 0,$ff-minus
0c14 : 08              >            php         ;save flags
0c15 : c900            >            cmp #0     ;test result
                       >            trap_ne
0c17 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c19 : 68              >            pla         ;load status
0c1a : 48              >            pha
                       >            cmp_flag $ff-minus
0c1b : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c1d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c1f : 28              >            plp         ;restore status
                        
0c20 : 08                       php
0c21 : e8                       inx             ;01
0c22 : 28                       plp
0c23 : 8a                       txa
                                tst_a 1,$ff-minus-zero
0c24 : 08              >            php         ;save flags
0c25 : c901            >            cmp #1     ;test result
                       >            trap_ne
0c27 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c29 : 68              >            pla         ;load status
0c2a : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0c2b : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c2d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c2f : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0c30 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0c32 : 48              >            pha         ;use stack to load status
0c33 : 28              >            plp
                        
0c34 : 8a                       txa
                                tst_a 1,0
0c35 : 08              >            php         ;save flags
0c36 : c901            >            cmp #1     ;test result
                       >            trap_ne
0c38 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c3a : 68              >            pla         ;load status
0c3b : 48              >            pha
                       >            cmp_flag 0
0c3c : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c3e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c40 : 28              >            plp         ;restore status
                        
0c41 : 08                       php
0c42 : ca                       dex             ;00
0c43 : 28                       plp
0c44 : 8a                       txa
                                tst_a 0,zero
0c45 : 08              >            php         ;save flags
0c46 : c900            >            cmp #0     ;test result
                       >            trap_ne
0c48 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c4a : 68              >            pla         ;load status
0c4b : 48              >            pha
                       >            cmp_flag zero
0c4c : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c4e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c50 : 28              >            plp         ;restore status
                        
0c51 : 08                       php
0c52 : ca                       dex             ;ff
0c53 : 28                       plp
0c54 : 8a                       txa
                                tst_a $ff,minus
0c55 : 08              >            php         ;save flags
0c56 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0c58 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c5a : 68              >            pla         ;load status
0c5b : 48              >            pha
                       >            cmp_flag minus
0c5c : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c5e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c60 : 28              >            plp         ;restore status
                        
                                                
0c61 : a0ff                     ldy #$ff
                                set_stat $ff
                       >            load_flag $ff
0c63 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0c65 : 48              >            pha         ;use stack to load status
0c66 : 28              >            plp
                        
0c67 : 98                       tya
                                tst_a $ff,$ff-zero
0c68 : 08              >            php         ;save flags
0c69 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0c6b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c6d : 68              >            pla         ;load status
0c6e : 48              >            pha
                       >            cmp_flag $ff-zero
0c6f : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c71 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c73 : 28              >            plp         ;restore status
                        
0c74 : 08                       php
0c75 : c8                       iny             ;00
0c76 : 28                       plp
0c77 : 98                       tya
                                tst_a 0,$ff-minus
0c78 : 08              >            php         ;save flags
0c79 : c900            >            cmp #0     ;test result
                       >            trap_ne
0c7b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c7d : 68              >            pla         ;load status
0c7e : 48              >            pha
                       >            cmp_flag $ff-minus
0c7f : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c81 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c83 : 28              >            plp         ;restore status
                        
0c84 : 08                       php
0c85 : c8                       iny             ;01
0c86 : 28                       plp
0c87 : 98                       tya
                                tst_a 1,$ff-minus-zero
0c88 : 08              >            php         ;save flags
0c89 : c901            >            cmp #1     ;test result
                       >            trap_ne
0c8b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c8d : 68              >            pla         ;load status
0c8e : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0c8f : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0c91 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c93 : 28              >            plp         ;restore status
                        
                                set_stat 0
                       >            load_flag 0
0c94 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0c96 : 48              >            pha         ;use stack to load status
0c97 : 28              >            plp
                        
0c98 : 98                       tya
                                tst_a 1,0
0c99 : 08              >            php         ;save flags
0c9a : c901            >            cmp #1     ;test result
                       >            trap_ne
0c9c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0c9e : 68              >            pla         ;load status
0c9f : 48              >            pha
                       >            cmp_flag 0
0ca0 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ca2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ca4 : 28              >            plp         ;restore status
                        
0ca5 : 08                       php
0ca6 : 88                       dey             ;00
0ca7 : 28                       plp
0ca8 : 98                       tya
                                tst_a 0,zero
0ca9 : 08              >            php         ;save flags
0caa : c900            >            cmp #0     ;test result
                       >            trap_ne
0cac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cae : 68              >            pla         ;load status
0caf : 48              >            pha
                       >            cmp_flag zero
0cb0 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0cb2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cb4 : 28              >            plp         ;restore status
                        
0cb5 : 08                       php
0cb6 : 88                       dey             ;ff
0cb7 : 28                       plp
0cb8 : 98                       tya
                                tst_a $ff,minus
0cb9 : 08              >            php         ;save flags
0cba : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
0cbc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cbe : 68              >            pla         ;load status
0cbf : 48              >            pha
                       >            cmp_flag minus
0cc0 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0cc2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cc4 : 28              >            plp         ;restore status
                        
                        
                                load_flag $ff
0cc5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
0cc7 : 48                       pha
0cc8 : a2ff                     ldx #$ff        ;ff
0cca : 8a                       txa
0ccb : 28                       plp             
0ccc : a8                       tay
                                tst_y $ff,$ff-zero
0ccd : 08              >            php         ;save flags
0cce : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0cd0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cd2 : 68              >            pla         ;load status
0cd3 : 48              >            pha
                       >            cmp_flag $ff-zero
0cd4 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0cd6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cd8 : 28              >            plp         ;restore status
                        
0cd9 : 08                       php
0cda : e8                       inx             ;00
0cdb : 8a                       txa
0cdc : 28                       plp
0cdd : a8                       tay
                                tst_y 0,$ff-minus
0cde : 08              >            php         ;save flags
0cdf : c000            >            cpy #0     ;test result
                       >            trap_ne
0ce1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ce3 : 68              >            pla         ;load status
0ce4 : 48              >            pha
                       >            cmp_flag $ff-minus
0ce5 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0ce7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0ce9 : 28              >            plp         ;restore status
                        
0cea : 08                       php
0ceb : e8                       inx             ;01
0cec : 8a                       txa
0ced : 28                       plp
0cee : a8                       tay
                                tst_y 1,$ff-minus-zero
0cef : 08              >            php         ;save flags
0cf0 : c001            >            cpy #1     ;test result
                       >            trap_ne
0cf2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cf4 : 68              >            pla         ;load status
0cf5 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0cf6 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0cf8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0cfa : 28              >            plp         ;restore status
                        
                                load_flag 0
0cfb : a900            >            lda #0             ;allow test to change I-flag (no mask)
                        
0cfd : 48                       pha
0cfe : a900                     lda #0
0d00 : 8a                       txa
0d01 : 28                       plp
0d02 : a8                       tay
                                tst_y 1,0
0d03 : 08              >            php         ;save flags
0d04 : c001            >            cpy #1     ;test result
                       >            trap_ne
0d06 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d08 : 68              >            pla         ;load status
0d09 : 48              >            pha
                       >            cmp_flag 0
0d0a : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d0c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d0e : 28              >            plp         ;restore status
                        
0d0f : 08                       php
0d10 : ca                       dex             ;00
0d11 : 8a                       txa
0d12 : 28                       plp
0d13 : a8                       tay
                                tst_y 0,zero
0d14 : 08              >            php         ;save flags
0d15 : c000            >            cpy #0     ;test result
                       >            trap_ne
0d17 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d19 : 68              >            pla         ;load status
0d1a : 48              >            pha
                       >            cmp_flag zero
0d1b : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d1d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d1f : 28              >            plp         ;restore status
                        
0d20 : 08                       php
0d21 : ca                       dex             ;ff
0d22 : 8a                       txa
0d23 : 28                       plp
0d24 : a8                       tay
                                tst_y $ff,minus
0d25 : 08              >            php         ;save flags
0d26 : c0ff            >            cpy #$ff     ;test result
                       >            trap_ne
0d28 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d2a : 68              >            pla         ;load status
0d2b : 48              >            pha
                       >            cmp_flag minus
0d2c : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d2e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d30 : 28              >            plp         ;restore status
                        
                        
                        
                                load_flag $ff
0d31 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
0d33 : 48                       pha
0d34 : a0ff                     ldy #$ff        ;ff
0d36 : 98                       tya
0d37 : 28                       plp
0d38 : aa                       tax
                                tst_x $ff,$ff-zero
0d39 : 08              >            php         ;save flags
0d3a : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0d3c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d3e : 68              >            pla         ;load status
0d3f : 48              >            pha
                       >            cmp_flag $ff-zero
0d40 : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d42 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d44 : 28              >            plp         ;restore status
                        
0d45 : 08                       php
0d46 : c8                       iny             ;00
0d47 : 98                       tya
0d48 : 28                       plp
0d49 : aa                       tax
                                tst_x 0,$ff-minus
0d4a : 08              >            php         ;save flags
0d4b : e000            >            cpx #0     ;test result
                       >            trap_ne
0d4d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d4f : 68              >            pla         ;load status
0d50 : 48              >            pha
                       >            cmp_flag $ff-minus
0d51 : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d53 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d55 : 28              >            plp         ;restore status
                        
0d56 : 08                       php
0d57 : c8                       iny             ;01
0d58 : 98                       tya
0d59 : 28                       plp
0d5a : aa                       tax
                                tst_x 1,$ff-minus-zero
0d5b : 08              >            php         ;save flags
0d5c : e001            >            cpx #1     ;test result
                       >            trap_ne
0d5e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d60 : 68              >            pla         ;load status
0d61 : 48              >            pha
                       >            cmp_flag $ff-minus-zero
0d62 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d64 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d66 : 28              >            plp         ;restore status
                        
                                load_flag 0
0d67 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                        
0d69 : 48                       pha
0d6a : a900                     lda #0          ;preset status
0d6c : 98                       tya
0d6d : 28                       plp
0d6e : aa                       tax
                                tst_x 1,0
0d6f : 08              >            php         ;save flags
0d70 : e001            >            cpx #1     ;test result
                       >            trap_ne
0d72 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d74 : 68              >            pla         ;load status
0d75 : 48              >            pha
                       >            cmp_flag 0
0d76 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d78 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d7a : 28              >            plp         ;restore status
                        
0d7b : 08                       php
0d7c : 88                       dey             ;00
0d7d : 98                       tya
0d7e : 28                       plp
0d7f : aa                       tax
                                tst_x 0,zero
0d80 : 08              >            php         ;save flags
0d81 : e000            >            cpx #0     ;test result
                       >            trap_ne
0d83 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d85 : 68              >            pla         ;load status
0d86 : 48              >            pha
                       >            cmp_flag zero
0d87 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d89 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d8b : 28              >            plp         ;restore status
                        
0d8c : 08                       php
0d8d : 88                       dey             ;ff
0d8e : 98                       tya
0d8f : 28                       plp
0d90 : aa                       tax
                                tst_x $ff,minus
0d91 : 08              >            php         ;save flags
0d92 : e0ff            >            cpx #$ff     ;test result
                       >            trap_ne
0d94 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d96 : 68              >            pla         ;load status
0d97 : 48              >            pha
                       >            cmp_flag minus
0d98 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
0d9a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0d9c : 28              >            plp         ;restore status
                        
                                next_test
0d9d : ad0002          >            lda test_case   ;previous test
0da0 : c90d            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0da2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000e =                 >test_num = test_num + 1
0da4 : a90e            >            lda #test_num   ;*** next tests' number
0da6 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                             
                        ;TSX sets NZ - TXS does not
                        ;  This section also tests for proper stack wrap around.
0da9 : a201                     ldx #1          ;01
                                set_stat $ff
                       >            load_flag $ff
0dab : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0dad : 48              >            pha         ;use stack to load status
0dae : 28              >            plp
                        
0daf : 9a                       txs
0db0 : 08                       php
0db1 : ad0101                   lda $101
                                cmp_flag $ff
0db4 : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0db6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0db8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0dba : 48              >            pha         ;use stack to load status
0dbb : 28              >            plp
                        
0dbc : 9a                       txs
0dbd : 08                       php
0dbe : ad0101                   lda $101
                                cmp_flag 0
0dc1 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0dc3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0dc5 : ca                       dex             ;00
                                set_stat $ff
                       >            load_flag $ff
0dc6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0dc8 : 48              >            pha         ;use stack to load status
0dc9 : 28              >            plp
                        
0dca : 9a                       txs
0dcb : 08                       php
0dcc : ad0001                   lda $100
                                cmp_flag $ff
0dcf : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0dd1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0dd3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0dd5 : 48              >            pha         ;use stack to load status
0dd6 : 28              >            plp
                        
0dd7 : 9a                       txs
0dd8 : 08                       php
0dd9 : ad0001                   lda $100
                                cmp_flag 0
0ddc : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0dde : d0fe            >        bne *           ;failed not equal (non zero)
                        
0de0 : ca                       dex             ;ff
                                set_stat $ff
                       >            load_flag $ff
0de1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0de3 : 48              >            pha         ;use stack to load status
0de4 : 28              >            plp
                        
0de5 : 9a                       txs
0de6 : 08                       php
0de7 : adff01                   lda $1ff
                                cmp_flag $ff
0dea : c9ff            >            cmp #($ff|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0dec : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0dee : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0df0 : 48              >            pha         ;use stack to load status
0df1 : 28              >            plp
                        
0df2 : 9a                       txs
0df3 : 08                       php
0df4 : adff01                   lda $1ff
                                cmp_flag 0
0df7 : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                
0df9 : a201                     ldx #1
0dfb : 9a                       txs             ;sp=01
                                set_stat $ff
                       >            load_flag $ff
0dfc : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0dfe : 48              >            pha         ;use stack to load status
0dff : 28              >            plp
                        
0e00 : ba                       tsx             ;clears Z, N
0e01 : 08                       php             ;sp=00
0e02 : e001                     cpx #1
                                trap_ne
0e04 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e06 : ad0101                   lda $101
                                cmp_flag $ff-minus-zero
0e09 : c97d            >            cmp #($ff-minus-zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0e0b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
0e0d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0e0f : 48              >            pha         ;use stack to load status
0e10 : 28              >            plp
                        
0e11 : ba                       tsx             ;clears N, sets Z
0e12 : 08                       php             ;sp=ff
0e13 : e000                     cpx #0
                                trap_ne
0e15 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e17 : ad0001                   lda $100
                                cmp_flag $ff-minus
0e1a : c97f            >            cmp #($ff-minus|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0e1c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
0e1e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0e20 : 48              >            pha         ;use stack to load status
0e21 : 28              >            plp
                        
0e22 : ba                       tsx             ;clears N, sets Z
0e23 : 08                       php             ;sp=fe
0e24 : e0ff                     cpx #$ff
                                trap_ne
0e26 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e28 : adff01                   lda $1ff
                                cmp_flag $ff-zero
0e2b : c9fd            >            cmp #($ff-zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0e2d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                
0e2f : a201                     ldx #1
0e31 : 9a                       txs             ;sp=01
                                set_stat 0
                       >            load_flag 0
0e32 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0e34 : 48              >            pha         ;use stack to load status
0e35 : 28              >            plp
                        
0e36 : ba                       tsx             ;clears Z, N
0e37 : 08                       php             ;sp=00
0e38 : e001                     cpx #1
                                trap_ne
0e3a : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e3c : ad0101                   lda $101
                                cmp_flag 0
0e3f : c930            >            cmp #(0|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0e41 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0e43 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0e45 : 48              >            pha         ;use stack to load status
0e46 : 28              >            plp
                        
0e47 : ba                       tsx             ;clears N, sets Z
0e48 : 08                       php             ;sp=ff
0e49 : e000                     cpx #0
                                trap_ne
0e4b : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e4d : ad0001                   lda $100
                                cmp_flag zero
0e50 : c932            >            cmp #(zero|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0e52 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
0e54 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0e56 : 48              >            pha         ;use stack to load status
0e57 : 28              >            plp
                        
0e58 : ba                       tsx             ;clears N, sets Z
0e59 : 08                       php             ;sp=fe
0e5a : e0ff                     cpx #$ff
                                trap_ne
0e5c : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e5e : adff01                   lda $1ff
                                cmp_flag minus
0e61 : c9b0            >            cmp #(minus|fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
0e63 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e65 : 68                       pla             ;sp=ff
                                next_test
0e66 : ad0002          >            lda test_case   ;previous test
0e69 : c90e            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0e6b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
000f =                 >test_num = test_num + 1
0e6d : a90f            >            lda #test_num   ;*** next tests' number
0e6f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; testing index register load & store LDY LDX STY STX all addressing modes
                        ; LDX / STX - zp,y / abs,y
0e72 : a003                     ldy #3
0e74 :                  tldx    
                                set_stat 0
                       >            load_flag 0
0e74 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0e76 : 48              >            pha         ;use stack to load status
0e77 : 28              >            plp
                        
0e78 : b613                     ldx zp1,y
0e7a : 08                       php         ;test stores do not alter flags
0e7b : 8a                       txa
0e7c : 49c3                     eor #$c3
0e7e : 28                       plp
0e7f : 990302                   sta abst,y
0e82 : 08                       php         ;flags after load/store sequence
0e83 : 49c3                     eor #$c3
0e85 : d91702                   cmp abs1,y  ;test result
                                trap_ne
0e88 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e8a : 68                       pla         ;load status
                                eor_flag 0
0e8b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0e8d : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
0e90 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0e92 : 88                       dey
0e93 : 10df                     bpl tldx                  
                        
0e95 : a003                     ldy #3
0e97 :                  tldx1   
                                set_stat $ff
                       >            load_flag $ff
0e97 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0e99 : 48              >            pha         ;use stack to load status
0e9a : 28              >            plp
                        
0e9b : b613                     ldx zp1,y
0e9d : 08                       php         ;test stores do not alter flags
0e9e : 8a                       txa
0e9f : 49c3                     eor #$c3
0ea1 : 28                       plp
0ea2 : 990302                   sta abst,y
0ea5 : 08                       php         ;flags after load/store sequence
0ea6 : 49c3                     eor #$c3
0ea8 : d91702                   cmp abs1,y  ;test result
                                trap_ne
0eab : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ead : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0eae : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0eb0 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
0eb3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0eb5 : 88                       dey
0eb6 : 10df                     bpl tldx1                  
                        
0eb8 : a003                     ldy #3
0eba :                  tldx2   
                                set_stat 0
                       >            load_flag 0
0eba : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0ebc : 48              >            pha         ;use stack to load status
0ebd : 28              >            plp
                        
0ebe : be1702                   ldx abs1,y
0ec1 : 08                       php         ;test stores do not alter flags
0ec2 : 8a                       txa
0ec3 : 49c3                     eor #$c3
0ec5 : aa                       tax
0ec6 : 28                       plp
0ec7 : 960c                     stx zpt,y
0ec9 : 08                       php         ;flags after load/store sequence
0eca : 49c3                     eor #$c3
0ecc : d91300                   cmp zp1,y   ;test result
                                trap_ne
0ecf : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ed1 : 68                       pla         ;load status
                                eor_flag 0
0ed2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0ed4 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
0ed7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ed9 : 88                       dey
0eda : 10de                     bpl tldx2                  
                        
0edc : a003                     ldy #3
0ede :                  tldx3   
                                set_stat $ff
                       >            load_flag $ff
0ede : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0ee0 : 48              >            pha         ;use stack to load status
0ee1 : 28              >            plp
                        
0ee2 : be1702                   ldx abs1,y
0ee5 : 08                       php         ;test stores do not alter flags
0ee6 : 8a                       txa
0ee7 : 49c3                     eor #$c3
0ee9 : aa                       tax
0eea : 28                       plp
0eeb : 960c                     stx zpt,y
0eed : 08                       php         ;flags after load/store sequence
0eee : 49c3                     eor #$c3
0ef0 : d91300                   cmp zp1,y   ;test result
                                trap_ne
0ef3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ef5 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0ef6 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0ef8 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
0efb : d0fe            >        bne *           ;failed not equal (non zero)
                        
0efd : 88                       dey
0efe : 10de                     bpl tldx3
                                
0f00 : a003                     ldy #3      ;testing store result
0f02 : a200                     ldx #0
0f04 : b90c00           tstx    lda zpt,y
0f07 : 49c3                     eor #$c3
0f09 : d91300                   cmp zp1,y
                                trap_ne     ;store to zp data
0f0c : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f0e : 960c                     stx zpt,y   ;clear                
0f10 : b90302                   lda abst,y
0f13 : 49c3                     eor #$c3
0f15 : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
0f18 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f1a : 8a                       txa
0f1b : 990302                   sta abst,y  ;clear                
0f1e : 88                       dey
0f1f : 10e3                     bpl tstx
                                next_test
0f21 : ad0002          >            lda test_case   ;previous test
0f24 : c90f            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0f26 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0010 =                 >test_num = test_num + 1
0f28 : a910            >            lda #test_num   ;*** next tests' number
0f2a : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; indexed wraparound test (only zp should wrap)
0f2d : a0fd                     ldy #3+$fa
0f2f : b619             tldx4   ldx zp1-$fa&$ff,y   ;wrap on indexed zp
0f31 : 8a                       txa
0f32 : 990901                   sta abst-$fa,y      ;no STX abs,y!
0f35 : 88                       dey
0f36 : c0fa                     cpy #$fa
0f38 : b0f5                     bcs tldx4                  
0f3a : a0fd                     ldy #3+$fa
0f3c : be1d01           tldx5   ldx abs1-$fa,y      ;no wrap on indexed abs
0f3f : 9612                     stx zpt-$fa&$ff,y
0f41 : 88                       dey
0f42 : c0fa                     cpy #$fa
0f44 : b0f6                     bcs tldx5                  
0f46 : a003                     ldy #3      ;testing wraparound result
0f48 : a200                     ldx #0
0f4a : b90c00           tstx1   lda zpt,y
0f4d : d91300                   cmp zp1,y
                                trap_ne     ;store to zp data
0f50 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f52 : 960c                     stx zpt,y   ;clear                
0f54 : b90302                   lda abst,y
0f57 : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
0f5a : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f5c : 8a                       txa
0f5d : 990302                   sta abst,y  ;clear                
0f60 : 88                       dey
0f61 : 10e7                     bpl tstx1
                                next_test
0f63 : ad0002          >            lda test_case   ;previous test
0f66 : c910            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
0f68 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0011 =                 >test_num = test_num + 1
0f6a : a911            >            lda #test_num   ;*** next tests' number
0f6c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; LDY / STY - zp,x / abs,x
0f6f : a203                     ldx #3
0f71 :                  tldy    
                                set_stat 0
                       >            load_flag 0
0f71 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0f73 : 48              >            pha         ;use stack to load status
0f74 : 28              >            plp
                        
0f75 : b413                     ldy zp1,x
0f77 : 08                       php         ;test stores do not alter flags
0f78 : 98                       tya
0f79 : 49c3                     eor #$c3
0f7b : 28                       plp
0f7c : 9d0302                   sta abst,x
0f7f : 08                       php         ;flags after load/store sequence
0f80 : 49c3                     eor #$c3
0f82 : dd1702                   cmp abs1,x  ;test result
                                trap_ne
0f85 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f87 : 68                       pla         ;load status
                                eor_flag 0
0f88 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0f8a : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
0f8d : d0fe            >        bne *           ;failed not equal (non zero)
                        
0f8f : ca                       dex
0f90 : 10df                     bpl tldy                  
                        
0f92 : a203                     ldx #3
0f94 :                  tldy1   
                                set_stat $ff
                       >            load_flag $ff
0f94 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0f96 : 48              >            pha         ;use stack to load status
0f97 : 28              >            plp
                        
0f98 : b413                     ldy zp1,x
0f9a : 08                       php         ;test stores do not alter flags
0f9b : 98                       tya
0f9c : 49c3                     eor #$c3
0f9e : 28                       plp
0f9f : 9d0302                   sta abst,x
0fa2 : 08                       php         ;flags after load/store sequence
0fa3 : 49c3                     eor #$c3
0fa5 : dd1702                   cmp abs1,x  ;test result
                                trap_ne
0fa8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0faa : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0fab : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0fad : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
0fb0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fb2 : ca                       dex
0fb3 : 10df                     bpl tldy1                  
                        
0fb5 : a203                     ldx #3
0fb7 :                  tldy2   
                                set_stat 0
                       >            load_flag 0
0fb7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
0fb9 : 48              >            pha         ;use stack to load status
0fba : 28              >            plp
                        
0fbb : bc1702                   ldy abs1,x
0fbe : 08                       php         ;test stores do not alter flags
0fbf : 98                       tya
0fc0 : 49c3                     eor #$c3
0fc2 : a8                       tay
0fc3 : 28                       plp
0fc4 : 940c                     sty zpt,x
0fc6 : 08                       php         ;flags after load/store sequence
0fc7 : 49c3                     eor #$c3
0fc9 : d513                     cmp zp1,x   ;test result
                                trap_ne
0fcb : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fcd : 68                       pla         ;load status
                                eor_flag 0
0fce : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
0fd0 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
0fd3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0fd5 : ca                       dex
0fd6 : 10df                     bpl tldy2                  
                        
0fd8 : a203                     ldx #3
0fda :                  tldy3
                                set_stat $ff
                       >            load_flag $ff
0fda : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
0fdc : 48              >            pha         ;use stack to load status
0fdd : 28              >            plp
                        
0fde : bc1702                   ldy abs1,x
0fe1 : 08                       php         ;test stores do not alter flags
0fe2 : 98                       tya
0fe3 : 49c3                     eor #$c3
0fe5 : a8                       tay
0fe6 : 28                       plp
0fe7 : 940c                     sty zpt,x
0fe9 : 08                       php         ;flags after load/store sequence
0fea : 49c3                     eor #$c3
0fec : d513                     cmp zp1,x   ;test result
                                trap_ne
0fee : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ff0 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
0ff1 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
0ff3 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
0ff6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
0ff8 : ca                       dex
0ff9 : 10df                     bpl tldy3
                        
0ffb : a203                     ldx #3      ;testing store result
0ffd : a000                     ldy #0
0fff : b50c             tsty    lda zpt,x
1001 : 49c3                     eor #$c3
1003 : d513                     cmp zp1,x
                                trap_ne     ;store to zp,x data
1005 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1007 : 940c                     sty zpt,x   ;clear                
1009 : bd0302                   lda abst,x
100c : 49c3                     eor #$c3
100e : dd1702                   cmp abs1,x
                                trap_ne     ;store to abs,x data
1011 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1013 : 8a                       txa
1014 : 9d0302                   sta abst,x  ;clear                
1017 : ca                       dex
1018 : 10e5                     bpl tsty
                                next_test
101a : ad0002          >            lda test_case   ;previous test
101d : c911            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
101f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0012 =                 >test_num = test_num + 1
1021 : a912            >            lda #test_num   ;*** next tests' number
1023 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
1026 : a2fd                     ldx #3+$fa
1028 : b419             tldy4   ldy zp1-$fa&$ff,x   ;wrap on indexed zp
102a : 98                       tya
102b : 9d0901                   sta abst-$fa,x      ;no STX abs,x!
102e : ca                       dex
102f : e0fa                     cpx #$fa
1031 : b0f5                     bcs tldy4                  
1033 : a2fd                     ldx #3+$fa
1035 : bc1d01           tldy5   ldy abs1-$fa,x      ;no wrap on indexed abs
1038 : 9412                     sty zpt-$fa&$ff,x
103a : ca                       dex
103b : e0fa                     cpx #$fa
103d : b0f6                     bcs tldy5                  
103f : a203                     ldx #3      ;testing wraparound result
1041 : a000                     ldy #0
1043 : b50c             tsty1   lda zpt,x
1045 : d513                     cmp zp1,x
                                trap_ne     ;store to zp,x data
1047 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1049 : 940c                     sty zpt,x   ;clear                
104b : bd0302                   lda abst,x
104e : dd1702                   cmp abs1,x
                                trap_ne     ;store to abs,x data
1051 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1053 : 8a                       txa
1054 : 9d0302                   sta abst,x  ;clear                
1057 : ca                       dex
1058 : 10e9                     bpl tsty1
                                next_test
105a : ad0002          >            lda test_case   ;previous test
105d : c912            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
105f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0013 =                 >test_num = test_num + 1
1061 : a913            >            lda #test_num   ;*** next tests' number
1063 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDX / STX - zp / abs / #
                                set_stat 0  
                       >            load_flag 0  
1066 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
1068 : 48              >            pha         ;use stack to load status
1069 : 28              >            plp
                        
106a : a613                     ldx zp1
106c : 08                       php         ;test stores do not alter flags
106d : 8a                       txa
106e : 49c3                     eor #$c3
1070 : aa                       tax
1071 : 28                       plp
1072 : 8e0302                   stx abst
1075 : 08                       php         ;flags after load/store sequence
1076 : 49c3                     eor #$c3
1078 : aa                       tax
1079 : e0c3                     cpx #$c3    ;test result
                                trap_ne
107b : d0fe            >        bne *           ;failed not equal (non zero)
                        
107d : 68                       pla         ;load status
                                eor_flag 0
107e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1080 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1083 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1085 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1087 : 48              >            pha         ;use stack to load status
1088 : 28              >            plp
                        
1089 : a614                     ldx zp1+1
108b : 08                       php         ;test stores do not alter flags
108c : 8a                       txa
108d : 49c3                     eor #$c3
108f : aa                       tax
1090 : 28                       plp
1091 : 8e0402                   stx abst+1
1094 : 08                       php         ;flags after load/store sequence
1095 : 49c3                     eor #$c3
1097 : aa                       tax
1098 : e082                     cpx #$82    ;test result
                                trap_ne
109a : d0fe            >        bne *           ;failed not equal (non zero)
                        
109c : 68                       pla         ;load status
                                eor_flag 0
109d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
109f : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
10a2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
10a4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
10a6 : 48              >            pha         ;use stack to load status
10a7 : 28              >            plp
                        
10a8 : a615                     ldx zp1+2
10aa : 08                       php         ;test stores do not alter flags
10ab : 8a                       txa
10ac : 49c3                     eor #$c3
10ae : aa                       tax
10af : 28                       plp
10b0 : 8e0502                   stx abst+2
10b3 : 08                       php         ;flags after load/store sequence
10b4 : 49c3                     eor #$c3
10b6 : aa                       tax
10b7 : e041                     cpx #$41    ;test result
                                trap_ne
10b9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
10bb : 68                       pla         ;load status
                                eor_flag 0
10bc : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
10be : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
10c1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
10c3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
10c5 : 48              >            pha         ;use stack to load status
10c6 : 28              >            plp
                        
10c7 : a616                     ldx zp1+3
10c9 : 08                       php         ;test stores do not alter flags
10ca : 8a                       txa
10cb : 49c3                     eor #$c3
10cd : aa                       tax
10ce : 28                       plp
10cf : 8e0602                   stx abst+3
10d2 : 08                       php         ;flags after load/store sequence
10d3 : 49c3                     eor #$c3
10d5 : aa                       tax
10d6 : e000                     cpx #0      ;test result
                                trap_ne
10d8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
10da : 68                       pla         ;load status
                                eor_flag 0
10db : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
10dd : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
10e0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
10e2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
10e4 : 48              >            pha         ;use stack to load status
10e5 : 28              >            plp
                        
10e6 : a613                     ldx zp1  
10e8 : 08                       php         ;test stores do not alter flags
10e9 : 8a                       txa
10ea : 49c3                     eor #$c3
10ec : aa                       tax
10ed : 28                       plp
10ee : 8e0302                   stx abst  
10f1 : 08                       php         ;flags after load/store sequence
10f2 : 49c3                     eor #$c3
10f4 : aa                       tax
10f5 : e0c3                     cpx #$c3    ;test result
                                trap_ne     ;
10f7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
10f9 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
10fa : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
10fc : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
10ff : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1101 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1103 : 48              >            pha         ;use stack to load status
1104 : 28              >            plp
                        
1105 : a614                     ldx zp1+1
1107 : 08                       php         ;test stores do not alter flags
1108 : 8a                       txa
1109 : 49c3                     eor #$c3
110b : aa                       tax
110c : 28                       plp
110d : 8e0402                   stx abst+1
1110 : 08                       php         ;flags after load/store sequence
1111 : 49c3                     eor #$c3
1113 : aa                       tax
1114 : e082                     cpx #$82    ;test result
                                trap_ne
1116 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1118 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1119 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
111b : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
111e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1120 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1122 : 48              >            pha         ;use stack to load status
1123 : 28              >            plp
                        
1124 : a615                     ldx zp1+2
1126 : 08                       php         ;test stores do not alter flags
1127 : 8a                       txa
1128 : 49c3                     eor #$c3
112a : aa                       tax
112b : 28                       plp
112c : 8e0502                   stx abst+2
112f : 08                       php         ;flags after load/store sequence
1130 : 49c3                     eor #$c3
1132 : aa                       tax
1133 : e041                     cpx #$41    ;test result
                                trap_ne     ;
1135 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1137 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1138 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
113a : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
113d : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
113f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1141 : 48              >            pha         ;use stack to load status
1142 : 28              >            plp
                        
1143 : a616                     ldx zp1+3
1145 : 08                       php         ;test stores do not alter flags
1146 : 8a                       txa
1147 : 49c3                     eor #$c3
1149 : aa                       tax
114a : 28                       plp
114b : 8e0602                   stx abst+3
114e : 08                       php         ;flags after load/store sequence
114f : 49c3                     eor #$c3
1151 : aa                       tax
1152 : e000                     cpx #0      ;test result
                                trap_ne
1154 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1156 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1157 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1159 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
115c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat 0
                       >            load_flag 0
115e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1160 : 48              >            pha         ;use stack to load status
1161 : 28              >            plp
                        
1162 : ae1702                   ldx abs1  
1165 : 08                       php         ;test stores do not alter flags
1166 : 8a                       txa
1167 : 49c3                     eor #$c3
1169 : aa                       tax
116a : 28                       plp
116b : 860c                     stx zpt  
116d : 08                       php         ;flags after load/store sequence
116e : 49c3                     eor #$c3
1170 : c513                     cmp zp1     ;test result
                                trap_ne
1172 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1174 : 68                       pla         ;load status
                                eor_flag 0
1175 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1177 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
117a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
117c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
117e : 48              >            pha         ;use stack to load status
117f : 28              >            plp
                        
1180 : ae1802                   ldx abs1+1
1183 : 08                       php         ;test stores do not alter flags
1184 : 8a                       txa
1185 : 49c3                     eor #$c3
1187 : aa                       tax
1188 : 28                       plp
1189 : 860d                     stx zpt+1
118b : 08                       php         ;flags after load/store sequence
118c : 49c3                     eor #$c3
118e : c514                     cmp zp1+1   ;test result
                                trap_ne
1190 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1192 : 68                       pla         ;load status
                                eor_flag 0
1193 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1195 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1198 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
119a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
119c : 48              >            pha         ;use stack to load status
119d : 28              >            plp
                        
119e : ae1902                   ldx abs1+2
11a1 : 08                       php         ;test stores do not alter flags
11a2 : 8a                       txa
11a3 : 49c3                     eor #$c3
11a5 : aa                       tax
11a6 : 28                       plp
11a7 : 860e                     stx zpt+2
11a9 : 08                       php         ;flags after load/store sequence
11aa : 49c3                     eor #$c3
11ac : c515                     cmp zp1+2   ;test result
                                trap_ne
11ae : d0fe            >        bne *           ;failed not equal (non zero)
                        
11b0 : 68                       pla         ;load status
                                eor_flag 0
11b1 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
11b3 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
11b6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
11b8 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
11ba : 48              >            pha         ;use stack to load status
11bb : 28              >            plp
                        
11bc : ae1a02                   ldx abs1+3
11bf : 08                       php         ;test stores do not alter flags
11c0 : 8a                       txa
11c1 : 49c3                     eor #$c3
11c3 : aa                       tax
11c4 : 28                       plp
11c5 : 860f                     stx zpt+3
11c7 : 08                       php         ;flags after load/store sequence
11c8 : 49c3                     eor #$c3
11ca : c516                     cmp zp1+3   ;test result
                                trap_ne
11cc : d0fe            >        bne *           ;failed not equal (non zero)
                        
11ce : 68                       pla         ;load status
                                eor_flag 0
11cf : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
11d1 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
11d4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
11d6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
11d8 : 48              >            pha         ;use stack to load status
11d9 : 28              >            plp
                        
11da : ae1702                   ldx abs1  
11dd : 08                       php         ;test stores do not alter flags
11de : 8a                       txa
11df : 49c3                     eor #$c3
11e1 : aa                       tax
11e2 : 28                       plp
11e3 : 860c                     stx zpt  
11e5 : 08                       php         ;flags after load/store sequence
11e6 : 49c3                     eor #$c3
11e8 : aa                       tax
11e9 : e413                     cpx zp1     ;test result
                                trap_ne
11eb : d0fe            >        bne *           ;failed not equal (non zero)
                        
11ed : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
11ee : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
11f0 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
11f3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
11f5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
11f7 : 48              >            pha         ;use stack to load status
11f8 : 28              >            plp
                        
11f9 : ae1802                   ldx abs1+1
11fc : 08                       php         ;test stores do not alter flags
11fd : 8a                       txa
11fe : 49c3                     eor #$c3
1200 : aa                       tax
1201 : 28                       plp
1202 : 860d                     stx zpt+1
1204 : 08                       php         ;flags after load/store sequence
1205 : 49c3                     eor #$c3
1207 : aa                       tax
1208 : e414                     cpx zp1+1   ;test result
                                trap_ne
120a : d0fe            >        bne *           ;failed not equal (non zero)
                        
120c : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
120d : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
120f : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1212 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1214 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1216 : 48              >            pha         ;use stack to load status
1217 : 28              >            plp
                        
1218 : ae1902                   ldx abs1+2
121b : 08                       php         ;test stores do not alter flags
121c : 8a                       txa
121d : 49c3                     eor #$c3
121f : aa                       tax
1220 : 28                       plp
1221 : 860e                     stx zpt+2
1223 : 08                       php         ;flags after load/store sequence
1224 : 49c3                     eor #$c3
1226 : aa                       tax
1227 : e415                     cpx zp1+2   ;test result
                                trap_ne
1229 : d0fe            >        bne *           ;failed not equal (non zero)
                        
122b : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
122c : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
122e : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1231 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1233 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1235 : 48              >            pha         ;use stack to load status
1236 : 28              >            plp
                        
1237 : ae1a02                   ldx abs1+3
123a : 08                       php         ;test stores do not alter flags
123b : 8a                       txa
123c : 49c3                     eor #$c3
123e : aa                       tax
123f : 28                       plp
1240 : 860f                     stx zpt+3
1242 : 08                       php         ;flags after load/store sequence
1243 : 49c3                     eor #$c3
1245 : aa                       tax
1246 : e416                     cpx zp1+3   ;test result
                                trap_ne
1248 : d0fe            >        bne *           ;failed not equal (non zero)
                        
124a : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
124b : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
124d : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1250 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat 0  
                       >            load_flag 0  
1252 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
1254 : 48              >            pha         ;use stack to load status
1255 : 28              >            plp
                        
1256 : a2c3                     ldx #$c3
1258 : 08                       php
1259 : ec1702                   cpx abs1    ;test result
                                trap_ne
125c : d0fe            >        bne *           ;failed not equal (non zero)
                        
125e : 68                       pla         ;load status
                                eor_flag 0
125f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1261 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1264 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1266 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1268 : 48              >            pha         ;use stack to load status
1269 : 28              >            plp
                        
126a : a282                     ldx #$82
126c : 08                       php
126d : ec1802                   cpx abs1+1  ;test result
                                trap_ne
1270 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1272 : 68                       pla         ;load status
                                eor_flag 0
1273 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1275 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1278 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
127a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
127c : 48              >            pha         ;use stack to load status
127d : 28              >            plp
                        
127e : a241                     ldx #$41
1280 : 08                       php
1281 : ec1902                   cpx abs1+2  ;test result
                                trap_ne
1284 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1286 : 68                       pla         ;load status
                                eor_flag 0
1287 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1289 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
128c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
128e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1290 : 48              >            pha         ;use stack to load status
1291 : 28              >            plp
                        
1292 : a200                     ldx #0
1294 : 08                       php
1295 : ec1a02                   cpx abs1+3  ;test result
                                trap_ne
1298 : d0fe            >        bne *           ;failed not equal (non zero)
                        
129a : 68                       pla         ;load status
                                eor_flag 0
129b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
129d : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
12a0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
12a2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
12a4 : 48              >            pha         ;use stack to load status
12a5 : 28              >            plp
                        
12a6 : a2c3                     ldx #$c3  
12a8 : 08                       php
12a9 : ec1702                   cpx abs1    ;test result
                                trap_ne
12ac : d0fe            >        bne *           ;failed not equal (non zero)
                        
12ae : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
12af : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
12b1 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
12b4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
12b6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
12b8 : 48              >            pha         ;use stack to load status
12b9 : 28              >            plp
                        
12ba : a282                     ldx #$82
12bc : 08                       php
12bd : ec1802                   cpx abs1+1  ;test result
                                trap_ne
12c0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12c2 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
12c3 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
12c5 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
12c8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
12ca : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
12cc : 48              >            pha         ;use stack to load status
12cd : 28              >            plp
                        
12ce : a241                     ldx #$41
12d0 : 08                       php
12d1 : ec1902                   cpx abs1+2  ;test result
                                trap_ne
12d4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12d6 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
12d7 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
12d9 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
12dc : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
12de : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
12e0 : 48              >            pha         ;use stack to load status
12e1 : 28              >            plp
                        
12e2 : a200                     ldx #0
12e4 : 08                       php
12e5 : ec1a02                   cpx abs1+3  ;test result
                                trap_ne
12e8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
12ea : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
12eb : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
12ed : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
12f0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
12f2 : a200                     ldx #0
12f4 : a50c                     lda zpt  
12f6 : 49c3                     eor #$c3
12f8 : c513                     cmp zp1  
                                trap_ne     ;store to zp data
12fa : d0fe            >        bne *           ;failed not equal (non zero)
                        
12fc : 860c                     stx zpt     ;clear                
12fe : ad0302                   lda abst  
1301 : 49c3                     eor #$c3
1303 : cd1702                   cmp abs1  
                                trap_ne     ;store to abs data
1306 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1308 : 8e0302                   stx abst    ;clear                
130b : a50d                     lda zpt+1
130d : 49c3                     eor #$c3
130f : c514                     cmp zp1+1
                                trap_ne     ;store to zp data
1311 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1313 : 860d                     stx zpt+1   ;clear                
1315 : ad0402                   lda abst+1
1318 : 49c3                     eor #$c3
131a : cd1802                   cmp abs1+1
                                trap_ne     ;store to abs data
131d : d0fe            >        bne *           ;failed not equal (non zero)
                        
131f : 8e0402                   stx abst+1  ;clear                
1322 : a50e                     lda zpt+2
1324 : 49c3                     eor #$c3
1326 : c515                     cmp zp1+2
                                trap_ne     ;store to zp data
1328 : d0fe            >        bne *           ;failed not equal (non zero)
                        
132a : 860e                     stx zpt+2   ;clear                
132c : ad0502                   lda abst+2
132f : 49c3                     eor #$c3
1331 : cd1902                   cmp abs1+2
                                trap_ne     ;store to abs data
1334 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1336 : 8e0502                   stx abst+2  ;clear                
1339 : a50f                     lda zpt+3
133b : 49c3                     eor #$c3
133d : c516                     cmp zp1+3
                                trap_ne     ;store to zp data
133f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1341 : 860f                     stx zpt+3   ;clear                
1343 : ad0602                   lda abst+3
1346 : 49c3                     eor #$c3
1348 : cd1a02                   cmp abs1+3
                                trap_ne     ;store to abs data
134b : d0fe            >        bne *           ;failed not equal (non zero)
                        
134d : 8e0602                   stx abst+3  ;clear                
                                next_test
1350 : ad0002          >            lda test_case   ;previous test
1353 : c913            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1355 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0014 =                 >test_num = test_num + 1
1357 : a914            >            lda #test_num   ;*** next tests' number
1359 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDY / STY - zp / abs / #
                                set_stat 0
                       >            load_flag 0
135c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
135e : 48              >            pha         ;use stack to load status
135f : 28              >            plp
                        
1360 : a413                     ldy zp1  
1362 : 08                       php         ;test stores do not alter flags
1363 : 98                       tya
1364 : 49c3                     eor #$c3
1366 : a8                       tay
1367 : 28                       plp
1368 : 8c0302                   sty abst  
136b : 08                       php         ;flags after load/store sequence
136c : 49c3                     eor #$c3
136e : a8                       tay
136f : c0c3                     cpy #$c3    ;test result
                                trap_ne
1371 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1373 : 68                       pla         ;load status
                                eor_flag 0
1374 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1376 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1379 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
137b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
137d : 48              >            pha         ;use stack to load status
137e : 28              >            plp
                        
137f : a414                     ldy zp1+1
1381 : 08                       php         ;test stores do not alter flags
1382 : 98                       tya
1383 : 49c3                     eor #$c3
1385 : a8                       tay
1386 : 28                       plp
1387 : 8c0402                   sty abst+1
138a : 08                       php         ;flags after load/store sequence
138b : 49c3                     eor #$c3
138d : a8                       tay
138e : c082                     cpy #$82    ;test result
                                trap_ne
1390 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1392 : 68                       pla         ;load status
                                eor_flag 0
1393 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1395 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1398 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
139a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
139c : 48              >            pha         ;use stack to load status
139d : 28              >            plp
                        
139e : a415                     ldy zp1+2
13a0 : 08                       php         ;test stores do not alter flags
13a1 : 98                       tya
13a2 : 49c3                     eor #$c3
13a4 : a8                       tay
13a5 : 28                       plp
13a6 : 8c0502                   sty abst+2
13a9 : 08                       php         ;flags after load/store sequence
13aa : 49c3                     eor #$c3
13ac : a8                       tay
13ad : c041                     cpy #$41    ;test result
                                trap_ne
13af : d0fe            >        bne *           ;failed not equal (non zero)
                        
13b1 : 68                       pla         ;load status
                                eor_flag 0
13b2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
13b4 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
13b7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
13b9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
13bb : 48              >            pha         ;use stack to load status
13bc : 28              >            plp
                        
13bd : a416                     ldy zp1+3
13bf : 08                       php         ;test stores do not alter flags
13c0 : 98                       tya
13c1 : 49c3                     eor #$c3
13c3 : a8                       tay
13c4 : 28                       plp
13c5 : 8c0602                   sty abst+3
13c8 : 08                       php         ;flags after load/store sequence
13c9 : 49c3                     eor #$c3
13cb : a8                       tay
13cc : c000                     cpy #0      ;test result
                                trap_ne
13ce : d0fe            >        bne *           ;failed not equal (non zero)
                        
13d0 : 68                       pla         ;load status
                                eor_flag 0
13d1 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
13d3 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
13d6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
13d8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
13da : 48              >            pha         ;use stack to load status
13db : 28              >            plp
                        
13dc : a413                     ldy zp1  
13de : 08                       php         ;test stores do not alter flags
13df : 98                       tya
13e0 : 49c3                     eor #$c3
13e2 : a8                       tay
13e3 : 28                       plp
13e4 : 8c0302                   sty abst  
13e7 : 08                       php         ;flags after load/store sequence
13e8 : 49c3                     eor #$c3
13ea : a8                       tay
13eb : c0c3                     cpy #$c3    ;test result
                                trap_ne
13ed : d0fe            >        bne *           ;failed not equal (non zero)
                        
13ef : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
13f0 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
13f2 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
13f5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
13f7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
13f9 : 48              >            pha         ;use stack to load status
13fa : 28              >            plp
                        
13fb : a414                     ldy zp1+1
13fd : 08                       php         ;test stores do not alter flags
13fe : 98                       tya
13ff : 49c3                     eor #$c3
1401 : a8                       tay
1402 : 28                       plp
1403 : 8c0402                   sty abst+1
1406 : 08                       php         ;flags after load/store sequence
1407 : 49c3                     eor #$c3
1409 : a8                       tay
140a : c082                     cpy #$82   ;test result
                                trap_ne
140c : d0fe            >        bne *           ;failed not equal (non zero)
                        
140e : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
140f : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1411 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1414 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1416 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1418 : 48              >            pha         ;use stack to load status
1419 : 28              >            plp
                        
141a : a415                     ldy zp1+2
141c : 08                       php         ;test stores do not alter flags
141d : 98                       tya
141e : 49c3                     eor #$c3
1420 : a8                       tay
1421 : 28                       plp
1422 : 8c0502                   sty abst+2
1425 : 08                       php         ;flags after load/store sequence
1426 : 49c3                     eor #$c3
1428 : a8                       tay
1429 : c041                     cpy #$41    ;test result
                                trap_ne
142b : d0fe            >        bne *           ;failed not equal (non zero)
                        
142d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
142e : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1430 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1433 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1435 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1437 : 48              >            pha         ;use stack to load status
1438 : 28              >            plp
                        
1439 : a416                     ldy zp1+3
143b : 08                       php         ;test stores do not alter flags
143c : 98                       tya
143d : 49c3                     eor #$c3
143f : a8                       tay
1440 : 28                       plp
1441 : 8c0602                   sty abst+3
1444 : 08                       php         ;flags after load/store sequence
1445 : 49c3                     eor #$c3
1447 : a8                       tay
1448 : c000                     cpy #0      ;test result
                                trap_ne
144a : d0fe            >        bne *           ;failed not equal (non zero)
                        
144c : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
144d : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
144f : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1452 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                
                                set_stat 0
                       >            load_flag 0
1454 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1456 : 48              >            pha         ;use stack to load status
1457 : 28              >            plp
                        
1458 : ac1702                   ldy abs1  
145b : 08                       php         ;test stores do not alter flags
145c : 98                       tya
145d : 49c3                     eor #$c3
145f : a8                       tay
1460 : 28                       plp
1461 : 840c                     sty zpt  
1463 : 08                       php         ;flags after load/store sequence
1464 : 49c3                     eor #$c3
1466 : a8                       tay
1467 : c413                     cpy zp1     ;test result
                                trap_ne
1469 : d0fe            >        bne *           ;failed not equal (non zero)
                        
146b : 68                       pla         ;load status
                                eor_flag 0
146c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
146e : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1471 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1473 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1475 : 48              >            pha         ;use stack to load status
1476 : 28              >            plp
                        
1477 : ac1802                   ldy abs1+1
147a : 08                       php         ;test stores do not alter flags
147b : 98                       tya
147c : 49c3                     eor #$c3
147e : a8                       tay
147f : 28                       plp
1480 : 840d                     sty zpt+1
1482 : 08                       php         ;flags after load/store sequence
1483 : 49c3                     eor #$c3
1485 : a8                       tay
1486 : c414                     cpy zp1+1   ;test result
                                trap_ne
1488 : d0fe            >        bne *           ;failed not equal (non zero)
                        
148a : 68                       pla         ;load status
                                eor_flag 0
148b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
148d : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1490 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1492 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1494 : 48              >            pha         ;use stack to load status
1495 : 28              >            plp
                        
1496 : ac1902                   ldy abs1+2
1499 : 08                       php         ;test stores do not alter flags
149a : 98                       tya
149b : 49c3                     eor #$c3
149d : a8                       tay
149e : 28                       plp
149f : 840e                     sty zpt+2
14a1 : 08                       php         ;flags after load/store sequence
14a2 : 49c3                     eor #$c3
14a4 : a8                       tay
14a5 : c415                     cpy zp1+2   ;test result
                                trap_ne
14a7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
14a9 : 68                       pla         ;load status
                                eor_flag 0
14aa : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
14ac : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
14af : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
14b1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
14b3 : 48              >            pha         ;use stack to load status
14b4 : 28              >            plp
                        
14b5 : ac1a02                   ldy abs1+3
14b8 : 08                       php         ;test stores do not alter flags
14b9 : 98                       tya
14ba : 49c3                     eor #$c3
14bc : a8                       tay
14bd : 28                       plp
14be : 840f                     sty zpt+3
14c0 : 08                       php         ;flags after load/store sequence
14c1 : 49c3                     eor #$c3
14c3 : a8                       tay
14c4 : c416                     cpy zp1+3   ;test result
                                trap_ne
14c6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
14c8 : 68                       pla         ;load status
                                eor_flag 0
14c9 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
14cb : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
14ce : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
14d0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
14d2 : 48              >            pha         ;use stack to load status
14d3 : 28              >            plp
                        
14d4 : ac1702                   ldy abs1  
14d7 : 08                       php         ;test stores do not alter flags
14d8 : 98                       tya
14d9 : 49c3                     eor #$c3
14db : a8                       tay
14dc : 28                       plp
14dd : 840c                     sty zpt  
14df : 08                       php         ;flags after load/store sequence
14e0 : 49c3                     eor #$c3
14e2 : a8                       tay
14e3 : c513                     cmp zp1     ;test result
                                trap_ne
14e5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
14e7 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
14e8 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
14ea : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
14ed : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
14ef : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
14f1 : 48              >            pha         ;use stack to load status
14f2 : 28              >            plp
                        
14f3 : ac1802                   ldy abs1+1
14f6 : 08                       php         ;test stores do not alter flags
14f7 : 98                       tya
14f8 : 49c3                     eor #$c3
14fa : a8                       tay
14fb : 28                       plp
14fc : 840d                     sty zpt+1
14fe : 08                       php         ;flags after load/store sequence
14ff : 49c3                     eor #$c3
1501 : a8                       tay
1502 : c514                     cmp zp1+1   ;test result
                                trap_ne
1504 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1506 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1507 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1509 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
150c : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
150e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1510 : 48              >            pha         ;use stack to load status
1511 : 28              >            plp
                        
1512 : ac1902                   ldy abs1+2
1515 : 08                       php         ;test stores do not alter flags
1516 : 98                       tya
1517 : 49c3                     eor #$c3
1519 : a8                       tay
151a : 28                       plp
151b : 840e                     sty zpt+2
151d : 08                       php         ;flags after load/store sequence
151e : 49c3                     eor #$c3
1520 : a8                       tay
1521 : c515                     cmp zp1+2   ;test result
                                trap_ne
1523 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1525 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1526 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1528 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
152b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
152d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
152f : 48              >            pha         ;use stack to load status
1530 : 28              >            plp
                        
1531 : ac1a02                   ldy abs1+3
1534 : 08                       php         ;test stores do not alter flags
1535 : 98                       tya
1536 : 49c3                     eor #$c3
1538 : a8                       tay
1539 : 28                       plp
153a : 840f                     sty zpt+3
153c : 08                       php         ;flags after load/store sequence
153d : 49c3                     eor #$c3
153f : a8                       tay
1540 : c516                     cmp zp1+3   ;test result
                                trap_ne
1542 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1544 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1545 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1547 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
154a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                        
                                set_stat 0
                       >            load_flag 0
154c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
154e : 48              >            pha         ;use stack to load status
154f : 28              >            plp
                        
1550 : a0c3                     ldy #$c3  
1552 : 08                       php
1553 : cc1702                   cpy abs1    ;test result
                                trap_ne
1556 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1558 : 68                       pla         ;load status
                                eor_flag 0
1559 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
155b : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
155e : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1560 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1562 : 48              >            pha         ;use stack to load status
1563 : 28              >            plp
                        
1564 : a082                     ldy #$82
1566 : 08                       php
1567 : cc1802                   cpy abs1+1  ;test result
                                trap_ne
156a : d0fe            >        bne *           ;failed not equal (non zero)
                        
156c : 68                       pla         ;load status
                                eor_flag 0
156d : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
156f : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1572 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1574 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1576 : 48              >            pha         ;use stack to load status
1577 : 28              >            plp
                        
1578 : a041                     ldy #$41
157a : 08                       php
157b : cc1902                   cpy abs1+2  ;test result
                                trap_ne
157e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1580 : 68                       pla         ;load status
                                eor_flag 0
1581 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1583 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1586 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1588 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
158a : 48              >            pha         ;use stack to load status
158b : 28              >            plp
                        
158c : a000                     ldy #0
158e : 08                       php
158f : cc1a02                   cpy abs1+3  ;test result
                                trap_ne
1592 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1594 : 68                       pla         ;load status
                                eor_flag 0
1595 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1597 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
159a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
159c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
159e : 48              >            pha         ;use stack to load status
159f : 28              >            plp
                        
15a0 : a0c3                     ldy #$c3  
15a2 : 08                       php
15a3 : cc1702                   cpy abs1    ;test result
                                trap_ne
15a6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15a8 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
15a9 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
15ab : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
15ae : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
15b0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
15b2 : 48              >            pha         ;use stack to load status
15b3 : 28              >            plp
                        
15b4 : a082                     ldy #$82
15b6 : 08                       php
15b7 : cc1802                   cpy abs1+1  ;test result
                                trap_ne
15ba : d0fe            >        bne *           ;failed not equal (non zero)
                        
15bc : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
15bd : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
15bf : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
15c2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
15c4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
15c6 : 48              >            pha         ;use stack to load status
15c7 : 28              >            plp
                        
15c8 : a041                     ldy #$41
15ca : 08                       php
15cb : cc1902                   cpy abs1+2   ;test result
                                trap_ne
15ce : d0fe            >        bne *           ;failed not equal (non zero)
                        
15d0 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
15d1 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
15d3 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
15d6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
15d8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
15da : 48              >            pha         ;use stack to load status
15db : 28              >            plp
                        
15dc : a000                     ldy #0
15de : 08                       php
15df : cc1a02                   cpy abs1+3  ;test result
                                trap_ne
15e2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15e4 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
15e5 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
15e7 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
15ea : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                
15ec : a000                     ldy #0
15ee : a50c                     lda zpt  
15f0 : 49c3                     eor #$c3
15f2 : c513                     cmp zp1  
                                trap_ne     ;store to zp   data
15f4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
15f6 : 840c                     sty zpt     ;clear                
15f8 : ad0302                   lda abst  
15fb : 49c3                     eor #$c3
15fd : cd1702                   cmp abs1  
                                trap_ne     ;store to abs   data
1600 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1602 : 8c0302                   sty abst    ;clear                
1605 : a50d                     lda zpt+1
1607 : 49c3                     eor #$c3
1609 : c514                     cmp zp1+1
                                trap_ne     ;store to zp+1 data
160b : d0fe            >        bne *           ;failed not equal (non zero)
                        
160d : 840d                     sty zpt+1   ;clear                
160f : ad0402                   lda abst+1
1612 : 49c3                     eor #$c3
1614 : cd1802                   cmp abs1+1
                                trap_ne     ;store to abs+1 data
1617 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1619 : 8c0402                   sty abst+1  ;clear                
161c : a50e                     lda zpt+2
161e : 49c3                     eor #$c3
1620 : c515                     cmp zp1+2
                                trap_ne     ;store to zp+2 data
1622 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1624 : 840e                     sty zpt+2   ;clear                
1626 : ad0502                   lda abst+2
1629 : 49c3                     eor #$c3
162b : cd1902                   cmp abs1+2
                                trap_ne     ;store to abs+2 data
162e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1630 : 8c0502                   sty abst+2  ;clear                
1633 : a50f                     lda zpt+3
1635 : 49c3                     eor #$c3
1637 : c516                     cmp zp1+3
                                trap_ne     ;store to zp+3 data
1639 : d0fe            >        bne *           ;failed not equal (non zero)
                        
163b : 840f                     sty zpt+3   ;clear                
163d : ad0602                   lda abst+3
1640 : 49c3                     eor #$c3
1642 : cd1a02                   cmp abs1+3
                                trap_ne     ;store to abs+3 data
1645 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1647 : 8c0602                   sty abst+3  ;clear                
                                next_test
164a : ad0002          >            lda test_case   ;previous test
164d : c914            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
164f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0015 =                 >test_num = test_num + 1
1651 : a915            >            lda #test_num   ;*** next tests' number
1653 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing load / store accumulator LDA / STA all addressing modes
                        ; LDA / STA - zp,x / abs,x
1656 : a203                     ldx #3
1658 :                  tldax    
                                set_stat 0
                       >            load_flag 0
1658 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
165a : 48              >            pha         ;use stack to load status
165b : 28              >            plp
                        
165c : b513                     lda zp1,x
165e : 08                       php         ;test stores do not alter flags
165f : 49c3                     eor #$c3
1661 : 28                       plp
1662 : 9d0302                   sta abst,x
1665 : 08                       php         ;flags after load/store sequence
1666 : 49c3                     eor #$c3
1668 : dd1702                   cmp abs1,x  ;test result
                                trap_ne
166b : d0fe            >        bne *           ;failed not equal (non zero)
                        
166d : 68                       pla         ;load status
                                eor_flag 0
166e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1670 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
1673 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1675 : ca                       dex
1676 : 10e0                     bpl tldax                  
                        
1678 : a203                     ldx #3
167a :                  tldax1   
                                set_stat $ff
                       >            load_flag $ff
167a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
167c : 48              >            pha         ;use stack to load status
167d : 28              >            plp
                        
167e : b513                     lda zp1,x
1680 : 08                       php         ;test stores do not alter flags
1681 : 49c3                     eor #$c3
1683 : 28                       plp
1684 : 9d0302                   sta abst,x
1687 : 08                       php         ;flags after load/store sequence
1688 : 49c3                     eor #$c3
168a : dd1702                   cmp abs1,x   ;test result
                                trap_ne
168d : d0fe            >        bne *           ;failed not equal (non zero)
                        
168f : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1690 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1692 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
1695 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1697 : ca                       dex
1698 : 10e0                     bpl tldax1                  
                        
169a : a203                     ldx #3
169c :                  tldax2   
                                set_stat 0
                       >            load_flag 0
169c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
169e : 48              >            pha         ;use stack to load status
169f : 28              >            plp
                        
16a0 : bd1702                   lda abs1,x
16a3 : 08                       php         ;test stores do not alter flags
16a4 : 49c3                     eor #$c3
16a6 : 28                       plp
16a7 : 950c                     sta zpt,x
16a9 : 08                       php         ;flags after load/store sequence
16aa : 49c3                     eor #$c3
16ac : d513                     cmp zp1,x   ;test result
                                trap_ne
16ae : d0fe            >        bne *           ;failed not equal (non zero)
                        
16b0 : 68                       pla         ;load status
                                eor_flag 0
16b1 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
16b3 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
16b6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16b8 : ca                       dex
16b9 : 10e1                     bpl tldax2                  
                        
16bb : a203                     ldx #3
16bd :                  tldax3
                                set_stat $ff
                       >            load_flag $ff
16bd : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
16bf : 48              >            pha         ;use stack to load status
16c0 : 28              >            plp
                        
16c1 : bd1702                   lda abs1,x
16c4 : 08                       php         ;test stores do not alter flags
16c5 : 49c3                     eor #$c3
16c7 : 28                       plp
16c8 : 950c                     sta zpt,x
16ca : 08                       php         ;flags after load/store sequence
16cb : 49c3                     eor #$c3
16cd : d513                     cmp zp1,x   ;test result
                                trap_ne
16cf : d0fe            >        bne *           ;failed not equal (non zero)
                        
16d1 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
16d2 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
16d4 : dd1c02                   cmp fLDx,x  ;test flags
                                trap_ne
16d7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16d9 : ca                       dex
16da : 10e1                     bpl tldax3
                        
16dc : a203                     ldx #3      ;testing store result
16de : a000                     ldy #0
16e0 : b50c             tstax   lda zpt,x
16e2 : 49c3                     eor #$c3
16e4 : d513                     cmp zp1,x
                                trap_ne     ;store to zp,x data
16e6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16e8 : 940c                     sty zpt,x   ;clear                
16ea : bd0302                   lda abst,x
16ed : 49c3                     eor #$c3
16ef : dd1702                   cmp abs1,x
                                trap_ne     ;store to abs,x data
16f2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
16f4 : 8a                       txa
16f5 : 9d0302                   sta abst,x  ;clear                
16f8 : ca                       dex
16f9 : 10e5                     bpl tstax
                                next_test
16fb : ad0002          >            lda test_case   ;previous test
16fe : c915            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1700 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0016 =                 >test_num = test_num + 1
1702 : a916            >            lda #test_num   ;*** next tests' number
1704 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDA / STA - (zp),y / abs,y / (zp,x)
1707 : a003                     ldy #3
1709 :                  tlday    
                                set_stat 0
                       >            load_flag 0
1709 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
170b : 48              >            pha         ;use stack to load status
170c : 28              >            plp
                        
170d : b124                     lda (ind1),y
170f : 08                       php         ;test stores do not alter flags
1710 : 49c3                     eor #$c3
1712 : 28                       plp
1713 : 990302                   sta abst,y
1716 : 08                       php         ;flags after load/store sequence
1717 : 49c3                     eor #$c3
1719 : d91702                   cmp abs1,y  ;test result
                                trap_ne
171c : d0fe            >        bne *           ;failed not equal (non zero)
                        
171e : 68                       pla         ;load status
                                eor_flag 0
171f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1721 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
1724 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1726 : 88                       dey
1727 : 10e0                     bpl tlday                  
                        
1729 : a003                     ldy #3
172b :                  tlday1   
                                set_stat $ff
                       >            load_flag $ff
172b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
172d : 48              >            pha         ;use stack to load status
172e : 28              >            plp
                        
172f : b124                     lda (ind1),y
1731 : 08                       php         ;test stores do not alter flags
1732 : 49c3                     eor #$c3
1734 : 28                       plp
1735 : 990302                   sta abst,y
1738 : 08                       php         ;flags after load/store sequence
1739 : 49c3                     eor #$c3
173b : d91702                   cmp abs1,y  ;test result
                                trap_ne
173e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1740 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1741 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1743 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
1746 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1748 : 88                       dey
1749 : 10e0                     bpl tlday1                  
                        
174b : a003                     ldy #3      ;testing store result
174d : a200                     ldx #0
174f : b90302           tstay   lda abst,y
1752 : 49c3                     eor #$c3
1754 : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
1757 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1759 : 8a                       txa
175a : 990302                   sta abst,y  ;clear                
175d : 88                       dey
175e : 10ef                     bpl tstay
                        
1760 : a003                     ldy #3
1762 :                  tlday2   
                                set_stat 0
                       >            load_flag 0
1762 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1764 : 48              >            pha         ;use stack to load status
1765 : 28              >            plp
                        
1766 : b91702                   lda abs1,y
1769 : 08                       php         ;test stores do not alter flags
176a : 49c3                     eor #$c3
176c : 28                       plp
176d : 9130                     sta (indt),y
176f : 08                       php         ;flags after load/store sequence
1770 : 49c3                     eor #$c3
1772 : d124                     cmp (ind1),y    ;test result
                                trap_ne
1774 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1776 : 68                       pla         ;load status
                                eor_flag 0
1777 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1779 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
177c : d0fe            >        bne *           ;failed not equal (non zero)
                        
177e : 88                       dey
177f : 10e1                     bpl tlday2                  
                        
1781 : a003                     ldy #3
1783 :                  tlday3   
                                set_stat $ff
                       >            load_flag $ff
1783 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1785 : 48              >            pha         ;use stack to load status
1786 : 28              >            plp
                        
1787 : b91702                   lda abs1,y
178a : 08                       php         ;test stores do not alter flags
178b : 49c3                     eor #$c3
178d : 28                       plp
178e : 9130                     sta (indt),y
1790 : 08                       php         ;flags after load/store sequence
1791 : 49c3                     eor #$c3
1793 : d124                     cmp (ind1),y   ;test result
                                trap_ne
1795 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1797 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1798 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
179a : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
179d : d0fe            >        bne *           ;failed not equal (non zero)
                        
179f : 88                       dey
17a0 : 10e1                     bpl tlday3
                                
17a2 : a003                     ldy #3      ;testing store result
17a4 : a200                     ldx #0
17a6 : b90302           tstay1  lda abst,y
17a9 : 49c3                     eor #$c3
17ab : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
17ae : d0fe            >        bne *           ;failed not equal (non zero)
                        
17b0 : 8a                       txa
17b1 : 990302                   sta abst,y  ;clear                
17b4 : 88                       dey
17b5 : 10ef                     bpl tstay1
                                
17b7 : a206                     ldx #6
17b9 : a003                     ldy #3
17bb :                  tldax4   
                                set_stat 0
                       >            load_flag 0
17bb : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
17bd : 48              >            pha         ;use stack to load status
17be : 28              >            plp
                        
17bf : a124                     lda (ind1,x)
17c1 : 08                       php         ;test stores do not alter flags
17c2 : 49c3                     eor #$c3
17c4 : 28                       plp
17c5 : 8130                     sta (indt,x)
17c7 : 08                       php         ;flags after load/store sequence
17c8 : 49c3                     eor #$c3
17ca : d91702                   cmp abs1,y  ;test result
                                trap_ne
17cd : d0fe            >        bne *           ;failed not equal (non zero)
                        
17cf : 68                       pla         ;load status
                                eor_flag 0
17d0 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
17d2 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
17d5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
17d7 : ca                       dex
17d8 : ca                       dex
17d9 : 88                       dey
17da : 10df                     bpl tldax4                  
                        
17dc : a206                     ldx #6
17de : a003                     ldy #3
17e0 :                  tldax5
                                set_stat $ff
                       >            load_flag $ff
17e0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
17e2 : 48              >            pha         ;use stack to load status
17e3 : 28              >            plp
                        
17e4 : a124                     lda (ind1,x)
17e6 : 08                       php         ;test stores do not alter flags
17e7 : 49c3                     eor #$c3
17e9 : 28                       plp
17ea : 8130                     sta (indt,x)
17ec : 08                       php         ;flags after load/store sequence
17ed : 49c3                     eor #$c3
17ef : d91702                   cmp abs1,y  ;test result
                                trap_ne
17f2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
17f4 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
17f5 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
17f7 : d91c02                   cmp fLDx,y  ;test flags
                                trap_ne
17fa : d0fe            >        bne *           ;failed not equal (non zero)
                        
17fc : ca                       dex
17fd : ca                       dex
17fe : 88                       dey
17ff : 10df                     bpl tldax5
                        
1801 : a003                     ldy #3      ;testing store result
1803 : a200                     ldx #0
1805 : b90302           tstay2  lda abst,y
1808 : 49c3                     eor #$c3
180a : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
180d : d0fe            >        bne *           ;failed not equal (non zero)
                        
180f : 8a                       txa
1810 : 990302                   sta abst,y  ;clear                
1813 : 88                       dey
1814 : 10ef                     bpl tstay2
                                next_test
1816 : ad0002          >            lda test_case   ;previous test
1819 : c916            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
181b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0017 =                 >test_num = test_num + 1
181d : a917            >            lda #test_num   ;*** next tests' number
181f : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; indexed wraparound test (only zp should wrap)
1822 : a2fd                     ldx #3+$fa
1824 : b519             tldax6  lda zp1-$fa&$ff,x   ;wrap on indexed zp
1826 : 9d0901                   sta abst-$fa,x      ;no STX abs,x!
1829 : ca                       dex
182a : e0fa                     cpx #$fa
182c : b0f6                     bcs tldax6                  
182e : a2fd                     ldx #3+$fa
1830 : bd1d01           tldax7  lda abs1-$fa,x      ;no wrap on indexed abs
1833 : 9512                     sta zpt-$fa&$ff,x
1835 : ca                       dex
1836 : e0fa                     cpx #$fa
1838 : b0f6                     bcs tldax7
                                                  
183a : a203                     ldx #3      ;testing wraparound result
183c : a000                     ldy #0
183e : b50c             tstax1  lda zpt,x
1840 : d513                     cmp zp1,x
                                trap_ne     ;store to zp,x data
1842 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1844 : 940c                     sty zpt,x   ;clear                
1846 : bd0302                   lda abst,x
1849 : dd1702                   cmp abs1,x
                                trap_ne     ;store to abs,x data
184c : d0fe            >        bne *           ;failed not equal (non zero)
                        
184e : 8a                       txa
184f : 9d0302                   sta abst,x  ;clear                
1852 : ca                       dex
1853 : 10e9                     bpl tstax1
                        
1855 : a0fb                     ldy #3+$f8
1857 : a2fe                     ldx #6+$f8
1859 : a12c             tlday4  lda (ind1-$f8&$ff,x) ;wrap on indexed zp indirect
185b : 990b01                   sta abst-$f8,y
185e : ca                       dex
185f : ca                       dex
1860 : 88                       dey
1861 : c0f8                     cpy #$f8
1863 : b0f4                     bcs tlday4
1865 : a003                     ldy #3      ;testing wraparound result
1867 : a200                     ldx #0
1869 : b90302           tstay4  lda abst,y
186c : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
186f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1871 : 8a                       txa
1872 : 990302                   sta abst,y  ;clear                
1875 : 88                       dey
1876 : 10f1                     bpl tstay4
                                
1878 : a0fb                     ldy #3+$f8
187a : b91f01           tlday5  lda abs1-$f8,y  ;no wrap on indexed abs
187d : 9138                     sta (inwt),y
187f : 88                       dey
1880 : c0f8                     cpy #$f8
1882 : b0f6                     bcs tlday5                  
1884 : a003                     ldy #3      ;testing wraparound result
1886 : a200                     ldx #0
1888 : b90302           tstay5  lda abst,y
188b : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
188e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1890 : 8a                       txa
1891 : 990302                   sta abst,y  ;clear                
1894 : 88                       dey
1895 : 10f1                     bpl tstay5
                        
1897 : a0fb                     ldy #3+$f8
1899 : a2fe                     ldx #6+$f8
189b : b12e             tlday6  lda (inw1),y    ;no wrap on zp indirect indexed 
189d : 8138                     sta (indt-$f8&$ff,x)
189f : ca                       dex
18a0 : ca                       dex
18a1 : 88                       dey
18a2 : c0f8                     cpy #$f8
18a4 : b0f5                     bcs tlday6
18a6 : a003                     ldy #3      ;testing wraparound result
18a8 : a200                     ldx #0
18aa : b90302           tstay6  lda abst,y
18ad : d91702                   cmp abs1,y
                                trap_ne     ;store to abs data
18b0 : d0fe            >        bne *           ;failed not equal (non zero)
                        
18b2 : 8a                       txa
18b3 : 990302                   sta abst,y  ;clear                
18b6 : 88                       dey
18b7 : 10f1                     bpl tstay6
                                next_test
18b9 : ad0002          >            lda test_case   ;previous test
18bc : c917            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
18be : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0018 =                 >test_num = test_num + 1
18c0 : a918            >            lda #test_num   ;*** next tests' number
18c2 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; LDA / STA - zp / abs / #
                                set_stat 0  
                       >            load_flag 0  
18c5 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
18c7 : 48              >            pha         ;use stack to load status
18c8 : 28              >            plp
                        
18c9 : a513                     lda zp1
18cb : 08                       php         ;test stores do not alter flags
18cc : 49c3                     eor #$c3
18ce : 28                       plp
18cf : 8d0302                   sta abst
18d2 : 08                       php         ;flags after load/store sequence
18d3 : 49c3                     eor #$c3
18d5 : c9c3                     cmp #$c3    ;test result
                                trap_ne
18d7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
18d9 : 68                       pla         ;load status
                                eor_flag 0
18da : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
18dc : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
18df : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
18e1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
18e3 : 48              >            pha         ;use stack to load status
18e4 : 28              >            plp
                        
18e5 : a514                     lda zp1+1
18e7 : 08                       php         ;test stores do not alter flags
18e8 : 49c3                     eor #$c3
18ea : 28                       plp
18eb : 8d0402                   sta abst+1
18ee : 08                       php         ;flags after load/store sequence
18ef : 49c3                     eor #$c3
18f1 : c982                     cmp #$82    ;test result
                                trap_ne
18f3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
18f5 : 68                       pla         ;load status
                                eor_flag 0
18f6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
18f8 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
18fb : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
18fd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
18ff : 48              >            pha         ;use stack to load status
1900 : 28              >            plp
                        
1901 : a515                     lda zp1+2
1903 : 08                       php         ;test stores do not alter flags
1904 : 49c3                     eor #$c3
1906 : 28                       plp
1907 : 8d0502                   sta abst+2
190a : 08                       php         ;flags after load/store sequence
190b : 49c3                     eor #$c3
190d : c941                     cmp #$41    ;test result
                                trap_ne
190f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1911 : 68                       pla         ;load status
                                eor_flag 0
1912 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1914 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1917 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1919 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
191b : 48              >            pha         ;use stack to load status
191c : 28              >            plp
                        
191d : a516                     lda zp1+3
191f : 08                       php         ;test stores do not alter flags
1920 : 49c3                     eor #$c3
1922 : 28                       plp
1923 : 8d0602                   sta abst+3
1926 : 08                       php         ;flags after load/store sequence
1927 : 49c3                     eor #$c3
1929 : c900                     cmp #0      ;test result
                                trap_ne
192b : d0fe            >        bne *           ;failed not equal (non zero)
                        
192d : 68                       pla         ;load status
                                eor_flag 0
192e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1930 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1933 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1935 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1937 : 48              >            pha         ;use stack to load status
1938 : 28              >            plp
                        
1939 : a513                     lda zp1  
193b : 08                       php         ;test stores do not alter flags
193c : 49c3                     eor #$c3
193e : 28                       plp
193f : 8d0302                   sta abst  
1942 : 08                       php         ;flags after load/store sequence
1943 : 49c3                     eor #$c3
1945 : c9c3                     cmp #$c3    ;test result
                                trap_ne
1947 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1949 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
194a : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
194c : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
194f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1951 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1953 : 48              >            pha         ;use stack to load status
1954 : 28              >            plp
                        
1955 : a514                     lda zp1+1
1957 : 08                       php         ;test stores do not alter flags
1958 : 49c3                     eor #$c3
195a : 28                       plp
195b : 8d0402                   sta abst+1
195e : 08                       php         ;flags after load/store sequence
195f : 49c3                     eor #$c3
1961 : c982                     cmp #$82    ;test result
                                trap_ne
1963 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1965 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1966 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1968 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
196b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
196d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
196f : 48              >            pha         ;use stack to load status
1970 : 28              >            plp
                        
1971 : a515                     lda zp1+2
1973 : 08                       php         ;test stores do not alter flags
1974 : 49c3                     eor #$c3
1976 : 28                       plp
1977 : 8d0502                   sta abst+2
197a : 08                       php         ;flags after load/store sequence
197b : 49c3                     eor #$c3
197d : c941                     cmp #$41    ;test result
                                trap_ne
197f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1981 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1982 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1984 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1987 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1989 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
198b : 48              >            pha         ;use stack to load status
198c : 28              >            plp
                        
198d : a516                     lda zp1+3
198f : 08                       php         ;test stores do not alter flags
1990 : 49c3                     eor #$c3
1992 : 28                       plp
1993 : 8d0602                   sta abst+3
1996 : 08                       php         ;flags after load/store sequence
1997 : 49c3                     eor #$c3
1999 : c900                     cmp #0      ;test result
                                trap_ne
199b : d0fe            >        bne *           ;failed not equal (non zero)
                        
199d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
199e : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
19a0 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
19a3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
19a5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
19a7 : 48              >            pha         ;use stack to load status
19a8 : 28              >            plp
                        
19a9 : ad1702                   lda abs1  
19ac : 08                       php         ;test stores do not alter flags
19ad : 49c3                     eor #$c3
19af : 28                       plp
19b0 : 850c                     sta zpt  
19b2 : 08                       php         ;flags after load/store sequence
19b3 : 49c3                     eor #$c3
19b5 : c513                     cmp zp1     ;test result
                                trap_ne
19b7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
19b9 : 68                       pla         ;load status
                                eor_flag 0
19ba : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
19bc : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
19bf : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
19c1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
19c3 : 48              >            pha         ;use stack to load status
19c4 : 28              >            plp
                        
19c5 : ad1802                   lda abs1+1
19c8 : 08                       php         ;test stores do not alter flags
19c9 : 49c3                     eor #$c3
19cb : 28                       plp
19cc : 850d                     sta zpt+1
19ce : 08                       php         ;flags after load/store sequence
19cf : 49c3                     eor #$c3
19d1 : c514                     cmp zp1+1   ;test result
                                trap_ne
19d3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
19d5 : 68                       pla         ;load status
                                eor_flag 0
19d6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
19d8 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
19db : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
19dd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
19df : 48              >            pha         ;use stack to load status
19e0 : 28              >            plp
                        
19e1 : ad1902                   lda abs1+2
19e4 : 08                       php         ;test stores do not alter flags
19e5 : 49c3                     eor #$c3
19e7 : 28                       plp
19e8 : 850e                     sta zpt+2
19ea : 08                       php         ;flags after load/store sequence
19eb : 49c3                     eor #$c3
19ed : c515                     cmp zp1+2   ;test result
                                trap_ne
19ef : d0fe            >        bne *           ;failed not equal (non zero)
                        
19f1 : 68                       pla         ;load status
                                eor_flag 0
19f2 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
19f4 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
19f7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
19f9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
19fb : 48              >            pha         ;use stack to load status
19fc : 28              >            plp
                        
19fd : ad1a02                   lda abs1+3
1a00 : 08                       php         ;test stores do not alter flags
1a01 : 49c3                     eor #$c3
1a03 : 28                       plp
1a04 : 850f                     sta zpt+3
1a06 : 08                       php         ;flags after load/store sequence
1a07 : 49c3                     eor #$c3
1a09 : c516                     cmp zp1+3   ;test result
                                trap_ne
1a0b : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a0d : 68                       pla         ;load status
                                eor_flag 0
1a0e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1a10 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1a13 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1a15 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1a17 : 48              >            pha         ;use stack to load status
1a18 : 28              >            plp
                        
1a19 : ad1702                   lda abs1  
1a1c : 08                       php         ;test stores do not alter flags
1a1d : 49c3                     eor #$c3
1a1f : 28                       plp
1a20 : 850c                     sta zpt  
1a22 : 08                       php         ;flags after load/store sequence
1a23 : 49c3                     eor #$c3
1a25 : c513                     cmp zp1     ;test result
                                trap_ne
1a27 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a29 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a2a : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1a2c : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1a2f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1a31 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1a33 : 48              >            pha         ;use stack to load status
1a34 : 28              >            plp
                        
1a35 : ad1802                   lda abs1+1
1a38 : 08                       php         ;test stores do not alter flags
1a39 : 49c3                     eor #$c3
1a3b : 28                       plp
1a3c : 850d                     sta zpt+1
1a3e : 08                       php         ;flags after load/store sequence
1a3f : 49c3                     eor #$c3
1a41 : c514                     cmp zp1+1   ;test result
                                trap_ne
1a43 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a45 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a46 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1a48 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1a4b : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1a4d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1a4f : 48              >            pha         ;use stack to load status
1a50 : 28              >            plp
                        
1a51 : ad1902                   lda abs1+2
1a54 : 08                       php         ;test stores do not alter flags
1a55 : 49c3                     eor #$c3
1a57 : 28                       plp
1a58 : 850e                     sta zpt+2
1a5a : 08                       php         ;flags after load/store sequence
1a5b : 49c3                     eor #$c3
1a5d : c515                     cmp zp1+2   ;test result
                                trap_ne
1a5f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a61 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a62 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1a64 : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1a67 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1a69 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1a6b : 48              >            pha         ;use stack to load status
1a6c : 28              >            plp
                        
1a6d : ad1a02                   lda abs1+3
1a70 : 08                       php         ;test stores do not alter flags
1a71 : 49c3                     eor #$c3
1a73 : 28                       plp
1a74 : 850f                     sta zpt+3
1a76 : 08                       php         ;flags after load/store sequence
1a77 : 49c3                     eor #$c3
1a79 : c516                     cmp zp1+3   ;test result
                                trap_ne
1a7b : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a7d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1a7e : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1a80 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1a83 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0  
                       >            load_flag 0  
1a85 : a900            >            lda #0               ;allow test to change I-flag (no mask)
                       >
1a87 : 48              >            pha         ;use stack to load status
1a88 : 28              >            plp
                        
1a89 : a9c3                     lda #$c3
1a8b : 08                       php
1a8c : cd1702                   cmp abs1    ;test result
                                trap_ne
1a8f : d0fe            >        bne *           ;failed not equal (non zero)
                        
1a91 : 68                       pla         ;load status
                                eor_flag 0
1a92 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1a94 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1a97 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1a99 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1a9b : 48              >            pha         ;use stack to load status
1a9c : 28              >            plp
                        
1a9d : a982                     lda #$82
1a9f : 08                       php
1aa0 : cd1802                   cmp abs1+1  ;test result
                                trap_ne
1aa3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1aa5 : 68                       pla         ;load status
                                eor_flag 0
1aa6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1aa8 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1aab : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1aad : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1aaf : 48              >            pha         ;use stack to load status
1ab0 : 28              >            plp
                        
1ab1 : a941                     lda #$41
1ab3 : 08                       php
1ab4 : cd1902                   cmp abs1+2  ;test result
                                trap_ne
1ab7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ab9 : 68                       pla         ;load status
                                eor_flag 0
1aba : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1abc : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1abf : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat 0
                       >            load_flag 0
1ac1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1ac3 : 48              >            pha         ;use stack to load status
1ac4 : 28              >            plp
                        
1ac5 : a900                     lda #0
1ac7 : 08                       php
1ac8 : cd1a02                   cmp abs1+3  ;test result
                                trap_ne
1acb : d0fe            >        bne *           ;failed not equal (non zero)
                        
1acd : 68                       pla         ;load status
                                eor_flag 0
1ace : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                        
1ad0 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1ad3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
                                set_stat $ff
                       >            load_flag $ff
1ad5 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1ad7 : 48              >            pha         ;use stack to load status
1ad8 : 28              >            plp
                        
1ad9 : a9c3                     lda #$c3  
1adb : 08                       php
1adc : cd1702                   cmp abs1    ;test result
                                trap_ne
1adf : d0fe            >        bne *           ;failed not equal (non zero)
                        
1ae1 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1ae2 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1ae4 : cd1c02                   cmp fLDx    ;test flags
                                trap_ne
1ae7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1ae9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1aeb : 48              >            pha         ;use stack to load status
1aec : 28              >            plp
                        
1aed : a982                     lda #$82
1aef : 08                       php
1af0 : cd1802                   cmp abs1+1  ;test result
                                trap_ne
1af3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1af5 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1af6 : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1af8 : cd1d02                   cmp fLDx+1  ;test flags
                                trap_ne
1afb : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1afd : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1aff : 48              >            pha         ;use stack to load status
1b00 : 28              >            plp
                        
1b01 : a941                     lda #$41
1b03 : 08                       php
1b04 : cd1902                   cmp abs1+2  ;test result
                                trap_ne
1b07 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b09 : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1b0a : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1b0c : cd1e02                   cmp fLDx+2  ;test flags
                                trap_ne
1b0f : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
1b11 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1b13 : 48              >            pha         ;use stack to load status
1b14 : 28              >            plp
                        
1b15 : a900                     lda #0
1b17 : 08                       php
1b18 : cd1a02                   cmp abs1+3  ;test result
                                trap_ne
1b1b : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b1d : 68                       pla         ;load status
                                eor_flag lo~fnz ;mask bits not altered
1b1e : 497d            >            eor #lo~fnz |fao         ;invert expected flags + always on bits
                        
1b20 : cd1f02                   cmp fLDx+3  ;test flags
                                trap_ne
1b23 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                        
1b25 : a200                     ldx #0
1b27 : a50c                     lda zpt  
1b29 : 49c3                     eor #$c3
1b2b : c513                     cmp zp1  
                                trap_ne     ;store to zp data
1b2d : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b2f : 860c                     stx zpt     ;clear                
1b31 : ad0302                   lda abst  
1b34 : 49c3                     eor #$c3
1b36 : cd1702                   cmp abs1  
                                trap_ne     ;store to abs data
1b39 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b3b : 8e0302                   stx abst    ;clear                
1b3e : a50d                     lda zpt+1
1b40 : 49c3                     eor #$c3
1b42 : c514                     cmp zp1+1
                                trap_ne     ;store to zp data
1b44 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b46 : 860d                     stx zpt+1   ;clear                
1b48 : ad0402                   lda abst+1
1b4b : 49c3                     eor #$c3
1b4d : cd1802                   cmp abs1+1
                                trap_ne     ;store to abs data
1b50 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b52 : 8e0402                   stx abst+1  ;clear                
1b55 : a50e                     lda zpt+2
1b57 : 49c3                     eor #$c3
1b59 : c515                     cmp zp1+2
                                trap_ne     ;store to zp data
1b5b : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b5d : 860e                     stx zpt+2   ;clear                
1b5f : ad0502                   lda abst+2
1b62 : 49c3                     eor #$c3
1b64 : cd1902                   cmp abs1+2
                                trap_ne     ;store to abs data
1b67 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b69 : 8e0502                   stx abst+2  ;clear                
1b6c : a50f                     lda zpt+3
1b6e : 49c3                     eor #$c3
1b70 : c516                     cmp zp1+3
                                trap_ne     ;store to zp data
1b72 : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b74 : 860f                     stx zpt+3   ;clear                
1b76 : ad0602                   lda abst+3
1b79 : 49c3                     eor #$c3
1b7b : cd1a02                   cmp abs1+3
                                trap_ne     ;store to abs data
1b7e : d0fe            >        bne *           ;failed not equal (non zero)
                        
1b80 : 8e0602                   stx abst+3  ;clear                
                                next_test
1b83 : ad0002          >            lda test_case   ;previous test
1b86 : c918            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1b88 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0019 =                 >test_num = test_num + 1
1b8a : a919            >            lda #test_num   ;*** next tests' number
1b8c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing bit test & compares BIT CPX CPY CMP all addressing modes
                        ; BIT - zp / abs
                                set_a $ff,0
                       >            load_flag 0
1b8f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1b91 : 48              >            pha         ;use stack to load status
1b92 : a9ff            >            lda #$ff     ;precharge accu
1b94 : 28              >            plp
                        
1b95 : 2416                     bit zp1+3   ;00 - should set Z / clear  NV
                                tst_a $ff,fz 
1b97 : 08              >            php         ;save flags
1b98 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1b9a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1b9c : 68              >            pla         ;load status
1b9d : 48              >            pha
                       >            cmp_flag fz 
1b9e : c932            >            cmp #(fz |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ba0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ba2 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1ba3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1ba5 : 48              >            pha         ;use stack to load status
1ba6 : a901            >            lda #1     ;precharge accu
1ba8 : 28              >            plp
                        
1ba9 : 2415                     bit zp1+2   ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
1bab : 08              >            php         ;save flags
1bac : c901            >            cmp #1     ;test result
                       >            trap_ne
1bae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bb0 : 68              >            pla         ;load status
1bb1 : 48              >            pha
                       >            cmp_flag fv
1bb2 : c970            >            cmp #(fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bb4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bb6 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1bb7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1bb9 : 48              >            pha         ;use stack to load status
1bba : a901            >            lda #1     ;precharge accu
1bbc : 28              >            plp
                        
1bbd : 2414                     bit zp1+1   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
1bbf : 08              >            php         ;save flags
1bc0 : c901            >            cmp #1     ;test result
                       >            trap_ne
1bc2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bc4 : 68              >            pla         ;load status
1bc5 : 48              >            pha
                       >            cmp_flag fnz
1bc6 : c9b2            >            cmp #(fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bc8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bca : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1bcb : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1bcd : 48              >            pha         ;use stack to load status
1bce : a901            >            lda #1     ;precharge accu
1bd0 : 28              >            plp
                        
1bd1 : 2413                     bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
1bd3 : 08              >            php         ;save flags
1bd4 : c901            >            cmp #1     ;test result
                       >            trap_ne
1bd6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bd8 : 68              >            pla         ;load status
1bd9 : 48              >            pha
                       >            cmp_flag fnv
1bda : c9f0            >            cmp #(fnv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bdc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bde : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,$ff
                       >            load_flag $ff
1bdf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1be1 : 48              >            pha         ;use stack to load status
1be2 : a9ff            >            lda #$ff     ;precharge accu
1be4 : 28              >            plp
                        
1be5 : 2416                     bit zp1+3   ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv 
1be7 : 08              >            php         ;save flags
1be8 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1bea : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bec : 68              >            pla         ;load status
1bed : 48              >            pha
                       >            cmp_flag ~fnv 
1bee : c93f            >            cmp #(~fnv |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1bf0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1bf2 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1bf3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1bf5 : 48              >            pha         ;use stack to load status
1bf6 : a901            >            lda #1     ;precharge accu
1bf8 : 28              >            plp
                        
1bf9 : 2415                     bit zp1+2   ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
1bfb : 08              >            php         ;save flags
1bfc : c901            >            cmp #1     ;test result
                       >            trap_ne
1bfe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c00 : 68              >            pla         ;load status
1c01 : 48              >            pha
                       >            cmp_flag ~fnz
1c02 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c04 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c06 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1c07 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1c09 : 48              >            pha         ;use stack to load status
1c0a : a901            >            lda #1     ;precharge accu
1c0c : 28              >            plp
                        
1c0d : 2414                     bit zp1+1   ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
1c0f : 08              >            php         ;save flags
1c10 : c901            >            cmp #1     ;test result
                       >            trap_ne
1c12 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c14 : 68              >            pla         ;load status
1c15 : 48              >            pha
                       >            cmp_flag ~fv
1c16 : c9bf            >            cmp #(~fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c18 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c1a : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1c1b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1c1d : 48              >            pha         ;use stack to load status
1c1e : a901            >            lda #1     ;precharge accu
1c20 : 28              >            plp
                        
1c21 : 2413                     bit zp1     ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
1c23 : 08              >            php         ;save flags
1c24 : c901            >            cmp #1     ;test result
                       >            trap_ne
1c26 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c28 : 68              >            pla         ;load status
1c29 : 48              >            pha
                       >            cmp_flag ~fz
1c2a : c9fd            >            cmp #(~fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c2c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c2e : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,0
                       >            load_flag 0
1c2f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1c31 : 48              >            pha         ;use stack to load status
1c32 : a9ff            >            lda #$ff     ;precharge accu
1c34 : 28              >            plp
                        
1c35 : 2c1a02                   bit abs1+3  ;00 - should set Z / clear  NV
                                tst_a $ff,fz 
1c38 : 08              >            php         ;save flags
1c39 : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1c3b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c3d : 68              >            pla         ;load status
1c3e : 48              >            pha
                       >            cmp_flag fz 
1c3f : c932            >            cmp #(fz |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c41 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c43 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1c44 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1c46 : 48              >            pha         ;use stack to load status
1c47 : a901            >            lda #1     ;precharge accu
1c49 : 28              >            plp
                        
1c4a : 2c1902                   bit abs1+2  ;41 - should set V (M6) / clear NZ
                                tst_a 1,fv
1c4d : 08              >            php         ;save flags
1c4e : c901            >            cmp #1     ;test result
                       >            trap_ne
1c50 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c52 : 68              >            pla         ;load status
1c53 : 48              >            pha
                       >            cmp_flag fv
1c54 : c970            >            cmp #(fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c56 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c58 : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1c59 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1c5b : 48              >            pha         ;use stack to load status
1c5c : a901            >            lda #1     ;precharge accu
1c5e : 28              >            plp
                        
1c5f : 2c1802                   bit abs1+1  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,fnz
1c62 : 08              >            php         ;save flags
1c63 : c901            >            cmp #1     ;test result
                       >            trap_ne
1c65 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c67 : 68              >            pla         ;load status
1c68 : 48              >            pha
                       >            cmp_flag fnz
1c69 : c9b2            >            cmp #(fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c6b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c6d : 28              >            plp         ;restore status
                        
                                set_a 1,0
                       >            load_flag 0
1c6e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1c70 : 48              >            pha         ;use stack to load status
1c71 : a901            >            lda #1     ;precharge accu
1c73 : 28              >            plp
                        
1c74 : 2c1702                   bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,fnv
1c77 : 08              >            php         ;save flags
1c78 : c901            >            cmp #1     ;test result
                       >            trap_ne
1c7a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c7c : 68              >            pla         ;load status
1c7d : 48              >            pha
                       >            cmp_flag fnv
1c7e : c9f0            >            cmp #(fnv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c80 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c82 : 28              >            plp         ;restore status
                        
                                
                                set_a $ff,$ff
                       >            load_flag $ff
1c83 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1c85 : 48              >            pha         ;use stack to load status
1c86 : a9ff            >            lda #$ff     ;precharge accu
1c88 : 28              >            plp
                        
1c89 : 2c1a02                   bit abs1+3  ;00 - should set Z / clear  NV
                                tst_a $ff,~fnv 
1c8c : 08              >            php         ;save flags
1c8d : c9ff            >            cmp #$ff     ;test result
                       >            trap_ne
1c8f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c91 : 68              >            pla         ;load status
1c92 : 48              >            pha
                       >            cmp_flag ~fnv 
1c93 : c93f            >            cmp #(~fnv |fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1c95 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1c97 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1c98 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1c9a : 48              >            pha         ;use stack to load status
1c9b : a901            >            lda #1     ;precharge accu
1c9d : 28              >            plp
                        
1c9e : 2c1902                   bit abs1+2  ;41 - should set V (M6) / clear NZ
                                tst_a 1,~fnz
1ca1 : 08              >            php         ;save flags
1ca2 : c901            >            cmp #1     ;test result
                       >            trap_ne
1ca4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ca6 : 68              >            pla         ;load status
1ca7 : 48              >            pha
                       >            cmp_flag ~fnz
1ca8 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1caa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cac : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1cad : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1caf : 48              >            pha         ;use stack to load status
1cb0 : a901            >            lda #1     ;precharge accu
1cb2 : 28              >            plp
                        
1cb3 : 2c1802                   bit abs1+1  ;82 - should set N (M7) & Z / clear V
                                tst_a 1,~fv
1cb6 : 08              >            php         ;save flags
1cb7 : c901            >            cmp #1     ;test result
                       >            trap_ne
1cb9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cbb : 68              >            pla         ;load status
1cbc : 48              >            pha
                       >            cmp_flag ~fv
1cbd : c9bf            >            cmp #(~fv|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cbf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cc1 : 28              >            plp         ;restore status
                        
                                set_a 1,$ff
                       >            load_flag $ff
1cc2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1cc4 : 48              >            pha         ;use stack to load status
1cc5 : a901            >            lda #1     ;precharge accu
1cc7 : 28              >            plp
                        
1cc8 : 2c1702                   bit abs1    ;c3 - should set N (M7) & V (M6) / clear Z
                                tst_a 1,~fz
1ccb : 08              >            php         ;save flags
1ccc : c901            >            cmp #1     ;test result
                       >            trap_ne
1cce : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cd0 : 68              >            pla         ;load status
1cd1 : 48              >            pha
                       >            cmp_flag ~fz
1cd2 : c9fd            >            cmp #(~fz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cd4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cd6 : 28              >            plp         ;restore status
                        
                                next_test
1cd7 : ad0002          >            lda test_case   ;previous test
1cda : c919            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1cdc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001a =                 >test_num = test_num + 1
1cde : a91a            >            lda #test_num   ;*** next tests' number
1ce0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; CPX - zp / abs / #         
                                set_x $80,0
                       >            load_flag 0
1ce3 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1ce5 : 48              >            pha         ;use stack to load status
1ce6 : a280            >            ldx #$80     ;precharge index x
1ce8 : 28              >            plp
                        
1ce9 : e417                     cpx zp7f
                                tst_stat fc
1ceb : 08              >            php         ;save status
1cec : 68              >            pla         ;use stack to retrieve status
1ced : 48              >            pha
                       >            cmp_flag fc
1cee : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cf0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cf2 : 28              >            plp         ;restore status
                        
1cf3 : ca                       dex
1cf4 : e417                     cpx zp7f
                                tst_stat fzc
1cf6 : 08              >            php         ;save status
1cf7 : 68              >            pla         ;use stack to retrieve status
1cf8 : 48              >            pha
                       >            cmp_flag fzc
1cf9 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1cfb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1cfd : 28              >            plp         ;restore status
                        
1cfe : ca                       dex
1cff : e417                     cpx zp7f
                                tst_x $7e,fn
1d01 : 08              >            php         ;save flags
1d02 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1d04 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d06 : 68              >            pla         ;load status
1d07 : 48              >            pha
                       >            cmp_flag fn
1d08 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d0a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d0c : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1d0d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1d0f : 48              >            pha         ;use stack to load status
1d10 : a280            >            ldx #$80     ;precharge index x
1d12 : 28              >            plp
                        
1d13 : e417                     cpx zp7f
                                tst_stat ~fnz
1d15 : 08              >            php         ;save status
1d16 : 68              >            pla         ;use stack to retrieve status
1d17 : 48              >            pha
                       >            cmp_flag ~fnz
1d18 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d1a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d1c : 28              >            plp         ;restore status
                        
1d1d : ca                       dex
1d1e : e417                     cpx zp7f
                                tst_stat ~fn
1d20 : 08              >            php         ;save status
1d21 : 68              >            pla         ;use stack to retrieve status
1d22 : 48              >            pha
                       >            cmp_flag ~fn
1d23 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d25 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d27 : 28              >            plp         ;restore status
                        
1d28 : ca                       dex
1d29 : e417                     cpx zp7f
                                tst_x $7e,~fzc
1d2b : 08              >            php         ;save flags
1d2c : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1d2e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d30 : 68              >            pla         ;load status
1d31 : 48              >            pha
                       >            cmp_flag ~fzc
1d32 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d34 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d36 : 28              >            plp         ;restore status
                        
                        
                                set_x $80,0
                       >            load_flag 0
1d37 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1d39 : 48              >            pha         ;use stack to load status
1d3a : a280            >            ldx #$80     ;precharge index x
1d3c : 28              >            plp
                        
1d3d : ec1b02                   cpx abs7f
                                tst_stat fc
1d40 : 08              >            php         ;save status
1d41 : 68              >            pla         ;use stack to retrieve status
1d42 : 48              >            pha
                       >            cmp_flag fc
1d43 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d45 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d47 : 28              >            plp         ;restore status
                        
1d48 : ca                       dex
1d49 : ec1b02                   cpx abs7f
                                tst_stat fzc
1d4c : 08              >            php         ;save status
1d4d : 68              >            pla         ;use stack to retrieve status
1d4e : 48              >            pha
                       >            cmp_flag fzc
1d4f : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d51 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d53 : 28              >            plp         ;restore status
                        
1d54 : ca                       dex
1d55 : ec1b02                   cpx abs7f
                                tst_x $7e,fn
1d58 : 08              >            php         ;save flags
1d59 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1d5b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d5d : 68              >            pla         ;load status
1d5e : 48              >            pha
                       >            cmp_flag fn
1d5f : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d61 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d63 : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1d64 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1d66 : 48              >            pha         ;use stack to load status
1d67 : a280            >            ldx #$80     ;precharge index x
1d69 : 28              >            plp
                        
1d6a : ec1b02                   cpx abs7f
                                tst_stat ~fnz
1d6d : 08              >            php         ;save status
1d6e : 68              >            pla         ;use stack to retrieve status
1d6f : 48              >            pha
                       >            cmp_flag ~fnz
1d70 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d72 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d74 : 28              >            plp         ;restore status
                        
1d75 : ca                       dex
1d76 : ec1b02                   cpx abs7f
                                tst_stat ~fn
1d79 : 08              >            php         ;save status
1d7a : 68              >            pla         ;use stack to retrieve status
1d7b : 48              >            pha
                       >            cmp_flag ~fn
1d7c : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d7e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d80 : 28              >            plp         ;restore status
                        
1d81 : ca                       dex
1d82 : ec1b02                   cpx abs7f
                                tst_x $7e,~fzc
1d85 : 08              >            php         ;save flags
1d86 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1d88 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d8a : 68              >            pla         ;load status
1d8b : 48              >            pha
                       >            cmp_flag ~fzc
1d8c : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d8e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1d90 : 28              >            plp         ;restore status
                        
                        
                                set_x $80,0
                       >            load_flag 0
1d91 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1d93 : 48              >            pha         ;use stack to load status
1d94 : a280            >            ldx #$80     ;precharge index x
1d96 : 28              >            plp
                        
1d97 : e07f                     cpx #$7f
                                tst_stat fc
1d99 : 08              >            php         ;save status
1d9a : 68              >            pla         ;use stack to retrieve status
1d9b : 48              >            pha
                       >            cmp_flag fc
1d9c : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1d9e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1da0 : 28              >            plp         ;restore status
                        
1da1 : ca                       dex
1da2 : e07f                     cpx #$7f
                                tst_stat fzc
1da4 : 08              >            php         ;save status
1da5 : 68              >            pla         ;use stack to retrieve status
1da6 : 48              >            pha
                       >            cmp_flag fzc
1da7 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1da9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dab : 28              >            plp         ;restore status
                        
1dac : ca                       dex
1dad : e07f                     cpx #$7f
                                tst_x $7e,fn
1daf : 08              >            php         ;save flags
1db0 : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1db2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1db4 : 68              >            pla         ;load status
1db5 : 48              >            pha
                       >            cmp_flag fn
1db6 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1db8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dba : 28              >            plp         ;restore status
                        
                                set_x $80,$ff
                       >            load_flag $ff
1dbb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1dbd : 48              >            pha         ;use stack to load status
1dbe : a280            >            ldx #$80     ;precharge index x
1dc0 : 28              >            plp
                        
1dc1 : e07f                     cpx #$7f
                                tst_stat ~fnz
1dc3 : 08              >            php         ;save status
1dc4 : 68              >            pla         ;use stack to retrieve status
1dc5 : 48              >            pha
                       >            cmp_flag ~fnz
1dc6 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1dc8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dca : 28              >            plp         ;restore status
                        
1dcb : ca                       dex
1dcc : e07f                     cpx #$7f
                                tst_stat ~fn
1dce : 08              >            php         ;save status
1dcf : 68              >            pla         ;use stack to retrieve status
1dd0 : 48              >            pha
                       >            cmp_flag ~fn
1dd1 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1dd3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dd5 : 28              >            plp         ;restore status
                        
1dd6 : ca                       dex
1dd7 : e07f                     cpx #$7f
                                tst_x $7e,~fzc
1dd9 : 08              >            php         ;save flags
1dda : e07e            >            cpx #$7e     ;test result
                       >            trap_ne
1ddc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1dde : 68              >            pla         ;load status
1ddf : 48              >            pha
                       >            cmp_flag ~fzc
1de0 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1de2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1de4 : 28              >            plp         ;restore status
                        
                                next_test
1de5 : ad0002          >            lda test_case   ;previous test
1de8 : c91a            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1dea : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001b =                 >test_num = test_num + 1
1dec : a91b            >            lda #test_num   ;*** next tests' number
1dee : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CPY - zp / abs / #         
                                set_y $80,0
                       >            load_flag 0
1df1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1df3 : 48              >            pha         ;use stack to load status
1df4 : a080            >            ldy #$80     ;precharge index y
1df6 : 28              >            plp
                        
1df7 : c417                     cpy zp7f
                                tst_stat fc
1df9 : 08              >            php         ;save status
1dfa : 68              >            pla         ;use stack to retrieve status
1dfb : 48              >            pha
                       >            cmp_flag fc
1dfc : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1dfe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e00 : 28              >            plp         ;restore status
                        
1e01 : 88                       dey
1e02 : c417                     cpy zp7f
                                tst_stat fzc
1e04 : 08              >            php         ;save status
1e05 : 68              >            pla         ;use stack to retrieve status
1e06 : 48              >            pha
                       >            cmp_flag fzc
1e07 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e09 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e0b : 28              >            plp         ;restore status
                        
1e0c : 88                       dey
1e0d : c417                     cpy zp7f
                                tst_y $7e,fn
1e0f : 08              >            php         ;save flags
1e10 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1e12 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e14 : 68              >            pla         ;load status
1e15 : 48              >            pha
                       >            cmp_flag fn
1e16 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e18 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e1a : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1e1b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1e1d : 48              >            pha         ;use stack to load status
1e1e : a080            >            ldy #$80     ;precharge index y
1e20 : 28              >            plp
                        
1e21 : c417                     cpy zp7f
                                tst_stat ~fnz
1e23 : 08              >            php         ;save status
1e24 : 68              >            pla         ;use stack to retrieve status
1e25 : 48              >            pha
                       >            cmp_flag ~fnz
1e26 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e28 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e2a : 28              >            plp         ;restore status
                        
1e2b : 88                       dey
1e2c : c417                     cpy zp7f
                                tst_stat ~fn
1e2e : 08              >            php         ;save status
1e2f : 68              >            pla         ;use stack to retrieve status
1e30 : 48              >            pha
                       >            cmp_flag ~fn
1e31 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e33 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e35 : 28              >            plp         ;restore status
                        
1e36 : 88                       dey
1e37 : c417                     cpy zp7f
                                tst_y $7e,~fzc
1e39 : 08              >            php         ;save flags
1e3a : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1e3c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e3e : 68              >            pla         ;load status
1e3f : 48              >            pha
                       >            cmp_flag ~fzc
1e40 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e42 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e44 : 28              >            plp         ;restore status
                        
                        
                                set_y $80,0
                       >            load_flag 0
1e45 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1e47 : 48              >            pha         ;use stack to load status
1e48 : a080            >            ldy #$80     ;precharge index y
1e4a : 28              >            plp
                        
1e4b : cc1b02                   cpy abs7f
                                tst_stat fc
1e4e : 08              >            php         ;save status
1e4f : 68              >            pla         ;use stack to retrieve status
1e50 : 48              >            pha
                       >            cmp_flag fc
1e51 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e53 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e55 : 28              >            plp         ;restore status
                        
1e56 : 88                       dey
1e57 : cc1b02                   cpy abs7f
                                tst_stat fzc
1e5a : 08              >            php         ;save status
1e5b : 68              >            pla         ;use stack to retrieve status
1e5c : 48              >            pha
                       >            cmp_flag fzc
1e5d : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e5f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e61 : 28              >            plp         ;restore status
                        
1e62 : 88                       dey
1e63 : cc1b02                   cpy abs7f
                                tst_y $7e,fn
1e66 : 08              >            php         ;save flags
1e67 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1e69 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e6b : 68              >            pla         ;load status
1e6c : 48              >            pha
                       >            cmp_flag fn
1e6d : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e6f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e71 : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1e72 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1e74 : 48              >            pha         ;use stack to load status
1e75 : a080            >            ldy #$80     ;precharge index y
1e77 : 28              >            plp
                        
1e78 : cc1b02                   cpy abs7f
                                tst_stat ~fnz
1e7b : 08              >            php         ;save status
1e7c : 68              >            pla         ;use stack to retrieve status
1e7d : 48              >            pha
                       >            cmp_flag ~fnz
1e7e : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e80 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e82 : 28              >            plp         ;restore status
                        
1e83 : 88                       dey
1e84 : cc1b02                   cpy abs7f
                                tst_stat ~fn
1e87 : 08              >            php         ;save status
1e88 : 68              >            pla         ;use stack to retrieve status
1e89 : 48              >            pha
                       >            cmp_flag ~fn
1e8a : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e8c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e8e : 28              >            plp         ;restore status
                        
1e8f : 88                       dey
1e90 : cc1b02                   cpy abs7f
                                tst_y $7e,~fzc
1e93 : 08              >            php         ;save flags
1e94 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1e96 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e98 : 68              >            pla         ;load status
1e99 : 48              >            pha
                       >            cmp_flag ~fzc
1e9a : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1e9c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1e9e : 28              >            plp         ;restore status
                        
                        
                                set_y $80,0
                       >            load_flag 0
1e9f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1ea1 : 48              >            pha         ;use stack to load status
1ea2 : a080            >            ldy #$80     ;precharge index y
1ea4 : 28              >            plp
                        
1ea5 : c07f                     cpy #$7f
                                tst_stat fc
1ea7 : 08              >            php         ;save status
1ea8 : 68              >            pla         ;use stack to retrieve status
1ea9 : 48              >            pha
                       >            cmp_flag fc
1eaa : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1eac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1eae : 28              >            plp         ;restore status
                        
1eaf : 88                       dey
1eb0 : c07f                     cpy #$7f
                                tst_stat fzc
1eb2 : 08              >            php         ;save status
1eb3 : 68              >            pla         ;use stack to retrieve status
1eb4 : 48              >            pha
                       >            cmp_flag fzc
1eb5 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1eb7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1eb9 : 28              >            plp         ;restore status
                        
1eba : 88                       dey
1ebb : c07f                     cpy #$7f
                                tst_y $7e,fn
1ebd : 08              >            php         ;save flags
1ebe : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1ec0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ec2 : 68              >            pla         ;load status
1ec3 : 48              >            pha
                       >            cmp_flag fn
1ec4 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ec6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ec8 : 28              >            plp         ;restore status
                        
                                set_y $80,$ff
                       >            load_flag $ff
1ec9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1ecb : 48              >            pha         ;use stack to load status
1ecc : a080            >            ldy #$80     ;precharge index y
1ece : 28              >            plp
                        
1ecf : c07f                     cpy #$7f
                                tst_stat ~fnz
1ed1 : 08              >            php         ;save status
1ed2 : 68              >            pla         ;use stack to retrieve status
1ed3 : 48              >            pha
                       >            cmp_flag ~fnz
1ed4 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ed6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ed8 : 28              >            plp         ;restore status
                        
1ed9 : 88                       dey
1eda : c07f                     cpy #$7f
                                tst_stat ~fn
1edc : 08              >            php         ;save status
1edd : 68              >            pla         ;use stack to retrieve status
1ede : 48              >            pha
                       >            cmp_flag ~fn
1edf : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ee1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ee3 : 28              >            plp         ;restore status
                        
1ee4 : 88                       dey
1ee5 : c07f                     cpy #$7f
                                tst_y $7e,~fzc
1ee7 : 08              >            php         ;save flags
1ee8 : c07e            >            cpy #$7e     ;test result
                       >            trap_ne
1eea : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1eec : 68              >            pla         ;load status
1eed : 48              >            pha
                       >            cmp_flag ~fzc
1eee : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ef0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ef2 : 28              >            plp         ;restore status
                        
                                next_test
1ef3 : ad0002          >            lda test_case   ;previous test
1ef6 : c91b            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
1ef8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001c =                 >test_num = test_num + 1
1efa : a91c            >            lda #test_num   ;*** next tests' number
1efc : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; CMP - zp / abs / #         
                                set_a $80,0
                       >            load_flag 0
1eff : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f01 : 48              >            pha         ;use stack to load status
1f02 : a980            >            lda #$80     ;precharge accu
1f04 : 28              >            plp
                        
1f05 : c517                     cmp zp7f
                                tst_a $80,fc
1f07 : 08              >            php         ;save flags
1f08 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1f0a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f0c : 68              >            pla         ;load status
1f0d : 48              >            pha
                       >            cmp_flag fc
1f0e : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f10 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f12 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1f13 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f15 : 48              >            pha         ;use stack to load status
1f16 : a97f            >            lda #$7f     ;precharge accu
1f18 : 28              >            plp
                        
1f19 : c517                     cmp zp7f
                                tst_a $7f,fzc
1f1b : 08              >            php         ;save flags
1f1c : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1f1e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f20 : 68              >            pla         ;load status
1f21 : 48              >            pha
                       >            cmp_flag fzc
1f22 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f24 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f26 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1f27 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f29 : 48              >            pha         ;use stack to load status
1f2a : a97e            >            lda #$7e     ;precharge accu
1f2c : 28              >            plp
                        
1f2d : c517                     cmp zp7f
                                tst_a $7e,fn
1f2f : 08              >            php         ;save flags
1f30 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1f32 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f34 : 68              >            pla         ;load status
1f35 : 48              >            pha
                       >            cmp_flag fn
1f36 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f38 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f3a : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
1f3b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1f3d : 48              >            pha         ;use stack to load status
1f3e : a980            >            lda #$80     ;precharge accu
1f40 : 28              >            plp
                        
1f41 : c517                     cmp zp7f
                                tst_a $80,~fnz
1f43 : 08              >            php         ;save flags
1f44 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1f46 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f48 : 68              >            pla         ;load status
1f49 : 48              >            pha
                       >            cmp_flag ~fnz
1f4a : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f4c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f4e : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
1f4f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1f51 : 48              >            pha         ;use stack to load status
1f52 : a97f            >            lda #$7f     ;precharge accu
1f54 : 28              >            plp
                        
1f55 : c517                     cmp zp7f
                                tst_a $7f,~fn
1f57 : 08              >            php         ;save flags
1f58 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1f5a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f5c : 68              >            pla         ;load status
1f5d : 48              >            pha
                       >            cmp_flag ~fn
1f5e : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f60 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f62 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
1f63 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1f65 : 48              >            pha         ;use stack to load status
1f66 : a97e            >            lda #$7e     ;precharge accu
1f68 : 28              >            plp
                        
1f69 : c517                     cmp zp7f
                                tst_a $7e,~fzc
1f6b : 08              >            php         ;save flags
1f6c : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1f6e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f70 : 68              >            pla         ;load status
1f71 : 48              >            pha
                       >            cmp_flag ~fzc
1f72 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f74 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f76 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
1f77 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f79 : 48              >            pha         ;use stack to load status
1f7a : a980            >            lda #$80     ;precharge accu
1f7c : 28              >            plp
                        
1f7d : cd1b02                   cmp abs7f
                                tst_a $80,fc
1f80 : 08              >            php         ;save flags
1f81 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1f83 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f85 : 68              >            pla         ;load status
1f86 : 48              >            pha
                       >            cmp_flag fc
1f87 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f89 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f8b : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
1f8c : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1f8e : 48              >            pha         ;use stack to load status
1f8f : a97f            >            lda #$7f     ;precharge accu
1f91 : 28              >            plp
                        
1f92 : cd1b02                   cmp abs7f
                                tst_a $7f,fzc
1f95 : 08              >            php         ;save flags
1f96 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1f98 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1f9a : 68              >            pla         ;load status
1f9b : 48              >            pha
                       >            cmp_flag fzc
1f9c : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1f9e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fa0 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
1fa1 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1fa3 : 48              >            pha         ;use stack to load status
1fa4 : a97e            >            lda #$7e     ;precharge accu
1fa6 : 28              >            plp
                        
1fa7 : cd1b02                   cmp abs7f
                                tst_a $7e,fn
1faa : 08              >            php         ;save flags
1fab : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1fad : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1faf : 68              >            pla         ;load status
1fb0 : 48              >            pha
                       >            cmp_flag fn
1fb1 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fb3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fb5 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
1fb6 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1fb8 : 48              >            pha         ;use stack to load status
1fb9 : a980            >            lda #$80     ;precharge accu
1fbb : 28              >            plp
                        
1fbc : cd1b02                   cmp abs7f
                                tst_a $80,~fnz
1fbf : 08              >            php         ;save flags
1fc0 : c980            >            cmp #$80     ;test result
                       >            trap_ne
1fc2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fc4 : 68              >            pla         ;load status
1fc5 : 48              >            pha
                       >            cmp_flag ~fnz
1fc6 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fc8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fca : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
1fcb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1fcd : 48              >            pha         ;use stack to load status
1fce : a97f            >            lda #$7f     ;precharge accu
1fd0 : 28              >            plp
                        
1fd1 : cd1b02                   cmp abs7f
                                tst_a $7f,~fn
1fd4 : 08              >            php         ;save flags
1fd5 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
1fd7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fd9 : 68              >            pla         ;load status
1fda : 48              >            pha
                       >            cmp_flag ~fn
1fdb : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1fdd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fdf : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
1fe0 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
1fe2 : 48              >            pha         ;use stack to load status
1fe3 : a97e            >            lda #$7e     ;precharge accu
1fe5 : 28              >            plp
                        
1fe6 : cd1b02                   cmp abs7f
                                tst_a $7e,~fzc
1fe9 : 08              >            php         ;save flags
1fea : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
1fec : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1fee : 68              >            pla         ;load status
1fef : 48              >            pha
                       >            cmp_flag ~fzc
1ff0 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
1ff2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
1ff4 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
1ff5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
1ff7 : 48              >            pha         ;use stack to load status
1ff8 : a980            >            lda #$80     ;precharge accu
1ffa : 28              >            plp
                        
1ffb : c97f                     cmp #$7f
                                tst_a $80,fc
1ffd : 08              >            php         ;save flags
1ffe : c980            >            cmp #$80     ;test result
                       >            trap_ne
2000 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2002 : 68              >            pla         ;load status
2003 : 48              >            pha
                       >            cmp_flag fc
2004 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2006 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2008 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
2009 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
200b : 48              >            pha         ;use stack to load status
200c : a97f            >            lda #$7f     ;precharge accu
200e : 28              >            plp
                        
200f : c97f                     cmp #$7f
                                tst_a $7f,fzc
2011 : 08              >            php         ;save flags
2012 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2014 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2016 : 68              >            pla         ;load status
2017 : 48              >            pha
                       >            cmp_flag fzc
2018 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
201a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
201c : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
201d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
201f : 48              >            pha         ;use stack to load status
2020 : a97e            >            lda #$7e     ;precharge accu
2022 : 28              >            plp
                        
2023 : c97f                     cmp #$7f
                                tst_a $7e,fn
2025 : 08              >            php         ;save flags
2026 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2028 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
202a : 68              >            pla         ;load status
202b : 48              >            pha
                       >            cmp_flag fn
202c : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
202e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2030 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
2031 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2033 : 48              >            pha         ;use stack to load status
2034 : a980            >            lda #$80     ;precharge accu
2036 : 28              >            plp
                        
2037 : c97f                     cmp #$7f
                                tst_a $80,~fnz
2039 : 08              >            php         ;save flags
203a : c980            >            cmp #$80     ;test result
                       >            trap_ne
203c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
203e : 68              >            pla         ;load status
203f : 48              >            pha
                       >            cmp_flag ~fnz
2040 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2042 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2044 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
2045 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2047 : 48              >            pha         ;use stack to load status
2048 : a97f            >            lda #$7f     ;precharge accu
204a : 28              >            plp
                        
204b : c97f                     cmp #$7f
                                tst_a $7f,~fn
204d : 08              >            php         ;save flags
204e : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2050 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2052 : 68              >            pla         ;load status
2053 : 48              >            pha
                       >            cmp_flag ~fn
2054 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2056 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2058 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2059 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
205b : 48              >            pha         ;use stack to load status
205c : a97e            >            lda #$7e     ;precharge accu
205e : 28              >            plp
                        
205f : c97f                     cmp #$7f
                                tst_a $7e,~fzc
2061 : 08              >            php         ;save flags
2062 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2064 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2066 : 68              >            pla         ;load status
2067 : 48              >            pha
                       >            cmp_flag ~fzc
2068 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
206a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
206c : 28              >            plp         ;restore status
                        
                        
206d : a204                     ldx #4          ;with indexing by X
                                set_a $80,0
                       >            load_flag 0
206f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2071 : 48              >            pha         ;use stack to load status
2072 : a980            >            lda #$80     ;precharge accu
2074 : 28              >            plp
                        
2075 : d513                     cmp zp1,x
                                tst_a $80,fc
2077 : 08              >            php         ;save flags
2078 : c980            >            cmp #$80     ;test result
                       >            trap_ne
207a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
207c : 68              >            pla         ;load status
207d : 48              >            pha
                       >            cmp_flag fc
207e : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2080 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2082 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
2083 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2085 : 48              >            pha         ;use stack to load status
2086 : a97f            >            lda #$7f     ;precharge accu
2088 : 28              >            plp
                        
2089 : d513                     cmp zp1,x
                                tst_a $7f,fzc
208b : 08              >            php         ;save flags
208c : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
208e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2090 : 68              >            pla         ;load status
2091 : 48              >            pha
                       >            cmp_flag fzc
2092 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2094 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2096 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
2097 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2099 : 48              >            pha         ;use stack to load status
209a : a97e            >            lda #$7e     ;precharge accu
209c : 28              >            plp
                        
209d : d513                     cmp zp1,x
                                tst_a $7e,fn
209f : 08              >            php         ;save flags
20a0 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
20a2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20a4 : 68              >            pla         ;load status
20a5 : 48              >            pha
                       >            cmp_flag fn
20a6 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20a8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20aa : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
20ab : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
20ad : 48              >            pha         ;use stack to load status
20ae : a980            >            lda #$80     ;precharge accu
20b0 : 28              >            plp
                        
20b1 : d513                     cmp zp1,x
                                tst_a $80,~fnz
20b3 : 08              >            php         ;save flags
20b4 : c980            >            cmp #$80     ;test result
                       >            trap_ne
20b6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20b8 : 68              >            pla         ;load status
20b9 : 48              >            pha
                       >            cmp_flag ~fnz
20ba : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20bc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20be : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
20bf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
20c1 : 48              >            pha         ;use stack to load status
20c2 : a97f            >            lda #$7f     ;precharge accu
20c4 : 28              >            plp
                        
20c5 : d513                     cmp zp1,x
                                tst_a $7f,~fn
20c7 : 08              >            php         ;save flags
20c8 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
20ca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20cc : 68              >            pla         ;load status
20cd : 48              >            pha
                       >            cmp_flag ~fn
20ce : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20d0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20d2 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
20d3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
20d5 : 48              >            pha         ;use stack to load status
20d6 : a97e            >            lda #$7e     ;precharge accu
20d8 : 28              >            plp
                        
20d9 : d513                     cmp zp1,x
                                tst_a $7e,~fzc
20db : 08              >            php         ;save flags
20dc : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
20de : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20e0 : 68              >            pla         ;load status
20e1 : 48              >            pha
                       >            cmp_flag ~fzc
20e2 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20e4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20e6 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
20e7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
20e9 : 48              >            pha         ;use stack to load status
20ea : a980            >            lda #$80     ;precharge accu
20ec : 28              >            plp
                        
20ed : dd1702                   cmp abs1,x
                                tst_a $80,fc
20f0 : 08              >            php         ;save flags
20f1 : c980            >            cmp #$80     ;test result
                       >            trap_ne
20f3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20f5 : 68              >            pla         ;load status
20f6 : 48              >            pha
                       >            cmp_flag fc
20f7 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
20f9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
20fb : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
20fc : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
20fe : 48              >            pha         ;use stack to load status
20ff : a97f            >            lda #$7f     ;precharge accu
2101 : 28              >            plp
                        
2102 : dd1702                   cmp abs1,x
                                tst_a $7f,fzc
2105 : 08              >            php         ;save flags
2106 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2108 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
210a : 68              >            pla         ;load status
210b : 48              >            pha
                       >            cmp_flag fzc
210c : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
210e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2110 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
2111 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2113 : 48              >            pha         ;use stack to load status
2114 : a97e            >            lda #$7e     ;precharge accu
2116 : 28              >            plp
                        
2117 : dd1702                   cmp abs1,x
                                tst_a $7e,fn
211a : 08              >            php         ;save flags
211b : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
211d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
211f : 68              >            pla         ;load status
2120 : 48              >            pha
                       >            cmp_flag fn
2121 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2123 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2125 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
2126 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2128 : 48              >            pha         ;use stack to load status
2129 : a980            >            lda #$80     ;precharge accu
212b : 28              >            plp
                        
212c : dd1702                   cmp abs1,x
                                tst_a $80,~fnz
212f : 08              >            php         ;save flags
2130 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2132 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2134 : 68              >            pla         ;load status
2135 : 48              >            pha
                       >            cmp_flag ~fnz
2136 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2138 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
213a : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
213b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
213d : 48              >            pha         ;use stack to load status
213e : a97f            >            lda #$7f     ;precharge accu
2140 : 28              >            plp
                        
2141 : dd1702                   cmp abs1,x
                                tst_a $7f,~fn
2144 : 08              >            php         ;save flags
2145 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2147 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2149 : 68              >            pla         ;load status
214a : 48              >            pha
                       >            cmp_flag ~fn
214b : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
214d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
214f : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
2150 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2152 : 48              >            pha         ;use stack to load status
2153 : a97e            >            lda #$7e     ;precharge accu
2155 : 28              >            plp
                        
2156 : dd1702                   cmp abs1,x
                                tst_a $7e,~fzc
2159 : 08              >            php         ;save flags
215a : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
215c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
215e : 68              >            pla         ;load status
215f : 48              >            pha
                       >            cmp_flag ~fzc
2160 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2162 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2164 : 28              >            plp         ;restore status
                        
                        
2165 : a004                     ldy #4          ;with indexing by Y
2167 : a208                     ldx #8          ;with indexed indirect
                                set_a $80,0
                       >            load_flag 0
2169 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
216b : 48              >            pha         ;use stack to load status
216c : a980            >            lda #$80     ;precharge accu
216e : 28              >            plp
                        
216f : d91702                   cmp abs1,y
                                tst_a $80,fc
2172 : 08              >            php         ;save flags
2173 : c980            >            cmp #$80     ;test result
                       >            trap_ne
2175 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2177 : 68              >            pla         ;load status
2178 : 48              >            pha
                       >            cmp_flag fc
2179 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
217b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
217d : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
217e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2180 : 48              >            pha         ;use stack to load status
2181 : a97f            >            lda #$7f     ;precharge accu
2183 : 28              >            plp
                        
2184 : d91702                   cmp abs1,y
                                tst_a $7f,fzc
2187 : 08              >            php         ;save flags
2188 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
218a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
218c : 68              >            pla         ;load status
218d : 48              >            pha
                       >            cmp_flag fzc
218e : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2190 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2192 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
2193 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2195 : 48              >            pha         ;use stack to load status
2196 : a97e            >            lda #$7e     ;precharge accu
2198 : 28              >            plp
                        
2199 : d91702                   cmp abs1,y
                                tst_a $7e,fn
219c : 08              >            php         ;save flags
219d : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
219f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21a1 : 68              >            pla         ;load status
21a2 : 48              >            pha
                       >            cmp_flag fn
21a3 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21a5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21a7 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
21a8 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
21aa : 48              >            pha         ;use stack to load status
21ab : a980            >            lda #$80     ;precharge accu
21ad : 28              >            plp
                        
21ae : d91702                   cmp abs1,y
                                tst_a $80,~fnz
21b1 : 08              >            php         ;save flags
21b2 : c980            >            cmp #$80     ;test result
                       >            trap_ne
21b4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21b6 : 68              >            pla         ;load status
21b7 : 48              >            pha
                       >            cmp_flag ~fnz
21b8 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21ba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21bc : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
21bd : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
21bf : 48              >            pha         ;use stack to load status
21c0 : a97f            >            lda #$7f     ;precharge accu
21c2 : 28              >            plp
                        
21c3 : d91702                   cmp abs1,y
                                tst_a $7f,~fn
21c6 : 08              >            php         ;save flags
21c7 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
21c9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21cb : 68              >            pla         ;load status
21cc : 48              >            pha
                       >            cmp_flag ~fn
21cd : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21cf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21d1 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
21d2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
21d4 : 48              >            pha         ;use stack to load status
21d5 : a97e            >            lda #$7e     ;precharge accu
21d7 : 28              >            plp
                        
21d8 : d91702                   cmp abs1,y
                                tst_a $7e,~fzc
21db : 08              >            php         ;save flags
21dc : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
21de : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21e0 : 68              >            pla         ;load status
21e1 : 48              >            pha
                       >            cmp_flag ~fzc
21e2 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21e4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21e6 : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
21e7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
21e9 : 48              >            pha         ;use stack to load status
21ea : a980            >            lda #$80     ;precharge accu
21ec : 28              >            plp
                        
21ed : c124                     cmp (ind1,x)
                                tst_a $80,fc
21ef : 08              >            php         ;save flags
21f0 : c980            >            cmp #$80     ;test result
                       >            trap_ne
21f2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21f4 : 68              >            pla         ;load status
21f5 : 48              >            pha
                       >            cmp_flag fc
21f6 : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
21f8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
21fa : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
21fb : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
21fd : 48              >            pha         ;use stack to load status
21fe : a97f            >            lda #$7f     ;precharge accu
2200 : 28              >            plp
                        
2201 : c124                     cmp (ind1,x)
                                tst_a $7f,fzc
2203 : 08              >            php         ;save flags
2204 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2206 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2208 : 68              >            pla         ;load status
2209 : 48              >            pha
                       >            cmp_flag fzc
220a : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
220c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
220e : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
220f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2211 : 48              >            pha         ;use stack to load status
2212 : a97e            >            lda #$7e     ;precharge accu
2214 : 28              >            plp
                        
2215 : c124                     cmp (ind1,x)
                                tst_a $7e,fn
2217 : 08              >            php         ;save flags
2218 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
221a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
221c : 68              >            pla         ;load status
221d : 48              >            pha
                       >            cmp_flag fn
221e : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2220 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2222 : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
2223 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2225 : 48              >            pha         ;use stack to load status
2226 : a980            >            lda #$80     ;precharge accu
2228 : 28              >            plp
                        
2229 : c124                     cmp (ind1,x)
                                tst_a $80,~fnz
222b : 08              >            php         ;save flags
222c : c980            >            cmp #$80     ;test result
                       >            trap_ne
222e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2230 : 68              >            pla         ;load status
2231 : 48              >            pha
                       >            cmp_flag ~fnz
2232 : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2234 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2236 : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
2237 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2239 : 48              >            pha         ;use stack to load status
223a : a97f            >            lda #$7f     ;precharge accu
223c : 28              >            plp
                        
223d : c124                     cmp (ind1,x)
                                tst_a $7f,~fn
223f : 08              >            php         ;save flags
2240 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
2242 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2244 : 68              >            pla         ;load status
2245 : 48              >            pha
                       >            cmp_flag ~fn
2246 : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2248 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
224a : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
224b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
224d : 48              >            pha         ;use stack to load status
224e : a97e            >            lda #$7e     ;precharge accu
2250 : 28              >            plp
                        
2251 : c124                     cmp (ind1,x)
                                tst_a $7e,~fzc
2253 : 08              >            php         ;save flags
2254 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2256 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2258 : 68              >            pla         ;load status
2259 : 48              >            pha
                       >            cmp_flag ~fzc
225a : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
225c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
225e : 28              >            plp         ;restore status
                        
                        
                                set_a $80,0
                       >            load_flag 0
225f : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2261 : 48              >            pha         ;use stack to load status
2262 : a980            >            lda #$80     ;precharge accu
2264 : 28              >            plp
                        
2265 : d124                     cmp (ind1),y
                                tst_a $80,fc
2267 : 08              >            php         ;save flags
2268 : c980            >            cmp #$80     ;test result
                       >            trap_ne
226a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
226c : 68              >            pla         ;load status
226d : 48              >            pha
                       >            cmp_flag fc
226e : c931            >            cmp #(fc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2270 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2272 : 28              >            plp         ;restore status
                        
                                set_a $7f,0
                       >            load_flag 0
2273 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2275 : 48              >            pha         ;use stack to load status
2276 : a97f            >            lda #$7f     ;precharge accu
2278 : 28              >            plp
                        
2279 : d124                     cmp (ind1),y
                                tst_a $7f,fzc
227b : 08              >            php         ;save flags
227c : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
227e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2280 : 68              >            pla         ;load status
2281 : 48              >            pha
                       >            cmp_flag fzc
2282 : c933            >            cmp #(fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2284 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2286 : 28              >            plp         ;restore status
                        
                                set_a $7e,0
                       >            load_flag 0
2287 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2289 : 48              >            pha         ;use stack to load status
228a : a97e            >            lda #$7e     ;precharge accu
228c : 28              >            plp
                        
228d : d124                     cmp (ind1),y
                                tst_a $7e,fn
228f : 08              >            php         ;save flags
2290 : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
2292 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2294 : 68              >            pla         ;load status
2295 : 48              >            pha
                       >            cmp_flag fn
2296 : c9b0            >            cmp #(fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
2298 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
229a : 28              >            plp         ;restore status
                        
                                set_a $80,$ff
                       >            load_flag $ff
229b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
229d : 48              >            pha         ;use stack to load status
229e : a980            >            lda #$80     ;precharge accu
22a0 : 28              >            plp
                        
22a1 : d124                     cmp (ind1),y
                                tst_a $80,~fnz
22a3 : 08              >            php         ;save flags
22a4 : c980            >            cmp #$80     ;test result
                       >            trap_ne
22a6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22a8 : 68              >            pla         ;load status
22a9 : 48              >            pha
                       >            cmp_flag ~fnz
22aa : c97d            >            cmp #(~fnz|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
22ac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22ae : 28              >            plp         ;restore status
                        
                                set_a $7f,$ff
                       >            load_flag $ff
22af : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
22b1 : 48              >            pha         ;use stack to load status
22b2 : a97f            >            lda #$7f     ;precharge accu
22b4 : 28              >            plp
                        
22b5 : d124                     cmp (ind1),y
                                tst_a $7f,~fn
22b7 : 08              >            php         ;save flags
22b8 : c97f            >            cmp #$7f     ;test result
                       >            trap_ne
22ba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22bc : 68              >            pla         ;load status
22bd : 48              >            pha
                       >            cmp_flag ~fn
22be : c97f            >            cmp #(~fn|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
22c0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22c2 : 28              >            plp         ;restore status
                        
                                set_a $7e,$ff
                       >            load_flag $ff
22c3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
22c5 : 48              >            pha         ;use stack to load status
22c6 : a97e            >            lda #$7e     ;precharge accu
22c8 : 28              >            plp
                        
22c9 : d124                     cmp (ind1),y
                                tst_a $7e,~fzc
22cb : 08              >            php         ;save flags
22cc : c97e            >            cmp #$7e     ;test result
                       >            trap_ne
22ce : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22d0 : 68              >            pla         ;load status
22d1 : 48              >            pha
                       >            cmp_flag ~fzc
22d2 : c9fc            >            cmp #(~fzc|fao)&m8    ;expected flags + always on bits
                       >
                       >            trap_ne
22d4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22d6 : 28              >            plp         ;restore status
                        
                                next_test
22d7 : ad0002          >            lda test_case   ;previous test
22da : c91c            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
22dc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001d =                 >test_num = test_num + 1
22de : a91d            >            lda #test_num   ;*** next tests' number
22e0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing shifts - ASL LSR ROL ROR all addressing modes
                        ; shifts - accumulator
22e3 : a203                     ldx #3
22e5 :                  tasl
                                set_ax zp1,0
                       >            load_flag 0
22e5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
22e7 : 48              >            pha         ;use stack to load status
22e8 : b513            >            lda zp1,x    ;precharge accu
22ea : 28              >            plp
                        
22eb : 0a                       asl a
                                tst_ax rASL,fASL,0
22ec : 08              >            php         ;save flags
22ed : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
22f0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
22f2 : 68              >            pla         ;load status
                       >            eor_flag 0
22f3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
22f5 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne     ;
22f8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
22fa : ca                       dex
22fb : 10e8                     bpl tasl
22fd : a203                     ldx #3
22ff :                  tasl1
                                set_ax zp1,$ff
                       >            load_flag $ff
22ff : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2301 : 48              >            pha         ;use stack to load status
2302 : b513            >            lda zp1,x    ;precharge accu
2304 : 28              >            plp
                        
2305 : 0a                       asl a
                                tst_ax rASL,fASL,$ff-fnzc
2306 : 08              >            php         ;save flags
2307 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
230a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
230c : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
230d : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
230f : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne     ;
2312 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2314 : ca                       dex
2315 : 10e8                     bpl tasl1
                        
2317 : a203                     ldx #3
2319 :                  tlsr
                                set_ax zp1,0
                       >            load_flag 0
2319 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
231b : 48              >            pha         ;use stack to load status
231c : b513            >            lda zp1,x    ;precharge accu
231e : 28              >            plp
                        
231f : 4a                       lsr a
                                tst_ax rLSR,fLSR,0
2320 : 08              >            php         ;save flags
2321 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2324 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2326 : 68              >            pla         ;load status
                       >            eor_flag 0
2327 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2329 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne     ;
232c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
232e : ca                       dex
232f : 10e8                     bpl tlsr
2331 : a203                     ldx #3
2333 :                  tlsr1
                                set_ax zp1,$ff
                       >            load_flag $ff
2333 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2335 : 48              >            pha         ;use stack to load status
2336 : b513            >            lda zp1,x    ;precharge accu
2338 : 28              >            plp
                        
2339 : 4a                       lsr a
                                tst_ax rLSR,fLSR,$ff-fnzc
233a : 08              >            php         ;save flags
233b : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
233e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2340 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2341 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2343 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne     ;
2346 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2348 : ca                       dex
2349 : 10e8                     bpl tlsr1
                        
234b : a203                     ldx #3
234d :                  trol
                                set_ax zp1,0
                       >            load_flag 0
234d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
234f : 48              >            pha         ;use stack to load status
2350 : b513            >            lda zp1,x    ;precharge accu
2352 : 28              >            plp
                        
2353 : 2a                       rol a
                                tst_ax rROL,fROL,0
2354 : 08              >            php         ;save flags
2355 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2358 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
235a : 68              >            pla         ;load status
                       >            eor_flag 0
235b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
235d : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne     ;
2360 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2362 : ca                       dex
2363 : 10e8                     bpl trol
2365 : a203                     ldx #3
2367 :                  trol1
                                set_ax zp1,$ff-fc
                       >            load_flag $ff-fc
2367 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2369 : 48              >            pha         ;use stack to load status
236a : b513            >            lda zp1,x    ;precharge accu
236c : 28              >            plp
                        
236d : 2a                       rol a
                                tst_ax rROL,fROL,$ff-fnzc
236e : 08              >            php         ;save flags
236f : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2372 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2374 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2375 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2377 : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne     ;
237a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
237c : ca                       dex
237d : 10e8                     bpl trol1
                        
237f : a203                     ldx #3
2381 :                  trolc
                                set_ax zp1,fc
                       >            load_flag fc
2381 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2383 : 48              >            pha         ;use stack to load status
2384 : b513            >            lda zp1,x    ;precharge accu
2386 : 28              >            plp
                        
2387 : 2a                       rol a
                                tst_ax rROLc,fROLc,0
2388 : 08              >            php         ;save flags
2389 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
238c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
238e : 68              >            pla         ;load status
                       >            eor_flag 0
238f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2391 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne     ;
2394 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2396 : ca                       dex
2397 : 10e8                     bpl trolc
2399 : a203                     ldx #3
239b :                  trolc1
                                set_ax zp1,$ff
                       >            load_flag $ff
239b : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
239d : 48              >            pha         ;use stack to load status
239e : b513            >            lda zp1,x    ;precharge accu
23a0 : 28              >            plp
                        
23a1 : 2a                       rol a
                                tst_ax rROLc,fROLc,$ff-fnzc
23a2 : 08              >            php         ;save flags
23a3 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
23a6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23a8 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
23a9 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
23ab : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne     ;
23ae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
23b0 : ca                       dex
23b1 : 10e8                     bpl trolc1
                        
23b3 : a203                     ldx #3
23b5 :                  tror
                                set_ax zp1,0
                       >            load_flag 0
23b5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
23b7 : 48              >            pha         ;use stack to load status
23b8 : b513            >            lda zp1,x    ;precharge accu
23ba : 28              >            plp
                        
23bb : 6a                       ror a
                                tst_ax rROR,fROR,0
23bc : 08              >            php         ;save flags
23bd : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
23c0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23c2 : 68              >            pla         ;load status
                       >            eor_flag 0
23c3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
23c5 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne     ;
23c8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
23ca : ca                       dex
23cb : 10e8                     bpl tror
23cd : a203                     ldx #3
23cf :                  tror1
                                set_ax zp1,$ff-fc
                       >            load_flag $ff-fc
23cf : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
23d1 : 48              >            pha         ;use stack to load status
23d2 : b513            >            lda zp1,x    ;precharge accu
23d4 : 28              >            plp
                        
23d5 : 6a                       ror a
                                tst_ax rROR,fROR,$ff-fnzc
23d6 : 08              >            php         ;save flags
23d7 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
23da : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23dc : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
23dd : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
23df : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne     ;
23e2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
23e4 : ca                       dex
23e5 : 10e8                     bpl tror1
                        
23e7 : a203                     ldx #3
23e9 :                  trorc
                                set_ax zp1,fc
                       >            load_flag fc
23e9 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
23eb : 48              >            pha         ;use stack to load status
23ec : b513            >            lda zp1,x    ;precharge accu
23ee : 28              >            plp
                        
23ef : 6a                       ror a
                                tst_ax rRORc,fRORc,0
23f0 : 08              >            php         ;save flags
23f1 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
23f4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
23f6 : 68              >            pla         ;load status
                       >            eor_flag 0
23f7 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
23f9 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne     ;
23fc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
23fe : ca                       dex
23ff : 10e8                     bpl trorc
2401 : a203                     ldx #3
2403 :                  trorc1
                                set_ax zp1,$ff
                       >            load_flag $ff
2403 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2405 : 48              >            pha         ;use stack to load status
2406 : b513            >            lda zp1,x    ;precharge accu
2408 : 28              >            plp
                        
2409 : 6a                       ror a
                                tst_ax rRORc,fRORc,$ff-fnzc
240a : 08              >            php         ;save flags
240b : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
240e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2410 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2411 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2413 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne     ;
2416 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2418 : ca                       dex
2419 : 10e8                     bpl trorc1
                                next_test
241b : ad0002          >            lda test_case   ;previous test
241e : c91d            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2420 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001e =                 >test_num = test_num + 1
2422 : a91e            >            lda #test_num   ;*** next tests' number
2424 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - zeropage
2427 : a203                     ldx #3
2429 :                  tasl2
                                set_z zp1,0
                       >            load_flag 0
2429 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
242b : 48              >            pha         ;use stack to load status
242c : b513            >            lda zp1,x    ;load to zeropage
242e : 850c            >            sta zpt
2430 : 28              >            plp
                        
2431 : 060c                     asl zpt
                                tst_z rASL,fASL,0
2433 : 08              >            php         ;save flags
2434 : a50c            >            lda zpt
2436 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
2439 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
243b : 68              >            pla         ;load status
                       >            eor_flag 0
243c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
243e : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
2441 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2443 : ca                       dex
2444 : 10e3                     bpl tasl2
2446 : a203                     ldx #3
2448 :                  tasl3
                                set_z zp1,$ff
                       >            load_flag $ff
2448 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
244a : 48              >            pha         ;use stack to load status
244b : b513            >            lda zp1,x    ;load to zeropage
244d : 850c            >            sta zpt
244f : 28              >            plp
                        
2450 : 060c                     asl zpt
                                tst_z rASL,fASL,$ff-fnzc
2452 : 08              >            php         ;save flags
2453 : a50c            >            lda zpt
2455 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
2458 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
245a : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
245b : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
245d : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
2460 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2462 : ca                       dex
2463 : 10e3                     bpl tasl3
                        
2465 : a203                     ldx #3
2467 :                  tlsr2
                                set_z zp1,0
                       >            load_flag 0
2467 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2469 : 48              >            pha         ;use stack to load status
246a : b513            >            lda zp1,x    ;load to zeropage
246c : 850c            >            sta zpt
246e : 28              >            plp
                        
246f : 460c                     lsr zpt
                                tst_z rLSR,fLSR,0
2471 : 08              >            php         ;save flags
2472 : a50c            >            lda zpt
2474 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2477 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2479 : 68              >            pla         ;load status
                       >            eor_flag 0
247a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
247c : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
247f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2481 : ca                       dex
2482 : 10e3                     bpl tlsr2
2484 : a203                     ldx #3
2486 :                  tlsr3
                                set_z zp1,$ff
                       >            load_flag $ff
2486 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2488 : 48              >            pha         ;use stack to load status
2489 : b513            >            lda zp1,x    ;load to zeropage
248b : 850c            >            sta zpt
248d : 28              >            plp
                        
248e : 460c                     lsr zpt
                                tst_z rLSR,fLSR,$ff-fnzc
2490 : 08              >            php         ;save flags
2491 : a50c            >            lda zpt
2493 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2496 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2498 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2499 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
249b : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
249e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
24a0 : ca                       dex
24a1 : 10e3                     bpl tlsr3
                        
24a3 : a203                     ldx #3
24a5 :                  trol2
                                set_z zp1,0
                       >            load_flag 0
24a5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
24a7 : 48              >            pha         ;use stack to load status
24a8 : b513            >            lda zp1,x    ;load to zeropage
24aa : 850c            >            sta zpt
24ac : 28              >            plp
                        
24ad : 260c                     rol zpt
                                tst_z rROL,fROL,0
24af : 08              >            php         ;save flags
24b0 : a50c            >            lda zpt
24b2 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
24b5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24b7 : 68              >            pla         ;load status
                       >            eor_flag 0
24b8 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
24ba : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
24bd : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
24bf : ca                       dex
24c0 : 10e3                     bpl trol2
24c2 : a203                     ldx #3
24c4 :                  trol3
                                set_z zp1,$ff-fc
                       >            load_flag $ff-fc
24c4 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
24c6 : 48              >            pha         ;use stack to load status
24c7 : b513            >            lda zp1,x    ;load to zeropage
24c9 : 850c            >            sta zpt
24cb : 28              >            plp
                        
24cc : 260c                     rol zpt
                                tst_z rROL,fROL,$ff-fnzc
24ce : 08              >            php         ;save flags
24cf : a50c            >            lda zpt
24d1 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
24d4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24d6 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
24d7 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
24d9 : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
24dc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
24de : ca                       dex
24df : 10e3                     bpl trol3
                        
24e1 : a203                     ldx #3
24e3 :                  trolc2
                                set_z zp1,fc
                       >            load_flag fc
24e3 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
24e5 : 48              >            pha         ;use stack to load status
24e6 : b513            >            lda zp1,x    ;load to zeropage
24e8 : 850c            >            sta zpt
24ea : 28              >            plp
                        
24eb : 260c                     rol zpt
                                tst_z rROLc,fROLc,0
24ed : 08              >            php         ;save flags
24ee : a50c            >            lda zpt
24f0 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
24f3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
24f5 : 68              >            pla         ;load status
                       >            eor_flag 0
24f6 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
24f8 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
24fb : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
24fd : ca                       dex
24fe : 10e3                     bpl trolc2
2500 : a203                     ldx #3
2502 :                  trolc3
                                set_z zp1,$ff
                       >            load_flag $ff
2502 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2504 : 48              >            pha         ;use stack to load status
2505 : b513            >            lda zp1,x    ;load to zeropage
2507 : 850c            >            sta zpt
2509 : 28              >            plp
                        
250a : 260c                     rol zpt
                                tst_z rROLc,fROLc,$ff-fnzc
250c : 08              >            php         ;save flags
250d : a50c            >            lda zpt
250f : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
2512 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2514 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2515 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2517 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
251a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
251c : ca                       dex
251d : 10e3                     bpl trolc3
                        
251f : a203                     ldx #3
2521 :                  tror2
                                set_z zp1,0
                       >            load_flag 0
2521 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2523 : 48              >            pha         ;use stack to load status
2524 : b513            >            lda zp1,x    ;load to zeropage
2526 : 850c            >            sta zpt
2528 : 28              >            plp
                        
2529 : 660c                     ror zpt
                                tst_z rROR,fROR,0
252b : 08              >            php         ;save flags
252c : a50c            >            lda zpt
252e : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
2531 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2533 : 68              >            pla         ;load status
                       >            eor_flag 0
2534 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2536 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
2539 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
253b : ca                       dex
253c : 10e3                     bpl tror2
253e : a203                     ldx #3
2540 :                  tror3
                                set_z zp1,$ff-fc
                       >            load_flag $ff-fc
2540 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2542 : 48              >            pha         ;use stack to load status
2543 : b513            >            lda zp1,x    ;load to zeropage
2545 : 850c            >            sta zpt
2547 : 28              >            plp
                        
2548 : 660c                     ror zpt
                                tst_z rROR,fROR,$ff-fnzc
254a : 08              >            php         ;save flags
254b : a50c            >            lda zpt
254d : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
2550 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2552 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2553 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2555 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
2558 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
255a : ca                       dex
255b : 10e3                     bpl tror3
                        
255d : a203                     ldx #3
255f :                  trorc2
                                set_z zp1,fc
                       >            load_flag fc
255f : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2561 : 48              >            pha         ;use stack to load status
2562 : b513            >            lda zp1,x    ;load to zeropage
2564 : 850c            >            sta zpt
2566 : 28              >            plp
                        
2567 : 660c                     ror zpt
                                tst_z rRORc,fRORc,0
2569 : 08              >            php         ;save flags
256a : a50c            >            lda zpt
256c : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
256f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2571 : 68              >            pla         ;load status
                       >            eor_flag 0
2572 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2574 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2577 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2579 : ca                       dex
257a : 10e3                     bpl trorc2
257c : a203                     ldx #3
257e :                  trorc3
                                set_z zp1,$ff
                       >            load_flag $ff
257e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2580 : 48              >            pha         ;use stack to load status
2581 : b513            >            lda zp1,x    ;load to zeropage
2583 : 850c            >            sta zpt
2585 : 28              >            plp
                        
2586 : 660c                     ror zpt
                                tst_z rRORc,fRORc,$ff-fnzc
2588 : 08              >            php         ;save flags
2589 : a50c            >            lda zpt
258b : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
258e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2590 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2591 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2593 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2596 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2598 : ca                       dex
2599 : 10e3                     bpl trorc3
                                next_test
259b : ad0002          >            lda test_case   ;previous test
259e : c91e            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
25a0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
001f =                 >test_num = test_num + 1
25a2 : a91f            >            lda #test_num   ;*** next tests' number
25a4 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - absolute
25a7 : a203                     ldx #3
25a9 :                  tasl4
                                set_abs zp1,0
                       >            load_flag 0
25a9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
25ab : 48              >            pha         ;use stack to load status
25ac : b513            >            lda zp1,x    ;load to memory
25ae : 8d0302          >            sta abst
25b1 : 28              >            plp
                        
25b2 : 0e0302                   asl abst
                                tst_abs rASL,fASL,0
25b5 : 08              >            php         ;save flags
25b6 : ad0302          >            lda abst
25b9 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
25bc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25be : 68              >            pla         ;load status
                       >            eor_flag 0
25bf : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
25c1 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
25c4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
25c6 : ca                       dex
25c7 : 10e0                     bpl tasl4
25c9 : a203                     ldx #3
25cb :                  tasl5
                                set_abs zp1,$ff
                       >            load_flag $ff
25cb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
25cd : 48              >            pha         ;use stack to load status
25ce : b513            >            lda zp1,x    ;load to memory
25d0 : 8d0302          >            sta abst
25d3 : 28              >            plp
                        
25d4 : 0e0302                   asl abst
                                tst_abs rASL,fASL,$ff-fnzc
25d7 : 08              >            php         ;save flags
25d8 : ad0302          >            lda abst
25db : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
25de : d0fe            >        bne *           ;failed not equal (non zero)
                       >
25e0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
25e1 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
25e3 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
25e6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
25e8 : ca                       dex
25e9 : 10e0                     bpl tasl5
                        
25eb : a203                     ldx #3
25ed :                  tlsr4
                                set_abs zp1,0
                       >            load_flag 0
25ed : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
25ef : 48              >            pha         ;use stack to load status
25f0 : b513            >            lda zp1,x    ;load to memory
25f2 : 8d0302          >            sta abst
25f5 : 28              >            plp
                        
25f6 : 4e0302                   lsr abst
                                tst_abs rLSR,fLSR,0
25f9 : 08              >            php         ;save flags
25fa : ad0302          >            lda abst
25fd : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2600 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2602 : 68              >            pla         ;load status
                       >            eor_flag 0
2603 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2605 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
2608 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
260a : ca                       dex
260b : 10e0                     bpl tlsr4
260d : a203                     ldx #3
260f :                  tlsr5
                                set_abs zp1,$ff
                       >            load_flag $ff
260f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2611 : 48              >            pha         ;use stack to load status
2612 : b513            >            lda zp1,x    ;load to memory
2614 : 8d0302          >            sta abst
2617 : 28              >            plp
                        
2618 : 4e0302                   lsr abst
                                tst_abs rLSR,fLSR,$ff-fnzc
261b : 08              >            php         ;save flags
261c : ad0302          >            lda abst
261f : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2622 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2624 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2625 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2627 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
262a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
262c : ca                       dex
262d : 10e0                     bpl tlsr5
                        
262f : a203                     ldx #3
2631 :                  trol4
                                set_abs zp1,0
                       >            load_flag 0
2631 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2633 : 48              >            pha         ;use stack to load status
2634 : b513            >            lda zp1,x    ;load to memory
2636 : 8d0302          >            sta abst
2639 : 28              >            plp
                        
263a : 2e0302                   rol abst
                                tst_abs rROL,fROL,0
263d : 08              >            php         ;save flags
263e : ad0302          >            lda abst
2641 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2644 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2646 : 68              >            pla         ;load status
                       >            eor_flag 0
2647 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2649 : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
264c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
264e : ca                       dex
264f : 10e0                     bpl trol4
2651 : a203                     ldx #3
2653 :                  trol5
                                set_abs zp1,$ff-fc
                       >            load_flag $ff-fc
2653 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2655 : 48              >            pha         ;use stack to load status
2656 : b513            >            lda zp1,x    ;load to memory
2658 : 8d0302          >            sta abst
265b : 28              >            plp
                        
265c : 2e0302                   rol abst
                                tst_abs rROL,fROL,$ff-fnzc
265f : 08              >            php         ;save flags
2660 : ad0302          >            lda abst
2663 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2666 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2668 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2669 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
266b : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
266e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2670 : ca                       dex
2671 : 10e0                     bpl trol5
                        
2673 : a203                     ldx #3
2675 :                  trolc4
                                set_abs zp1,fc
                       >            load_flag fc
2675 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2677 : 48              >            pha         ;use stack to load status
2678 : b513            >            lda zp1,x    ;load to memory
267a : 8d0302          >            sta abst
267d : 28              >            plp
                        
267e : 2e0302                   rol abst
                                tst_abs rROLc,fROLc,0
2681 : 08              >            php         ;save flags
2682 : ad0302          >            lda abst
2685 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
2688 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
268a : 68              >            pla         ;load status
                       >            eor_flag 0
268b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
268d : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
2690 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2692 : ca                       dex
2693 : 10e0                     bpl trolc4
2695 : a203                     ldx #3
2697 :                  trolc5
                                set_abs zp1,$ff
                       >            load_flag $ff
2697 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2699 : 48              >            pha         ;use stack to load status
269a : b513            >            lda zp1,x    ;load to memory
269c : 8d0302          >            sta abst
269f : 28              >            plp
                        
26a0 : 2e0302                   rol abst
                                tst_abs rROLc,fROLc,$ff-fnzc
26a3 : 08              >            php         ;save flags
26a4 : ad0302          >            lda abst
26a7 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
26aa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
26ac : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
26ad : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
26af : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
26b2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
26b4 : ca                       dex
26b5 : 10e0                     bpl trolc5
                        
26b7 : a203                     ldx #3
26b9 :                  tror4
                                set_abs zp1,0
                       >            load_flag 0
26b9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
26bb : 48              >            pha         ;use stack to load status
26bc : b513            >            lda zp1,x    ;load to memory
26be : 8d0302          >            sta abst
26c1 : 28              >            plp
                        
26c2 : 6e0302                   ror abst
                                tst_abs rROR,fROR,0
26c5 : 08              >            php         ;save flags
26c6 : ad0302          >            lda abst
26c9 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
26cc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
26ce : 68              >            pla         ;load status
                       >            eor_flag 0
26cf : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
26d1 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
26d4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
26d6 : ca                       dex
26d7 : 10e0                     bpl tror4
26d9 : a203                     ldx #3
26db :                  tror5
                                set_abs zp1,$ff-fc
                       >            load_flag $ff-fc
26db : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
26dd : 48              >            pha         ;use stack to load status
26de : b513            >            lda zp1,x    ;load to memory
26e0 : 8d0302          >            sta abst
26e3 : 28              >            plp
                        
26e4 : 6e0302                   ror abst
                                tst_abs rROR,fROR,$ff-fnzc
26e7 : 08              >            php         ;save flags
26e8 : ad0302          >            lda abst
26eb : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
26ee : d0fe            >        bne *           ;failed not equal (non zero)
                       >
26f0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
26f1 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
26f3 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
26f6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
26f8 : ca                       dex
26f9 : 10e0                     bpl tror5
                        
26fb : a203                     ldx #3
26fd :                  trorc4
                                set_abs zp1,fc
                       >            load_flag fc
26fd : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
26ff : 48              >            pha         ;use stack to load status
2700 : b513            >            lda zp1,x    ;load to memory
2702 : 8d0302          >            sta abst
2705 : 28              >            plp
                        
2706 : 6e0302                   ror abst
                                tst_abs rRORc,fRORc,0
2709 : 08              >            php         ;save flags
270a : ad0302          >            lda abst
270d : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2710 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2712 : 68              >            pla         ;load status
                       >            eor_flag 0
2713 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2715 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2718 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
271a : ca                       dex
271b : 10e0                     bpl trorc4
271d : a203                     ldx #3
271f :                  trorc5
                                set_abs zp1,$ff
                       >            load_flag $ff
271f : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2721 : 48              >            pha         ;use stack to load status
2722 : b513            >            lda zp1,x    ;load to memory
2724 : 8d0302          >            sta abst
2727 : 28              >            plp
                        
2728 : 6e0302                   ror abst
                                tst_abs rRORc,fRORc,$ff-fnzc
272b : 08              >            php         ;save flags
272c : ad0302          >            lda abst
272f : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2732 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2734 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2735 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2737 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
273a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
273c : ca                       dex
273d : 10e0                     bpl trorc5
                                next_test
273f : ad0002          >            lda test_case   ;previous test
2742 : c91f            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2744 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0020 =                 >test_num = test_num + 1
2746 : a920            >            lda #test_num   ;*** next tests' number
2748 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; shifts - zp indexed
274b : a203                     ldx #3
274d :                  tasl6
                                set_zx zp1,0
                       >            load_flag 0
274d : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
274f : 48              >            pha         ;use stack to load status
2750 : b513            >            lda zp1,x    ;load to indexed zeropage
2752 : 950c            >            sta zpt,x
2754 : 28              >            plp
                        
2755 : 160c                     asl zpt,x
                                tst_zx rASL,fASL,0
2757 : 08              >            php         ;save flags
2758 : b50c            >            lda zpt,x
275a : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
275d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
275f : 68              >            pla         ;load status
                       >            eor_flag 0
2760 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2762 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
2765 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2767 : ca                       dex
2768 : 10e3                     bpl tasl6
276a : a203                     ldx #3
276c :                  tasl7
                                set_zx zp1,$ff
                       >            load_flag $ff
276c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
276e : 48              >            pha         ;use stack to load status
276f : b513            >            lda zp1,x    ;load to indexed zeropage
2771 : 950c            >            sta zpt,x
2773 : 28              >            plp
                        
2774 : 160c                     asl zpt,x
                                tst_zx rASL,fASL,$ff-fnzc
2776 : 08              >            php         ;save flags
2777 : b50c            >            lda zpt,x
2779 : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
277c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
277e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
277f : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2781 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
2784 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2786 : ca                       dex
2787 : 10e3                     bpl tasl7
                        
2789 : a203                     ldx #3
278b :                  tlsr6
                                set_zx zp1,0
                       >            load_flag 0
278b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
278d : 48              >            pha         ;use stack to load status
278e : b513            >            lda zp1,x    ;load to indexed zeropage
2790 : 950c            >            sta zpt,x
2792 : 28              >            plp
                        
2793 : 560c                     lsr zpt,x
                                tst_zx rLSR,fLSR,0
2795 : 08              >            php         ;save flags
2796 : b50c            >            lda zpt,x
2798 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
279b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
279d : 68              >            pla         ;load status
                       >            eor_flag 0
279e : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
27a0 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
27a3 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27a5 : ca                       dex
27a6 : 10e3                     bpl tlsr6
27a8 : a203                     ldx #3
27aa :                  tlsr7
                                set_zx zp1,$ff
                       >            load_flag $ff
27aa : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
27ac : 48              >            pha         ;use stack to load status
27ad : b513            >            lda zp1,x    ;load to indexed zeropage
27af : 950c            >            sta zpt,x
27b1 : 28              >            plp
                        
27b2 : 560c                     lsr zpt,x
                                tst_zx rLSR,fLSR,$ff-fnzc
27b4 : 08              >            php         ;save flags
27b5 : b50c            >            lda zpt,x
27b7 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
27ba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
27bc : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
27bd : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
27bf : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
27c2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27c4 : ca                       dex
27c5 : 10e3                     bpl tlsr7
                        
27c7 : a203                     ldx #3
27c9 :                  trol6
                                set_zx zp1,0
                       >            load_flag 0
27c9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
27cb : 48              >            pha         ;use stack to load status
27cc : b513            >            lda zp1,x    ;load to indexed zeropage
27ce : 950c            >            sta zpt,x
27d0 : 28              >            plp
                        
27d1 : 360c                     rol zpt,x
                                tst_zx rROL,fROL,0
27d3 : 08              >            php         ;save flags
27d4 : b50c            >            lda zpt,x
27d6 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
27d9 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
27db : 68              >            pla         ;load status
                       >            eor_flag 0
27dc : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
27de : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
27e1 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
27e3 : ca                       dex
27e4 : 10e3                     bpl trol6
27e6 : a203                     ldx #3
27e8 :                  trol7
                                set_zx zp1,$ff-fc
                       >            load_flag $ff-fc
27e8 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
27ea : 48              >            pha         ;use stack to load status
27eb : b513            >            lda zp1,x    ;load to indexed zeropage
27ed : 950c            >            sta zpt,x
27ef : 28              >            plp
                        
27f0 : 360c                     rol zpt,x
                                tst_zx rROL,fROL,$ff-fnzc
27f2 : 08              >            php         ;save flags
27f3 : b50c            >            lda zpt,x
27f5 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
27f8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
27fa : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
27fb : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
27fd : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
2800 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2802 : ca                       dex
2803 : 10e3                     bpl trol7
                        
2805 : a203                     ldx #3
2807 :                  trolc6
                                set_zx zp1,fc
                       >            load_flag fc
2807 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2809 : 48              >            pha         ;use stack to load status
280a : b513            >            lda zp1,x    ;load to indexed zeropage
280c : 950c            >            sta zpt,x
280e : 28              >            plp
                        
280f : 360c                     rol zpt,x
                                tst_zx rROLc,fROLc,0
2811 : 08              >            php         ;save flags
2812 : b50c            >            lda zpt,x
2814 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
2817 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2819 : 68              >            pla         ;load status
                       >            eor_flag 0
281a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
281c : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
281f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2821 : ca                       dex
2822 : 10e3                     bpl trolc6
2824 : a203                     ldx #3
2826 :                  trolc7
                                set_zx zp1,$ff
                       >            load_flag $ff
2826 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2828 : 48              >            pha         ;use stack to load status
2829 : b513            >            lda zp1,x    ;load to indexed zeropage
282b : 950c            >            sta zpt,x
282d : 28              >            plp
                        
282e : 360c                     rol zpt,x
                                tst_zx rROLc,fROLc,$ff-fnzc
2830 : 08              >            php         ;save flags
2831 : b50c            >            lda zpt,x
2833 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
2836 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2838 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2839 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
283b : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
283e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2840 : ca                       dex
2841 : 10e3                     bpl trolc7
                        
2843 : a203                     ldx #3
2845 :                  tror6
                                set_zx zp1,0
                       >            load_flag 0
2845 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2847 : 48              >            pha         ;use stack to load status
2848 : b513            >            lda zp1,x    ;load to indexed zeropage
284a : 950c            >            sta zpt,x
284c : 28              >            plp
                        
284d : 760c                     ror zpt,x
                                tst_zx rROR,fROR,0
284f : 08              >            php         ;save flags
2850 : b50c            >            lda zpt,x
2852 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
2855 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2857 : 68              >            pla         ;load status
                       >            eor_flag 0
2858 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
285a : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
285d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
285f : ca                       dex
2860 : 10e3                     bpl tror6
2862 : a203                     ldx #3
2864 :                  tror7
                                set_zx zp1,$ff-fc
                       >            load_flag $ff-fc
2864 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2866 : 48              >            pha         ;use stack to load status
2867 : b513            >            lda zp1,x    ;load to indexed zeropage
2869 : 950c            >            sta zpt,x
286b : 28              >            plp
                        
286c : 760c                     ror zpt,x
                                tst_zx rROR,fROR,$ff-fnzc
286e : 08              >            php         ;save flags
286f : b50c            >            lda zpt,x
2871 : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
2874 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2876 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2877 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2879 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
287c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
287e : ca                       dex
287f : 10e3                     bpl tror7
                        
2881 : a203                     ldx #3
2883 :                  trorc6
                                set_zx zp1,fc
                       >            load_flag fc
2883 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2885 : 48              >            pha         ;use stack to load status
2886 : b513            >            lda zp1,x    ;load to indexed zeropage
2888 : 950c            >            sta zpt,x
288a : 28              >            plp
                        
288b : 760c                     ror zpt,x
                                tst_zx rRORc,fRORc,0
288d : 08              >            php         ;save flags
288e : b50c            >            lda zpt,x
2890 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2893 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2895 : 68              >            pla         ;load status
                       >            eor_flag 0
2896 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2898 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
289b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
289d : ca                       dex
289e : 10e3                     bpl trorc6
28a0 : a203                     ldx #3
28a2 :                  trorc7
                                set_zx zp1,$ff
                       >            load_flag $ff
28a2 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
28a4 : 48              >            pha         ;use stack to load status
28a5 : b513            >            lda zp1,x    ;load to indexed zeropage
28a7 : 950c            >            sta zpt,x
28a9 : 28              >            plp
                        
28aa : 760c                     ror zpt,x
                                tst_zx rRORc,fRORc,$ff-fnzc
28ac : 08              >            php         ;save flags
28ad : b50c            >            lda zpt,x
28af : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
28b2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
28b4 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
28b5 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
28b7 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
28ba : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
28bc : ca                       dex
28bd : 10e3                     bpl trorc7
                                next_test
28bf : ad0002          >            lda test_case   ;previous test
28c2 : c920            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
28c4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0021 =                 >test_num = test_num + 1
28c6 : a921            >            lda #test_num   ;*** next tests' number
28c8 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                                
                        ; shifts - abs indexed
28cb : a203                     ldx #3
28cd :                  tasl8
                                set_absx zp1,0
                       >            load_flag 0
28cd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
28cf : 48              >            pha         ;use stack to load status
28d0 : b513            >            lda zp1,x    ;load to indexed memory
28d2 : 9d0302          >            sta abst,x
28d5 : 28              >            plp
                        
28d6 : 1e0302                   asl abst,x
                                tst_absx rASL,fASL,0
28d9 : 08              >            php         ;save flags
28da : bd0302          >            lda abst,x
28dd : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
28e0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
28e2 : 68              >            pla         ;load status
                       >            eor_flag 0
28e3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
28e5 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
28e8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
28ea : ca                       dex
28eb : 10e0                     bpl tasl8
28ed : a203                     ldx #3
28ef :                  tasl9
                                set_absx zp1,$ff
                       >            load_flag $ff
28ef : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
28f1 : 48              >            pha         ;use stack to load status
28f2 : b513            >            lda zp1,x    ;load to indexed memory
28f4 : 9d0302          >            sta abst,x
28f7 : 28              >            plp
                        
28f8 : 1e0302                   asl abst,x
                                tst_absx rASL,fASL,$ff-fnzc
28fb : 08              >            php         ;save flags
28fc : bd0302          >            lda abst,x
28ff : dd2002          >            cmp rASL,x    ;test result
                       >            trap_ne
2902 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2904 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2905 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2907 : dd3002          >            cmp fASL,x    ;test flags
                       >            trap_ne
290a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
290c : ca                       dex
290d : 10e0                     bpl tasl9
                        
290f : a203                     ldx #3
2911 :                  tlsr8
                                set_absx zp1,0
                       >            load_flag 0
2911 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2913 : 48              >            pha         ;use stack to load status
2914 : b513            >            lda zp1,x    ;load to indexed memory
2916 : 9d0302          >            sta abst,x
2919 : 28              >            plp
                        
291a : 5e0302                   lsr abst,x
                                tst_absx rLSR,fLSR,0
291d : 08              >            php         ;save flags
291e : bd0302          >            lda abst,x
2921 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2924 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2926 : 68              >            pla         ;load status
                       >            eor_flag 0
2927 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2929 : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
292c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
292e : ca                       dex
292f : 10e0                     bpl tlsr8
2931 : a203                     ldx #3
2933 :                  tlsr9
                                set_absx zp1,$ff
                       >            load_flag $ff
2933 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2935 : 48              >            pha         ;use stack to load status
2936 : b513            >            lda zp1,x    ;load to indexed memory
2938 : 9d0302          >            sta abst,x
293b : 28              >            plp
                        
293c : 5e0302                   lsr abst,x
                                tst_absx rLSR,fLSR,$ff-fnzc
293f : 08              >            php         ;save flags
2940 : bd0302          >            lda abst,x
2943 : dd2802          >            cmp rLSR,x    ;test result
                       >            trap_ne
2946 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2948 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2949 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
294b : dd3802          >            cmp fLSR,x    ;test flags
                       >            trap_ne
294e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2950 : ca                       dex
2951 : 10e0                     bpl tlsr9
                        
2953 : a203                     ldx #3
2955 :                  trol8
                                set_absx zp1,0
                       >            load_flag 0
2955 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2957 : 48              >            pha         ;use stack to load status
2958 : b513            >            lda zp1,x    ;load to indexed memory
295a : 9d0302          >            sta abst,x
295d : 28              >            plp
                        
295e : 3e0302                   rol abst,x
                                tst_absx rROL,fROL,0
2961 : 08              >            php         ;save flags
2962 : bd0302          >            lda abst,x
2965 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
2968 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
296a : 68              >            pla         ;load status
                       >            eor_flag 0
296b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
296d : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
2970 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2972 : ca                       dex
2973 : 10e0                     bpl trol8
2975 : a203                     ldx #3
2977 :                  trol9
                                set_absx zp1,$ff-fc
                       >            load_flag $ff-fc
2977 : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2979 : 48              >            pha         ;use stack to load status
297a : b513            >            lda zp1,x    ;load to indexed memory
297c : 9d0302          >            sta abst,x
297f : 28              >            plp
                        
2980 : 3e0302                   rol abst,x
                                tst_absx rROL,fROL,$ff-fnzc
2983 : 08              >            php         ;save flags
2984 : bd0302          >            lda abst,x
2987 : dd2002          >            cmp rROL,x    ;test result
                       >            trap_ne
298a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
298c : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
298d : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
298f : dd3002          >            cmp fROL,x    ;test flags
                       >            trap_ne
2992 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2994 : ca                       dex
2995 : 10e0                     bpl trol9
                        
2997 : a203                     ldx #3
2999 :                  trolc8
                                set_absx zp1,fc
                       >            load_flag fc
2999 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
299b : 48              >            pha         ;use stack to load status
299c : b513            >            lda zp1,x    ;load to indexed memory
299e : 9d0302          >            sta abst,x
29a1 : 28              >            plp
                        
29a2 : 3e0302                   rol abst,x
                                tst_absx rROLc,fROLc,0
29a5 : 08              >            php         ;save flags
29a6 : bd0302          >            lda abst,x
29a9 : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
29ac : d0fe            >        bne *           ;failed not equal (non zero)
                       >
29ae : 68              >            pla         ;load status
                       >            eor_flag 0
29af : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
29b1 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
29b4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
29b6 : ca                       dex
29b7 : 10e0                     bpl trolc8
29b9 : a203                     ldx #3
29bb :                  trolc9
                                set_absx zp1,$ff
                       >            load_flag $ff
29bb : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
29bd : 48              >            pha         ;use stack to load status
29be : b513            >            lda zp1,x    ;load to indexed memory
29c0 : 9d0302          >            sta abst,x
29c3 : 28              >            plp
                        
29c4 : 3e0302                   rol abst,x
                                tst_absx rROLc,fROLc,$ff-fnzc
29c7 : 08              >            php         ;save flags
29c8 : bd0302          >            lda abst,x
29cb : dd2402          >            cmp rROLc,x    ;test result
                       >            trap_ne
29ce : d0fe            >        bne *           ;failed not equal (non zero)
                       >
29d0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
29d1 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
29d3 : dd3402          >            cmp fROLc,x    ;test flags
                       >            trap_ne
29d6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
29d8 : ca                       dex
29d9 : 10e0                     bpl trolc9
                        
29db : a203                     ldx #3
29dd :                  tror8
                                set_absx zp1,0
                       >            load_flag 0
29dd : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
29df : 48              >            pha         ;use stack to load status
29e0 : b513            >            lda zp1,x    ;load to indexed memory
29e2 : 9d0302          >            sta abst,x
29e5 : 28              >            plp
                        
29e6 : 7e0302                   ror abst,x
                                tst_absx rROR,fROR,0
29e9 : 08              >            php         ;save flags
29ea : bd0302          >            lda abst,x
29ed : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
29f0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
29f2 : 68              >            pla         ;load status
                       >            eor_flag 0
29f3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
29f5 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
29f8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
29fa : ca                       dex
29fb : 10e0                     bpl tror8
29fd : a203                     ldx #3
29ff :                  tror9
                                set_absx zp1,$ff-fc
                       >            load_flag $ff-fc
29ff : a9fe            >            lda #$ff-fc             ;allow test to change I-flag (no mask)
                       >
2a01 : 48              >            pha         ;use stack to load status
2a02 : b513            >            lda zp1,x    ;load to indexed memory
2a04 : 9d0302          >            sta abst,x
2a07 : 28              >            plp
                        
2a08 : 7e0302                   ror abst,x
                                tst_absx rROR,fROR,$ff-fnzc
2a0b : 08              >            php         ;save flags
2a0c : bd0302          >            lda abst,x
2a0f : dd2802          >            cmp rROR,x    ;test result
                       >            trap_ne
2a12 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a14 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2a15 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2a17 : dd3802          >            cmp fROR,x    ;test flags
                       >            trap_ne
2a1a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a1c : ca                       dex
2a1d : 10e0                     bpl tror9
                        
2a1f : a203                     ldx #3
2a21 :                  trorc8
                                set_absx zp1,fc
                       >            load_flag fc
2a21 : a901            >            lda #fc             ;allow test to change I-flag (no mask)
                       >
2a23 : 48              >            pha         ;use stack to load status
2a24 : b513            >            lda zp1,x    ;load to indexed memory
2a26 : 9d0302          >            sta abst,x
2a29 : 28              >            plp
                        
2a2a : 7e0302                   ror abst,x
                                tst_absx rRORc,fRORc,0
2a2d : 08              >            php         ;save flags
2a2e : bd0302          >            lda abst,x
2a31 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2a34 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a36 : 68              >            pla         ;load status
                       >            eor_flag 0
2a37 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2a39 : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2a3c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a3e : ca                       dex
2a3f : 10e0                     bpl trorc8
2a41 : a203                     ldx #3
2a43 :                  trorc9
                                set_absx zp1,$ff
                       >            load_flag $ff
2a43 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2a45 : 48              >            pha         ;use stack to load status
2a46 : b513            >            lda zp1,x    ;load to indexed memory
2a48 : 9d0302          >            sta abst,x
2a4b : 28              >            plp
                        
2a4c : 7e0302                   ror abst,x
                                tst_absx rRORc,fRORc,$ff-fnzc
2a4f : 08              >            php         ;save flags
2a50 : bd0302          >            lda abst,x
2a53 : dd2c02          >            cmp rRORc,x    ;test result
                       >            trap_ne
2a56 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a58 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnzc
2a59 : 497c            >            eor #$ff-fnzc|fao         ;invert expected flags + always on bits
                       >
2a5b : dd3c02          >            cmp fRORc,x    ;test flags
                       >            trap_ne
2a5e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a60 : ca                       dex
2a61 : 10e0                     bpl trorc9
                                next_test
2a63 : ad0002          >            lda test_case   ;previous test
2a66 : c921            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2a68 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0022 =                 >test_num = test_num + 1
2a6a : a922            >            lda #test_num   ;*** next tests' number
2a6c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing memory increment/decrement - INC DEC all addressing modes
                        ; zeropage
2a6f : a200                     ldx #0
2a71 : a97e                     lda #$7e
2a73 : 850c                     sta zpt
2a75 :                  tinc    
                                set_stat 0
                       >            load_flag 0
2a75 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2a77 : 48              >            pha         ;use stack to load status
2a78 : 28              >            plp
                        
2a79 : e60c                     inc zpt
                                tst_z rINC,fINC,0
2a7b : 08              >            php         ;save flags
2a7c : a50c            >            lda zpt
2a7e : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2a81 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2a83 : 68              >            pla         ;load status
                       >            eor_flag 0
2a84 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2a86 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2a89 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2a8b : e8                       inx
2a8c : e002                     cpx #2
2a8e : d004                     bne tinc1
2a90 : a9fe                     lda #$fe
2a92 : 850c                     sta zpt
2a94 : e005             tinc1   cpx #5
2a96 : d0dd                     bne tinc
2a98 : ca                       dex
2a99 : e60c                     inc zpt
2a9b :                  tdec    
                                set_stat 0
                       >            load_flag 0
2a9b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2a9d : 48              >            pha         ;use stack to load status
2a9e : 28              >            plp
                        
2a9f : c60c                     dec zpt
                                tst_z rINC,fINC,0
2aa1 : 08              >            php         ;save flags
2aa2 : a50c            >            lda zpt
2aa4 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2aa7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2aa9 : 68              >            pla         ;load status
                       >            eor_flag 0
2aaa : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2aac : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2aaf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ab1 : ca                       dex
2ab2 : 300a                     bmi tdec1
2ab4 : e001                     cpx #1
2ab6 : d0e3                     bne tdec
2ab8 : a981                     lda #$81
2aba : 850c                     sta zpt
2abc : d0dd                     bne tdec
2abe :                  tdec1
2abe : a200                     ldx #0
2ac0 : a97e                     lda #$7e
2ac2 : 850c                     sta zpt
2ac4 :                  tinc10    
                                set_stat $ff
                       >            load_flag $ff
2ac4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2ac6 : 48              >            pha         ;use stack to load status
2ac7 : 28              >            plp
                        
2ac8 : e60c                     inc zpt
                                tst_z rINC,fINC,$ff-fnz
2aca : 08              >            php         ;save flags
2acb : a50c            >            lda zpt
2acd : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2ad0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ad2 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2ad3 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2ad5 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2ad8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ada : e8                       inx
2adb : e002                     cpx #2
2add : d004                     bne tinc11
2adf : a9fe                     lda #$fe
2ae1 : 850c                     sta zpt
2ae3 : e005             tinc11  cpx #5
2ae5 : d0dd                     bne tinc10
2ae7 : ca                       dex
2ae8 : e60c                     inc zpt
2aea :                  tdec10    
                                set_stat $ff
                       >            load_flag $ff
2aea : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2aec : 48              >            pha         ;use stack to load status
2aed : 28              >            plp
                        
2aee : c60c                     dec zpt
                                tst_z rINC,fINC,$ff-fnz
2af0 : 08              >            php         ;save flags
2af1 : a50c            >            lda zpt
2af3 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2af6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2af8 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2af9 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2afb : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2afe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b00 : ca                       dex
2b01 : 300a                     bmi tdec11
2b03 : e001                     cpx #1
2b05 : d0e3                     bne tdec10
2b07 : a981                     lda #$81
2b09 : 850c                     sta zpt
2b0b : d0dd                     bne tdec10
2b0d :                  tdec11
                                next_test
2b0d : ad0002          >            lda test_case   ;previous test
2b10 : c922            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2b12 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0023 =                 >test_num = test_num + 1
2b14 : a923            >            lda #test_num   ;*** next tests' number
2b16 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; absolute memory
2b19 : a200                     ldx #0
2b1b : a97e                     lda #$7e
2b1d : 8d0302                   sta abst
2b20 :                  tinc2    
                                set_stat 0
                       >            load_flag 0
2b20 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2b22 : 48              >            pha         ;use stack to load status
2b23 : 28              >            plp
                        
2b24 : ee0302                   inc abst
                                tst_abs rINC,fINC,0
2b27 : 08              >            php         ;save flags
2b28 : ad0302          >            lda abst
2b2b : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2b2e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b30 : 68              >            pla         ;load status
                       >            eor_flag 0
2b31 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2b33 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b36 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b38 : e8                       inx
2b39 : e002                     cpx #2
2b3b : d005                     bne tinc3
2b3d : a9fe                     lda #$fe
2b3f : 8d0302                   sta abst
2b42 : e005             tinc3   cpx #5
2b44 : d0da                     bne tinc2
2b46 : ca                       dex
2b47 : ee0302                   inc abst
2b4a :                  tdec2    
                                set_stat 0
                       >            load_flag 0
2b4a : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2b4c : 48              >            pha         ;use stack to load status
2b4d : 28              >            plp
                        
2b4e : ce0302                   dec abst
                                tst_abs rINC,fINC,0
2b51 : 08              >            php         ;save flags
2b52 : ad0302          >            lda abst
2b55 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2b58 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b5a : 68              >            pla         ;load status
                       >            eor_flag 0
2b5b : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2b5d : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b60 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b62 : ca                       dex
2b63 : 300b                     bmi tdec3
2b65 : e001                     cpx #1
2b67 : d0e1                     bne tdec2
2b69 : a981                     lda #$81
2b6b : 8d0302                   sta abst
2b6e : d0da                     bne tdec2
2b70 :                  tdec3
2b70 : a200                     ldx #0
2b72 : a97e                     lda #$7e
2b74 : 8d0302                   sta abst
2b77 :                  tinc12    
                                set_stat $ff
                       >            load_flag $ff
2b77 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2b79 : 48              >            pha         ;use stack to load status
2b7a : 28              >            plp
                        
2b7b : ee0302                   inc abst
                                tst_abs rINC,fINC,$ff-fnz
2b7e : 08              >            php         ;save flags
2b7f : ad0302          >            lda abst
2b82 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2b85 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2b87 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2b88 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2b8a : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2b8d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2b8f : e8                       inx
2b90 : e002                     cpx #2
2b92 : d005                     bne tinc13
2b94 : a9fe                     lda #$fe
2b96 : 8d0302                   sta abst
2b99 : e005             tinc13   cpx #5
2b9b : d0da                     bne tinc12
2b9d : ca                       dex
2b9e : ee0302                   inc abst
2ba1 :                  tdec12    
                                set_stat $ff
                       >            load_flag $ff
2ba1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2ba3 : 48              >            pha         ;use stack to load status
2ba4 : 28              >            plp
                        
2ba5 : ce0302                   dec abst
                                tst_abs rINC,fINC,$ff-fnz
2ba8 : 08              >            php         ;save flags
2ba9 : ad0302          >            lda abst
2bac : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2baf : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2bb1 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2bb2 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2bb4 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2bb7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2bb9 : ca                       dex
2bba : 300b                     bmi tdec13
2bbc : e001                     cpx #1
2bbe : d0e1                     bne tdec12
2bc0 : a981                     lda #$81
2bc2 : 8d0302                   sta abst
2bc5 : d0da                     bne tdec12
2bc7 :                  tdec13
                                next_test
2bc7 : ad0002          >            lda test_case   ;previous test
2bca : c923            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2bcc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0024 =                 >test_num = test_num + 1
2bce : a924            >            lda #test_num   ;*** next tests' number
2bd0 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; zeropage indexed
2bd3 : a200                     ldx #0
2bd5 : a97e                     lda #$7e
2bd7 : 950c             tinc4   sta zpt,x
                                set_stat 0
                       >            load_flag 0
2bd9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2bdb : 48              >            pha         ;use stack to load status
2bdc : 28              >            plp
                        
2bdd : f60c                     inc zpt,x
                                tst_zx rINC,fINC,0
2bdf : 08              >            php         ;save flags
2be0 : b50c            >            lda zpt,x
2be2 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2be5 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2be7 : 68              >            pla         ;load status
                       >            eor_flag 0
2be8 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2bea : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2bed : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2bef : b50c                     lda zpt,x
2bf1 : e8                       inx
2bf2 : e002                     cpx #2
2bf4 : d002                     bne tinc5
2bf6 : a9fe                     lda #$fe
2bf8 : e005             tinc5   cpx #5
2bfa : d0db                     bne tinc4
2bfc : ca                       dex
2bfd : a902                     lda #2
2bff : 950c             tdec4   sta zpt,x 
                                set_stat 0
                       >            load_flag 0
2c01 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2c03 : 48              >            pha         ;use stack to load status
2c04 : 28              >            plp
                        
2c05 : d60c                     dec zpt,x
                                tst_zx rINC,fINC,0
2c07 : 08              >            php         ;save flags
2c08 : b50c            >            lda zpt,x
2c0a : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2c0d : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c0f : 68              >            pla         ;load status
                       >            eor_flag 0
2c10 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2c12 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2c15 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c17 : b50c                     lda zpt,x
2c19 : ca                       dex
2c1a : 3008                     bmi tdec5
2c1c : e001                     cpx #1
2c1e : d0df                     bne tdec4
2c20 : a981                     lda #$81
2c22 : d0db                     bne tdec4
2c24 :                  tdec5
2c24 : a200                     ldx #0
2c26 : a97e                     lda #$7e
2c28 : 950c             tinc14  sta zpt,x
                                set_stat $ff
                       >            load_flag $ff
2c2a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2c2c : 48              >            pha         ;use stack to load status
2c2d : 28              >            plp
                        
2c2e : f60c                     inc zpt,x
                                tst_zx rINC,fINC,$ff-fnz
2c30 : 08              >            php         ;save flags
2c31 : b50c            >            lda zpt,x
2c33 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2c36 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c38 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2c39 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2c3b : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2c3e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c40 : b50c                     lda zpt,x
2c42 : e8                       inx
2c43 : e002                     cpx #2
2c45 : d002                     bne tinc15
2c47 : a9fe                     lda #$fe
2c49 : e005             tinc15  cpx #5
2c4b : d0db                     bne tinc14
2c4d : ca                       dex
2c4e : a902                     lda #2
2c50 : 950c             tdec14  sta zpt,x 
                                set_stat $ff
                       >            load_flag $ff
2c52 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2c54 : 48              >            pha         ;use stack to load status
2c55 : 28              >            plp
                        
2c56 : d60c                     dec zpt,x
                                tst_zx rINC,fINC,$ff-fnz
2c58 : 08              >            php         ;save flags
2c59 : b50c            >            lda zpt,x
2c5b : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2c5e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c60 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2c61 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2c63 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2c66 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2c68 : b50c                     lda zpt,x
2c6a : ca                       dex
2c6b : 3008                     bmi tdec15
2c6d : e001                     cpx #1
2c6f : d0df                     bne tdec14
2c71 : a981                     lda #$81
2c73 : d0db                     bne tdec14
2c75 :                  tdec15
                                next_test
2c75 : ad0002          >            lda test_case   ;previous test
2c78 : c924            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2c7a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0025 =                 >test_num = test_num + 1
2c7c : a925            >            lda #test_num   ;*** next tests' number
2c7e : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; memory indexed
2c81 : a200                     ldx #0
2c83 : a97e                     lda #$7e
2c85 : 9d0302           tinc6   sta abst,x
                                set_stat 0
                       >            load_flag 0
2c88 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2c8a : 48              >            pha         ;use stack to load status
2c8b : 28              >            plp
                        
2c8c : fe0302                   inc abst,x
                                tst_absx rINC,fINC,0
2c8f : 08              >            php         ;save flags
2c90 : bd0302          >            lda abst,x
2c93 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2c96 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2c98 : 68              >            pla         ;load status
                       >            eor_flag 0
2c99 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2c9b : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2c9e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ca0 : bd0302                   lda abst,x
2ca3 : e8                       inx
2ca4 : e002                     cpx #2
2ca6 : d002                     bne tinc7
2ca8 : a9fe                     lda #$fe
2caa : e005             tinc7   cpx #5
2cac : d0d7                     bne tinc6
2cae : ca                       dex
2caf : a902                     lda #2
2cb1 : 9d0302           tdec6   sta abst,x 
                                set_stat 0
                       >            load_flag 0
2cb4 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2cb6 : 48              >            pha         ;use stack to load status
2cb7 : 28              >            plp
                        
2cb8 : de0302                   dec abst,x
                                tst_absx rINC,fINC,0
2cbb : 08              >            php         ;save flags
2cbc : bd0302          >            lda abst,x
2cbf : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2cc2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2cc4 : 68              >            pla         ;load status
                       >            eor_flag 0
2cc5 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2cc7 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2cca : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ccc : bd0302                   lda abst,x
2ccf : ca                       dex
2cd0 : 3008                     bmi tdec7
2cd2 : e001                     cpx #1
2cd4 : d0db                     bne tdec6
2cd6 : a981                     lda #$81
2cd8 : d0d7                     bne tdec6
2cda :                  tdec7
2cda : a200                     ldx #0
2cdc : a97e                     lda #$7e
2cde : 9d0302           tinc16  sta abst,x
                                set_stat $ff
                       >            load_flag $ff
2ce1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2ce3 : 48              >            pha         ;use stack to load status
2ce4 : 28              >            plp
                        
2ce5 : fe0302                   inc abst,x
                                tst_absx rINC,fINC,$ff-fnz
2ce8 : 08              >            php         ;save flags
2ce9 : bd0302          >            lda abst,x
2cec : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2cef : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2cf1 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2cf2 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2cf4 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2cf7 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2cf9 : bd0302                   lda abst,x
2cfc : e8                       inx
2cfd : e002                     cpx #2
2cff : d002                     bne tinc17
2d01 : a9fe                     lda #$fe
2d03 : e005             tinc17  cpx #5
2d05 : d0d7                     bne tinc16
2d07 : ca                       dex
2d08 : a902                     lda #2
2d0a : 9d0302           tdec16  sta abst,x 
                                set_stat $ff
                       >            load_flag $ff
2d0d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2d0f : 48              >            pha         ;use stack to load status
2d10 : 28              >            plp
                        
2d11 : de0302                   dec abst,x
                                tst_absx rINC,fINC,$ff-fnz
2d14 : 08              >            php         ;save flags
2d15 : bd0302          >            lda abst,x
2d18 : dd4002          >            cmp rINC,x    ;test result
                       >            trap_ne
2d1b : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d1d : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2d1e : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2d20 : dd4502          >            cmp fINC,x    ;test flags
                       >            trap_ne
2d23 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d25 : bd0302                   lda abst,x
2d28 : ca                       dex
2d29 : 3008                     bmi tdec17
2d2b : e001                     cpx #1
2d2d : d0db                     bne tdec16
2d2f : a981                     lda #$81
2d31 : d0d7                     bne tdec16
2d33 :                  tdec17
                                next_test
2d33 : ad0002          >            lda test_case   ;previous test
2d36 : c925            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2d38 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0026 =                 >test_num = test_num + 1
2d3a : a926            >            lda #test_num   ;*** next tests' number
2d3c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; testing logical instructions - AND EOR ORA all addressing modes
                        ; AND
2d3f : a203                     ldx #3          ;immediate
2d41 : b51c             tand    lda zpAN,x
2d43 : 8d0902                   sta ex_andi+1   ;set AND # operand
                                set_ax  absANa,0
                       >            load_flag 0
2d46 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2d48 : 48              >            pha         ;use stack to load status
2d49 : bd5a02          >            lda absANa,x    ;precharge accu
2d4c : 28              >            plp
                        
2d4d : 200802                   jsr ex_andi     ;execute AND # in RAM
                                tst_ax  absrlo,absflo,0
2d50 : 08              >            php         ;save flags
2d51 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d54 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d56 : 68              >            pla         ;load status
                       >            eor_flag 0
2d57 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2d59 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d5c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d5e : ca                       dex
2d5f : 10e0                     bpl tand
2d61 : a203                     ldx #3
2d63 : b51c             tand1   lda zpAN,x
2d65 : 8d0902                   sta ex_andi+1   ;set AND # operand
                                set_ax  absANa,$ff
                       >            load_flag $ff
2d68 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2d6a : 48              >            pha         ;use stack to load status
2d6b : bd5a02          >            lda absANa,x    ;precharge accu
2d6e : 28              >            plp
                        
2d6f : 200802                   jsr ex_andi     ;execute AND # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
2d72 : 08              >            php         ;save flags
2d73 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d76 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d78 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2d79 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2d7b : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d7e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2d80 : ca                       dex
2d81 : 10e0                     bpl tand1
                            
2d83 : a203                     ldx #3      ;zp
2d85 : b51c             tand2   lda zpAN,x
2d87 : 850c                     sta zpt
                                set_ax  absANa,0
                       >            load_flag 0
2d89 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2d8b : 48              >            pha         ;use stack to load status
2d8c : bd5a02          >            lda absANa,x    ;precharge accu
2d8f : 28              >            plp
                        
2d90 : 250c                     and zpt
                                tst_ax  absrlo,absflo,0
2d92 : 08              >            php         ;save flags
2d93 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2d96 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2d98 : 68              >            pla         ;load status
                       >            eor_flag 0
2d99 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2d9b : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2d9e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2da0 : ca                       dex
2da1 : 10e2                     bpl tand2
2da3 : a203                     ldx #3
2da5 : b51c             tand3   lda zpAN,x
2da7 : 850c                     sta zpt
                                set_ax  absANa,$ff
                       >            load_flag $ff
2da9 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2dab : 48              >            pha         ;use stack to load status
2dac : bd5a02          >            lda absANa,x    ;precharge accu
2daf : 28              >            plp
                        
2db0 : 250c                     and zpt
                                tst_ax  absrlo,absflo,$ff-fnz
2db2 : 08              >            php         ;save flags
2db3 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2db6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2db8 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2db9 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2dbb : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2dbe : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2dc0 : ca                       dex
2dc1 : 10e2                     bpl tand3
                        
2dc3 : a203                     ldx #3      ;abs
2dc5 : b51c             tand4   lda zpAN,x
2dc7 : 8d0302                   sta abst
                                set_ax  absANa,0
                       >            load_flag 0
2dca : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2dcc : 48              >            pha         ;use stack to load status
2dcd : bd5a02          >            lda absANa,x    ;precharge accu
2dd0 : 28              >            plp
                        
2dd1 : 2d0302                   and abst
                                tst_ax  absrlo,absflo,0
2dd4 : 08              >            php         ;save flags
2dd5 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2dd8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2dda : 68              >            pla         ;load status
                       >            eor_flag 0
2ddb : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2ddd : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2de0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2de2 : ca                       dex
2de3 : 10e0                     bpl tand4
2de5 : a203                     ldx #3
2de7 : b51c             tand5   lda zpAN,x
2de9 : 8d0302                   sta abst
                                set_ax  absANa,$ff
                       >            load_flag $ff
2dec : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2dee : 48              >            pha         ;use stack to load status
2def : bd5a02          >            lda absANa,x    ;precharge accu
2df2 : 28              >            plp
                        
2df3 : 2d0302                   and abst
                                tst_ax  absrlo,absflo,$ff-fnz
2df6 : 08              >            php         ;save flags
2df7 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2dfa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2dfc : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2dfd : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2dff : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2e02 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e04 : ca                       dex
2e05 : 1002                     bpl tand6
                        
2e07 : a203                     ldx #3      ;zp,x
2e09 :                  tand6
                                set_ax  absANa,0
                       >            load_flag 0
2e09 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2e0b : 48              >            pha         ;use stack to load status
2e0c : bd5a02          >            lda absANa,x    ;precharge accu
2e0f : 28              >            plp
                        
2e10 : 351c                     and zpAN,x
                                tst_ax  absrlo,absflo,0
2e12 : 08              >            php         ;save flags
2e13 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2e16 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e18 : 68              >            pla         ;load status
                       >            eor_flag 0
2e19 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2e1b : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2e1e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e20 : ca                       dex
2e21 : 10e6                     bpl tand6
2e23 : a203                     ldx #3
2e25 :                  tand7
                                set_ax  absANa,$ff
                       >            load_flag $ff
2e25 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2e27 : 48              >            pha         ;use stack to load status
2e28 : bd5a02          >            lda absANa,x    ;precharge accu
2e2b : 28              >            plp
                        
2e2c : 351c                     and zpAN,x
                                tst_ax  absrlo,absflo,$ff-fnz
2e2e : 08              >            php         ;save flags
2e2f : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2e32 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e34 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2e35 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2e37 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2e3a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e3c : ca                       dex
2e3d : 10e6                     bpl tand7
                        
2e3f : a203                     ldx #3      ;abs,x
2e41 :                  tand8
                                set_ax  absANa,0
                       >            load_flag 0
2e41 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2e43 : 48              >            pha         ;use stack to load status
2e44 : bd5a02          >            lda absANa,x    ;precharge accu
2e47 : 28              >            plp
                        
2e48 : 3d4e02                   and absAN,x
                                tst_ax  absrlo,absflo,0
2e4b : 08              >            php         ;save flags
2e4c : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2e4f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e51 : 68              >            pla         ;load status
                       >            eor_flag 0
2e52 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2e54 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2e57 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e59 : ca                       dex
2e5a : 10e5                     bpl tand8
2e5c : a203                     ldx #3
2e5e :                  tand9
                                set_ax  absANa,$ff
                       >            load_flag $ff
2e5e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2e60 : 48              >            pha         ;use stack to load status
2e61 : bd5a02          >            lda absANa,x    ;precharge accu
2e64 : 28              >            plp
                        
2e65 : 3d4e02                   and absAN,x
                                tst_ax  absrlo,absflo,$ff-fnz
2e68 : 08              >            php         ;save flags
2e69 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2e6c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e6e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2e6f : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2e71 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2e74 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e76 : ca                       dex
2e77 : 10e5                     bpl tand9
                        
2e79 : a003                     ldy #3      ;abs,y
2e7b :                  tand10
                                set_ay  absANa,0
                       >            load_flag 0
2e7b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2e7d : 48              >            pha         ;use stack to load status
2e7e : b95a02          >            lda absANa,y    ;precharge accu
2e81 : 28              >            plp
                        
2e82 : 394e02                   and absAN,y
                                tst_ay  absrlo,absflo,0
2e85 : 08              >            php         ;save flags
2e86 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2e89 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2e8b : 68              >            pla         ;load status
                       >            eor_flag 0
2e8c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2e8e : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
2e91 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2e93 : 88                       dey
2e94 : 10e5                     bpl tand10
2e96 : a003                     ldy #3
2e98 :                  tand11
                                set_ay  absANa,$ff
                       >            load_flag $ff
2e98 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2e9a : 48              >            pha         ;use stack to load status
2e9b : b95a02          >            lda absANa,y    ;precharge accu
2e9e : 28              >            plp
                        
2e9f : 394e02                   and absAN,y
                                tst_ay  absrlo,absflo,$ff-fnz
2ea2 : 08              >            php         ;save flags
2ea3 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2ea6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ea8 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2ea9 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2eab : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
2eae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2eb0 : 88                       dey
2eb1 : 10e5                     bpl tand11
                        
2eb3 : a206                     ldx #6      ;(zp,x)
2eb5 : a003                     ldy #3
2eb7 :                  tand12
                                set_ay  absANa,0
                       >            load_flag 0
2eb7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2eb9 : 48              >            pha         ;use stack to load status
2eba : b95a02          >            lda absANa,y    ;precharge accu
2ebd : 28              >            plp
                        
2ebe : 213a                     and (indAN,x)
                                tst_ay  absrlo,absflo,0
2ec0 : 08              >            php         ;save flags
2ec1 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2ec4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ec6 : 68              >            pla         ;load status
                       >            eor_flag 0
2ec7 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2ec9 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
2ecc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ece : ca                       dex
2ecf : ca                       dex
2ed0 : 88                       dey
2ed1 : 10e4                     bpl tand12
2ed3 : a206                     ldx #6
2ed5 : a003                     ldy #3
2ed7 :                  tand13
                                set_ay  absANa,$ff
                       >            load_flag $ff
2ed7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2ed9 : 48              >            pha         ;use stack to load status
2eda : b95a02          >            lda absANa,y    ;precharge accu
2edd : 28              >            plp
                        
2ede : 213a                     and (indAN,x)
                                tst_ay  absrlo,absflo,$ff-fnz
2ee0 : 08              >            php         ;save flags
2ee1 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2ee4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ee6 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2ee7 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2ee9 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
2eec : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2eee : ca                       dex
2eef : ca                       dex
2ef0 : 88                       dey
2ef1 : 10e4                     bpl tand13
                        
2ef3 : a003                     ldy #3      ;(zp),y
2ef5 :                  tand14
                                set_ay  absANa,0
                       >            load_flag 0
2ef5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2ef7 : 48              >            pha         ;use stack to load status
2ef8 : b95a02          >            lda absANa,y    ;precharge accu
2efb : 28              >            plp
                        
2efc : 313a                     and (indAN),y
                                tst_ay  absrlo,absflo,0
2efe : 08              >            php         ;save flags
2eff : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2f02 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f04 : 68              >            pla         ;load status
                       >            eor_flag 0
2f05 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2f07 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
2f0a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f0c : 88                       dey
2f0d : 10e6                     bpl tand14
2f0f : a003                     ldy #3
2f11 :                  tand15
                                set_ay  absANa,$ff
                       >            load_flag $ff
2f11 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2f13 : 48              >            pha         ;use stack to load status
2f14 : b95a02          >            lda absANa,y    ;precharge accu
2f17 : 28              >            plp
                        
2f18 : 313a                     and (indAN),y
                                tst_ay  absrlo,absflo,$ff-fnz
2f1a : 08              >            php         ;save flags
2f1b : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
2f1e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f20 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2f21 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2f23 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
2f26 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f28 : 88                       dey
2f29 : 10e6                     bpl tand15
                                next_test
2f2b : ad0002          >            lda test_case   ;previous test
2f2e : c926            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
2f30 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0027 =                 >test_num = test_num + 1
2f32 : a927            >            lda #test_num   ;*** next tests' number
2f34 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; EOR
2f37 : a203                     ldx #3          ;immediate - self modifying code
2f39 : b520             teor    lda zpEO,x
2f3b : 8d0c02                   sta ex_eori+1   ;set EOR # operand
                                set_ax  absEOa,0
                       >            load_flag 0
2f3e : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2f40 : 48              >            pha         ;use stack to load status
2f41 : bd5e02          >            lda absEOa,x    ;precharge accu
2f44 : 28              >            plp
                        
2f45 : 200b02                   jsr ex_eori     ;execute EOR # in RAM
                                tst_ax  absrlo,absflo,0
2f48 : 08              >            php         ;save flags
2f49 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f4c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f4e : 68              >            pla         ;load status
                       >            eor_flag 0
2f4f : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2f51 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f54 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f56 : ca                       dex
2f57 : 10e0                     bpl teor
2f59 : a203                     ldx #3
2f5b : b520             teor1   lda zpEO,x
2f5d : 8d0c02                   sta ex_eori+1   ;set EOR # operand
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2f60 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2f62 : 48              >            pha         ;use stack to load status
2f63 : bd5e02          >            lda absEOa,x    ;precharge accu
2f66 : 28              >            plp
                        
2f67 : 200b02                   jsr ex_eori     ;execute EOR # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
2f6a : 08              >            php         ;save flags
2f6b : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f6e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f70 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2f71 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2f73 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f76 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f78 : ca                       dex
2f79 : 10e0                     bpl teor1
                            
2f7b : a203                     ldx #3      ;zp
2f7d : b520             teor2    lda zpEO,x
2f7f : 850c                     sta zpt
                                set_ax  absEOa,0
                       >            load_flag 0
2f81 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2f83 : 48              >            pha         ;use stack to load status
2f84 : bd5e02          >            lda absEOa,x    ;precharge accu
2f87 : 28              >            plp
                        
2f88 : 450c                     eor zpt
                                tst_ax  absrlo,absflo,0
2f8a : 08              >            php         ;save flags
2f8b : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2f8e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2f90 : 68              >            pla         ;load status
                       >            eor_flag 0
2f91 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2f93 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2f96 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2f98 : ca                       dex
2f99 : 10e2                     bpl teor2
2f9b : a203                     ldx #3
2f9d : b520             teor3   lda zpEO,x
2f9f : 850c                     sta zpt
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2fa1 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2fa3 : 48              >            pha         ;use stack to load status
2fa4 : bd5e02          >            lda absEOa,x    ;precharge accu
2fa7 : 28              >            plp
                        
2fa8 : 450c                     eor zpt
                                tst_ax  absrlo,absflo,$ff-fnz
2faa : 08              >            php         ;save flags
2fab : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2fae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2fb0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2fb1 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2fb3 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2fb6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2fb8 : ca                       dex
2fb9 : 10e2                     bpl teor3
                        
2fbb : a203                     ldx #3      ;abs
2fbd : b520             teor4   lda zpEO,x
2fbf : 8d0302                   sta abst
                                set_ax  absEOa,0
                       >            load_flag 0
2fc2 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
2fc4 : 48              >            pha         ;use stack to load status
2fc5 : bd5e02          >            lda absEOa,x    ;precharge accu
2fc8 : 28              >            plp
                        
2fc9 : 4d0302                   eor abst
                                tst_ax  absrlo,absflo,0
2fcc : 08              >            php         ;save flags
2fcd : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2fd0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2fd2 : 68              >            pla         ;load status
                       >            eor_flag 0
2fd3 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
2fd5 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2fd8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2fda : ca                       dex
2fdb : 10e0                     bpl teor4
2fdd : a203                     ldx #3
2fdf : b520             teor5   lda zpEO,x
2fe1 : 8d0302                   sta abst
                                set_ax  absEOa,$ff
                       >            load_flag $ff
2fe4 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
2fe6 : 48              >            pha         ;use stack to load status
2fe7 : bd5e02          >            lda absEOa,x    ;precharge accu
2fea : 28              >            plp
                        
2feb : 4d0302                   eor abst
                                tst_ax  absrlo,absflo,$ff-fnz
2fee : 08              >            php         ;save flags
2fef : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
2ff2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
2ff4 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
2ff5 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
2ff7 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
2ffa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
2ffc : ca                       dex
2ffd : 1002                     bpl teor6
                        
2fff : a203                     ldx #3      ;zp,x
3001 :                  teor6
                                set_ax  absEOa,0
                       >            load_flag 0
3001 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3003 : 48              >            pha         ;use stack to load status
3004 : bd5e02          >            lda absEOa,x    ;precharge accu
3007 : 28              >            plp
                        
3008 : 5520                     eor zpEO,x
                                tst_ax  absrlo,absflo,0
300a : 08              >            php         ;save flags
300b : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
300e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3010 : 68              >            pla         ;load status
                       >            eor_flag 0
3011 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3013 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3016 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3018 : ca                       dex
3019 : 10e6                     bpl teor6
301b : a203                     ldx #3
301d :                  teor7
                                set_ax  absEOa,$ff
                       >            load_flag $ff
301d : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
301f : 48              >            pha         ;use stack to load status
3020 : bd5e02          >            lda absEOa,x    ;precharge accu
3023 : 28              >            plp
                        
3024 : 5520                     eor zpEO,x
                                tst_ax  absrlo,absflo,$ff-fnz
3026 : 08              >            php         ;save flags
3027 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
302a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
302c : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
302d : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
302f : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3032 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3034 : ca                       dex
3035 : 10e6                     bpl teor7
                        
3037 : a203                     ldx #3      ;abs,x
3039 :                  teor8
                                set_ax  absEOa,0
                       >            load_flag 0
3039 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
303b : 48              >            pha         ;use stack to load status
303c : bd5e02          >            lda absEOa,x    ;precharge accu
303f : 28              >            plp
                        
3040 : 5d5202                   eor absEO,x
                                tst_ax  absrlo,absflo,0
3043 : 08              >            php         ;save flags
3044 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3047 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3049 : 68              >            pla         ;load status
                       >            eor_flag 0
304a : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
304c : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
304f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3051 : ca                       dex
3052 : 10e5                     bpl teor8
3054 : a203                     ldx #3
3056 :                  teor9
                                set_ax  absEOa,$ff
                       >            load_flag $ff
3056 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3058 : 48              >            pha         ;use stack to load status
3059 : bd5e02          >            lda absEOa,x    ;precharge accu
305c : 28              >            plp
                        
305d : 5d5202                   eor absEO,x
                                tst_ax  absrlo,absflo,$ff-fnz
3060 : 08              >            php         ;save flags
3061 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3064 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3066 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3067 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3069 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
306c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
306e : ca                       dex
306f : 10e5                     bpl teor9
                        
3071 : a003                     ldy #3      ;abs,y
3073 :                  teor10
                                set_ay  absEOa,0
                       >            load_flag 0
3073 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3075 : 48              >            pha         ;use stack to load status
3076 : b95e02          >            lda absEOa,y    ;precharge accu
3079 : 28              >            plp
                        
307a : 595202                   eor absEO,y
                                tst_ay  absrlo,absflo,0
307d : 08              >            php         ;save flags
307e : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3081 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3083 : 68              >            pla         ;load status
                       >            eor_flag 0
3084 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3086 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
3089 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
308b : 88                       dey
308c : 10e5                     bpl teor10
308e : a003                     ldy #3
3090 :                  teor11
                                set_ay  absEOa,$ff
                       >            load_flag $ff
3090 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3092 : 48              >            pha         ;use stack to load status
3093 : b95e02          >            lda absEOa,y    ;precharge accu
3096 : 28              >            plp
                        
3097 : 595202                   eor absEO,y
                                tst_ay  absrlo,absflo,$ff-fnz
309a : 08              >            php         ;save flags
309b : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
309e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
30a0 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
30a1 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
30a3 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
30a6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
30a8 : 88                       dey
30a9 : 10e5                     bpl teor11
                        
30ab : a206                     ldx #6      ;(zp,x)
30ad : a003                     ldy #3
30af :                  teor12
                                set_ay  absEOa,0
                       >            load_flag 0
30af : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
30b1 : 48              >            pha         ;use stack to load status
30b2 : b95e02          >            lda absEOa,y    ;precharge accu
30b5 : 28              >            plp
                        
30b6 : 4142                     eor (indEO,x)
                                tst_ay  absrlo,absflo,0
30b8 : 08              >            php         ;save flags
30b9 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
30bc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
30be : 68              >            pla         ;load status
                       >            eor_flag 0
30bf : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
30c1 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
30c4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
30c6 : ca                       dex
30c7 : ca                       dex
30c8 : 88                       dey
30c9 : 10e4                     bpl teor12
30cb : a206                     ldx #6
30cd : a003                     ldy #3
30cf :                  teor13
                                set_ay  absEOa,$ff
                       >            load_flag $ff
30cf : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
30d1 : 48              >            pha         ;use stack to load status
30d2 : b95e02          >            lda absEOa,y    ;precharge accu
30d5 : 28              >            plp
                        
30d6 : 4142                     eor (indEO,x)
                                tst_ay  absrlo,absflo,$ff-fnz
30d8 : 08              >            php         ;save flags
30d9 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
30dc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
30de : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
30df : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
30e1 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
30e4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
30e6 : ca                       dex
30e7 : ca                       dex
30e8 : 88                       dey
30e9 : 10e4                     bpl teor13
                        
30eb : a003                     ldy #3      ;(zp),y
30ed :                  teor14
                                set_ay  absEOa,0
                       >            load_flag 0
30ed : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
30ef : 48              >            pha         ;use stack to load status
30f0 : b95e02          >            lda absEOa,y    ;precharge accu
30f3 : 28              >            plp
                        
30f4 : 5142                     eor (indEO),y
                                tst_ay  absrlo,absflo,0
30f6 : 08              >            php         ;save flags
30f7 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
30fa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
30fc : 68              >            pla         ;load status
                       >            eor_flag 0
30fd : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
30ff : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
3102 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3104 : 88                       dey
3105 : 10e6                     bpl teor14
3107 : a003                     ldy #3
3109 :                  teor15
                                set_ay  absEOa,$ff
                       >            load_flag $ff
3109 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
310b : 48              >            pha         ;use stack to load status
310c : b95e02          >            lda absEOa,y    ;precharge accu
310f : 28              >            plp
                        
3110 : 5142                     eor (indEO),y
                                tst_ay  absrlo,absflo,$ff-fnz
3112 : 08              >            php         ;save flags
3113 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3116 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3118 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3119 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
311b : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
311e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3120 : 88                       dey
3121 : 10e6                     bpl teor15
                                next_test
3123 : ad0002          >            lda test_case   ;previous test
3126 : c927            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
3128 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0028 =                 >test_num = test_num + 1
312a : a928            >            lda #test_num   ;*** next tests' number
312c : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; OR
312f : a203                     ldx #3          ;immediate - self modifying code
3131 : b518             tora    lda zpOR,x
3133 : 8d0f02                   sta ex_orai+1   ;set ORA # operand
                                set_ax  absORa,0
                       >            load_flag 0
3136 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3138 : 48              >            pha         ;use stack to load status
3139 : bd5602          >            lda absORa,x    ;precharge accu
313c : 28              >            plp
                        
313d : 200e02                   jsr ex_orai     ;execute ORA # in RAM
                                tst_ax  absrlo,absflo,0
3140 : 08              >            php         ;save flags
3141 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3144 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3146 : 68              >            pla         ;load status
                       >            eor_flag 0
3147 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3149 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
314c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
314e : ca                       dex
314f : 10e0                     bpl tora
3151 : a203                     ldx #3
3153 : b518             tora1   lda zpOR,x
3155 : 8d0f02                   sta ex_orai+1   ;set ORA # operand
                                set_ax  absORa,$ff
                       >            load_flag $ff
3158 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
315a : 48              >            pha         ;use stack to load status
315b : bd5602          >            lda absORa,x    ;precharge accu
315e : 28              >            plp
                        
315f : 200e02                   jsr ex_orai     ;execute ORA # in RAM
                                tst_ax  absrlo,absflo,$ff-fnz
3162 : 08              >            php         ;save flags
3163 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3166 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3168 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3169 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
316b : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
316e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3170 : ca                       dex
3171 : 10e0                     bpl tora1
                            
3173 : a203                     ldx #3      ;zp
3175 : b518             tora2   lda zpOR,x
3177 : 850c                     sta zpt
                                set_ax  absORa,0
                       >            load_flag 0
3179 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
317b : 48              >            pha         ;use stack to load status
317c : bd5602          >            lda absORa,x    ;precharge accu
317f : 28              >            plp
                        
3180 : 050c                     ora zpt
                                tst_ax  absrlo,absflo,0
3182 : 08              >            php         ;save flags
3183 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3186 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3188 : 68              >            pla         ;load status
                       >            eor_flag 0
3189 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
318b : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
318e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3190 : ca                       dex
3191 : 10e2                     bpl tora2
3193 : a203                     ldx #3
3195 : b518             tora3   lda zpOR,x
3197 : 850c                     sta zpt
                                set_ax  absORa,$ff
                       >            load_flag $ff
3199 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
319b : 48              >            pha         ;use stack to load status
319c : bd5602          >            lda absORa,x    ;precharge accu
319f : 28              >            plp
                        
31a0 : 050c                     ora zpt
                                tst_ax  absrlo,absflo,$ff-fnz
31a2 : 08              >            php         ;save flags
31a3 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
31a6 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31a8 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
31a9 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
31ab : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
31ae : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
31b0 : ca                       dex
31b1 : 10e2                     bpl tora3
                        
31b3 : a203                     ldx #3      ;abs
31b5 : b518             tora4   lda zpOR,x
31b7 : 8d0302                   sta abst
                                set_ax  absORa,0
                       >            load_flag 0
31ba : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
31bc : 48              >            pha         ;use stack to load status
31bd : bd5602          >            lda absORa,x    ;precharge accu
31c0 : 28              >            plp
                        
31c1 : 0d0302                   ora abst
                                tst_ax  absrlo,absflo,0
31c4 : 08              >            php         ;save flags
31c5 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
31c8 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31ca : 68              >            pla         ;load status
                       >            eor_flag 0
31cb : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
31cd : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
31d0 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
31d2 : ca                       dex
31d3 : 10e0                     bpl tora4
31d5 : a203                     ldx #3
31d7 : b518             tora5   lda zpOR,x
31d9 : 8d0302                   sta abst
                                set_ax  absORa,$ff
                       >            load_flag $ff
31dc : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
31de : 48              >            pha         ;use stack to load status
31df : bd5602          >            lda absORa,x    ;precharge accu
31e2 : 28              >            plp
                        
31e3 : 0d0302                   ora abst
                                tst_ax  absrlo,absflo,$ff-fnz
31e6 : 08              >            php         ;save flags
31e7 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
31ea : d0fe            >        bne *           ;failed not equal (non zero)
                       >
31ec : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
31ed : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
31ef : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
31f2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
31f4 : ca                       dex
31f5 : 1002                     bpl tora6
                        
31f7 : a203                     ldx #3      ;zp,x
31f9 :                  tora6
                                set_ax  absORa,0
                       >            load_flag 0
31f9 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
31fb : 48              >            pha         ;use stack to load status
31fc : bd5602          >            lda absORa,x    ;precharge accu
31ff : 28              >            plp
                        
3200 : 1518                     ora zpOR,x
                                tst_ax  absrlo,absflo,0
3202 : 08              >            php         ;save flags
3203 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3206 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3208 : 68              >            pla         ;load status
                       >            eor_flag 0
3209 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
320b : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
320e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3210 : ca                       dex
3211 : 10e6                     bpl tora6
3213 : a203                     ldx #3
3215 :                  tora7
                                set_ax  absORa,$ff
                       >            load_flag $ff
3215 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3217 : 48              >            pha         ;use stack to load status
3218 : bd5602          >            lda absORa,x    ;precharge accu
321b : 28              >            plp
                        
321c : 1518                     ora zpOR,x
                                tst_ax  absrlo,absflo,$ff-fnz
321e : 08              >            php         ;save flags
321f : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
3222 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3224 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3225 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3227 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
322a : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
322c : ca                       dex
322d : 10e6                     bpl tora7
                        
322f : a203                     ldx #3      ;abs,x
3231 :                  tora8
                                set_ax  absORa,0
                       >            load_flag 0
3231 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
3233 : 48              >            pha         ;use stack to load status
3234 : bd5602          >            lda absORa,x    ;precharge accu
3237 : 28              >            plp
                        
3238 : 1d4a02                   ora absOR,x
                                tst_ax  absrlo,absflo,0
323b : 08              >            php         ;save flags
323c : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
323f : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3241 : 68              >            pla         ;load status
                       >            eor_flag 0
3242 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
3244 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3247 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3249 : ca                       dex
324a : 10e5                     bpl tora8
324c : a203                     ldx #3
324e :                  tora9
                                set_ax  absORa,$ff
                       >            load_flag $ff
324e : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3250 : 48              >            pha         ;use stack to load status
3251 : bd5602          >            lda absORa,x    ;precharge accu
3254 : 28              >            plp
                        
3255 : 1d4a02                   ora absOR,x
                                tst_ax  absrlo,absflo,$ff-fnz
3258 : 08              >            php         ;save flags
3259 : dd6202          >            cmp absrlo,x    ;test result
                       >            trap_ne
325c : d0fe            >        bne *           ;failed not equal (non zero)
                       >
325e : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
325f : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3261 : dd6602          >            cmp absflo,x    ;test flags
                       >            trap_ne     ;
3264 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3266 : ca                       dex
3267 : 10e5                     bpl tora9
                        
3269 : a003                     ldy #3      ;abs,y
326b :                  tora10
                                set_ay  absORa,0
                       >            load_flag 0
326b : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
326d : 48              >            pha         ;use stack to load status
326e : b95602          >            lda absORa,y    ;precharge accu
3271 : 28              >            plp
                        
3272 : 194a02                   ora absOR,y
                                tst_ay  absrlo,absflo,0
3275 : 08              >            php         ;save flags
3276 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3279 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
327b : 68              >            pla         ;load status
                       >            eor_flag 0
327c : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
327e : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
3281 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3283 : 88                       dey
3284 : 10e5                     bpl tora10
3286 : a003                     ldy #3
3288 :                  tora11
                                set_ay  absORa,$ff
                       >            load_flag $ff
3288 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
328a : 48              >            pha         ;use stack to load status
328b : b95602          >            lda absORa,y    ;precharge accu
328e : 28              >            plp
                        
328f : 194a02                   ora absOR,y
                                tst_ay  absrlo,absflo,$ff-fnz
3292 : 08              >            php         ;save flags
3293 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
3296 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3298 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3299 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
329b : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
329e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
32a0 : 88                       dey
32a1 : 10e5                     bpl tora11
                        
32a3 : a206                     ldx #6      ;(zp,x)
32a5 : a003                     ldy #3
32a7 :                  tora12
                                set_ay  absORa,0
                       >            load_flag 0
32a7 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
32a9 : 48              >            pha         ;use stack to load status
32aa : b95602          >            lda absORa,y    ;precharge accu
32ad : 28              >            plp
                        
32ae : 014a                     ora (indOR,x)
                                tst_ay  absrlo,absflo,0
32b0 : 08              >            php         ;save flags
32b1 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
32b4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
32b6 : 68              >            pla         ;load status
                       >            eor_flag 0
32b7 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
32b9 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
32bc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
32be : ca                       dex
32bf : ca                       dex
32c0 : 88                       dey
32c1 : 10e4                     bpl tora12
32c3 : a206                     ldx #6
32c5 : a003                     ldy #3
32c7 :                  tora13
                                set_ay  absORa,$ff
                       >            load_flag $ff
32c7 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
32c9 : 48              >            pha         ;use stack to load status
32ca : b95602          >            lda absORa,y    ;precharge accu
32cd : 28              >            plp
                        
32ce : 014a                     ora (indOR,x)
                                tst_ay  absrlo,absflo,$ff-fnz
32d0 : 08              >            php         ;save flags
32d1 : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
32d4 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
32d6 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
32d7 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
32d9 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
32dc : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
32de : ca                       dex
32df : ca                       dex
32e0 : 88                       dey
32e1 : 10e4                     bpl tora13
                        
32e3 : a003                     ldy #3      ;(zp),y
32e5 :                  tora14
                                set_ay  absORa,0
                       >            load_flag 0
32e5 : a900            >            lda #0             ;allow test to change I-flag (no mask)
                       >
32e7 : 48              >            pha         ;use stack to load status
32e8 : b95602          >            lda absORa,y    ;precharge accu
32eb : 28              >            plp
                        
32ec : 114a                     ora (indOR),y
                                tst_ay  absrlo,absflo,0
32ee : 08              >            php         ;save flags
32ef : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
32f2 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
32f4 : 68              >            pla         ;load status
                       >            eor_flag 0
32f5 : 4930            >            eor #0|fao         ;invert expected flags + always on bits
                       >
32f7 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
32fa : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
32fc : 88                       dey
32fd : 10e6                     bpl tora14
32ff : a003                     ldy #3
3301 :                  tora15
                                set_ay  absORa,$ff
                       >            load_flag $ff
3301 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3303 : 48              >            pha         ;use stack to load status
3304 : b95602          >            lda absORa,y    ;precharge accu
3307 : 28              >            plp
                        
3308 : 114a                     ora (indOR),y
                                tst_ay  absrlo,absflo,$ff-fnz
330a : 08              >            php         ;save flags
330b : d96202          >            cmp absrlo,y    ;test result
                       >            trap_ne     ;
330e : d0fe            >        bne *           ;failed not equal (non zero)
                       >
3310 : 68              >            pla         ;load status
                       >            eor_flag $ff-fnz
3311 : 497d            >            eor #$ff-fnz|fao         ;invert expected flags + always on bits
                       >
3313 : d96602          >            cmp absflo,y    ;test flags
                       >            trap_ne
3316 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
                        
3318 : 88                       dey
3319 : 10e6                     bpl tora15
                            if I_flag = 3
331b : 58                       cli
                            endif                
                                next_test
331c : ad0002          >            lda test_case   ;previous test
331f : c928            >            cmp #test_num
                       >            trap_ne         ;test is out of sequence
3321 : d0fe            >        bne *           ;failed not equal (non zero)
                       >
0029 =                 >test_num = test_num + 1
3323 : a929            >            lda #test_num   ;*** next tests' number
3325 : 8d0002          >            sta test_case
                       >            ;check_ram       ;uncomment to find altered RAM after each test
                        
                        
                        ; full binary add/subtract test
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
3328 : d8                       cld
3329 : a20e                     ldx #ad2        ;for indexed test
332b : a0ff                     ldy #$ff        ;max range
332d : a900                     lda #0          ;start with adding zeroes & no carry
332f : 850c                     sta adfc        ;carry in - for diag
3331 : 850d                     sta ad1         ;operand 1 - accumulator
3333 : 850e                     sta ad2         ;operand 2 - memory or immediate
3335 : 8d0302                   sta ada2        ;non zp
3338 : 850f                     sta adrl        ;expected result bits 0-7
333a : 8510                     sta adrh        ;expected result bit 8 (carry out)
333c : a9ff                     lda #$ff        ;complemented operand 2 for subtract
333e : 8512                     sta sb2
3340 : 8d0402                   sta sba2        ;non zp
3343 : a902                     lda #2          ;expected Z-flag
3345 : 8511                     sta adrf
3347 : 18               tadd    clc             ;test with carry clear
3348 : 209333                   jsr chkadd
334b : e60c                     inc adfc        ;now with carry
334d : e60f                     inc adrl        ;result +1
334f : 08                       php             ;save N & Z from low result
3350 : 08                       php
3351 : 68                       pla             ;accu holds expected flags
3352 : 2982                     and #$82        ;mask N & Z
3354 : 28                       plp
3355 : d002                     bne tadd1
3357 : e610                     inc adrh        ;result bit 8 - carry
3359 : 0510             tadd1   ora adrh        ;merge C to expected flags
335b : 8511                     sta adrf        ;save expected flags except overflow
335d : 38                       sec             ;test with carry set
335e : 209333                   jsr chkadd
3361 : c60c                     dec adfc        ;same for operand +1 but no carry
3363 : e60d                     inc ad1
3365 : d0e0                     bne tadd        ;iterate op1
3367 : a900                     lda #0          ;preset result to op2 when op1 = 0
3369 : 8510                     sta adrh
336b : ee0302                   inc ada2
336e : e60e                     inc ad2
3370 : 08                       php             ;save NZ as operand 2 becomes the new result
3371 : 68                       pla
3372 : 2982                     and #$82        ;mask N00000Z0
3374 : 8511                     sta adrf        ;no need to check carry as we are adding to 0
3376 : c612                     dec sb2         ;complement subtract operand 2
3378 : ce0402                   dec sba2
337b : a50e                     lda ad2         
337d : 850f                     sta adrl
337f : d0c6                     bne tadd        ;iterate op2
                            if disable_decimal < 1
                                next_test
                        
                        ; decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, N V Z flags are ignored
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
                                sed 
                                ldx #ad2        ;for indexed test
                                ldy #$ff        ;max range
                                lda #$99        ;start with adding 99 to 99 with carry
                                sta ad1         ;operand 1 - accumulator
                                sta ad2         ;operand 2 - memory or immediate
                                sta ada2        ;non zp
                                sta adrl        ;expected result bits 0-7
                                lda #1          ;set carry in & out
                                sta adfc        ;carry in - for diag
                                sta adrh        ;expected result bit 8 (carry out)
                                lda #0          ;complemented operand 2 for subtract
                                sta sb2
                                sta sba2        ;non zp
                        tdad    sec             ;test with carry set
                                jsr chkdad
                                dec adfc        ;now with carry clear
                                lda adrl        ;decimal adjust result
                                bne tdad1       ;skip clear carry & preset result 99 (9A-1)
                                dec adrh
                                lda #$99
                                sta adrl
                                bne tdad3
                        tdad1   and #$f         ;lower nibble mask
                                bne tdad2       ;no decimal adjust needed
                                dec adrl        ;decimal adjust (?0-6)
                                dec adrl
                                dec adrl
                                dec adrl
                                dec adrl
                                dec adrl
                        tdad2   dec adrl        ;result -1
                        tdad3   clc             ;test with carry clear
                                jsr chkdad
                                inc adfc        ;same for operand -1 but with carry
                                lda ad1         ;decimal adjust operand 1
                                beq tdad5       ;iterate operand 2
                                and #$f         ;lower nibble mask
                                bne tdad4       ;skip decimal adjust
                                dec ad1         ;decimal adjust (?0-6)
                                dec ad1
                                dec ad1
                                dec ad1
                                dec ad1
                                dec ad1
                        tdad4   dec ad1         ;operand 1 -1
                                jmp tdad        ;iterate op1
                        
                        tdad5   lda #$99        ;precharge op1 max
                                sta ad1
                                lda ad2         ;decimal adjust operand 2
                                beq tdad7       ;end of iteration
                                and #$f         ;lower nibble mask
                                bne tdad6       ;skip decimal adjust
                                dec ad2         ;decimal adjust (?0-6)
                                dec ad2
                                dec ad2
                                dec ad2
                                dec ad2
                                dec ad2
                                inc sb2         ;complemented decimal adjust for subtract (?9+6)
                                inc sb2
                                inc sb2
                                inc sb2
                                inc sb2
                                inc sb2
                        tdad6   dec ad2         ;operand 2 -1
                                inc sb2         ;complemented operand for subtract
                                lda sb2
                                sta sba2        ;copy as non zp operand
                                lda ad2
                                sta ada2        ;copy as non zp operand
                                sta adrl        ;new result since op1+carry=00+carry +op2=op2
                                inc adrh        ;result carry
                                bne tdad        ;iterate op2
                        tdad7
                                next_test
                        
                        ; decimal/binary switch test
                        ; tests CLD, SED, PLP, RTI to properly switch between decimal & binary opcode
                        ;   tables
                                clc
                                cld
                                php
                                lda #$55
                                adc #$55
                                cmp #$aa
                                trap_ne         ;expected binary result after cld
                                clc
                                sed
                                php
                                lda #$55
                                adc #$55
                                cmp #$10
                                trap_ne         ;expected decimal result after sed
                                cld
                                plp
                                lda #$55
                                adc #$55
                                cmp #$10
                                trap_ne         ;expected decimal result after plp D=1
                                plp
                                lda #$55
                                adc #$55
                                cmp #$aa
                                trap_ne         ;expected binary result after plp D=0
                                clc
                                lda #hi bin_rti_ret ;emulated interrupt for rti
                                pha
                                lda #lo bin_rti_ret
                                pha
                                php
                                sed
                                lda #hi dec_rti_ret ;emulated interrupt for rti
                                pha
                                lda #lo dec_rti_ret
                                pha
                                php
                                cld
                                rti
                        dec_rti_ret
                                lda #$55
                                adc #$55
                                cmp #$10
                                trap_ne         ;expected decimal result after rti D=1
                                rti
                        bin_rti_ret        
                                lda #$55
                                adc #$55
                                cmp #$aa
                                trap_ne         ;expected binary result after rti D=0
                            endif
                            
3381 : ad0002                   lda test_case
3384 : c929                     cmp #test_num
                                trap_ne         ;previous test is out of sequence
3386 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3388 : a9f0                     lda #$f0        ;mark opcode testing complete
338a : 8d0002                   sta test_case
                                
                        ; final RAM integrity test
                        ;   verifies that none of the previous tests has altered RAM outside of the
                        ;   designated write areas.
                                check_ram
                       >            ;RAM check disabled - RAM size not set
                        
                        ; *** DEBUG INFO ***
                        ; to debug checksum errors uncomment check_ram in the next_test macro to
                        ; narrow down the responsible opcode.
                        ; may give false errors when monitor, OS or other background activity is
                        ; allowed during previous tests.
                        
                        
                        ; S U C C E S S ************************************************
                        ; -------------       
                                success         ;if you get here everything went well
338d : 4c8d33          >        jmp *           ;test passed, no errors
                        
                        ; -------------       
                        ; S U C C E S S ************************************************
3390 : 4c0004                   jmp start       ;run again      
                        
                            if disable_decimal < 1
                        ; core subroutine of the decimal add/subtract test
                        ; *** WARNING - tests documented behavior only! ***
                        ;   only valid BCD operands are tested, N V Z flags are ignored
                        ; iterates through all valid combinations of operands and carry input
                        ; uses increments/decrements to predict result & carry flag
                        chkdad
                        ; decimal ADC / SBC zp
                                php             ;save carry for subtract
                                lda ad1
                                adc ad2         ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sb2         ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad flags
                                plp
                        ; decimal ADC / SBC abs
                                php             ;save carry for subtract
                                lda ad1
                                adc ada2        ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sba2        ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC #
                                php             ;save carry for subtract
                                lda ad2
                                sta ex_adci+1   ;set ADC # operand
                                lda ad1
                                jsr ex_adci     ;execute ADC # in RAM
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda sb2
                                sta ex_sbci+1   ;set SBC # operand
                                lda ad1
                                jsr ex_sbci     ;execute SBC # in RAM
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC zp,x
                                php             ;save carry for subtract
                                lda ad1
                                adc 0,x         ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sb2-ad2,x   ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC abs,x
                                php             ;save carry for subtract
                                lda ad1
                                adc ada2-ad2,x  ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sba2-ad2,x  ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC abs,y
                                php             ;save carry for subtract
                                lda ad1
                                adc ada2-$ff,y  ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc sba2-$ff,y  ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC (zp,x)
                                php             ;save carry for subtract
                                lda ad1
                                adc (lo adi2-ad2,x) ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc (lo sbi2-ad2,x) ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                        ; decimal ADC / SBC (abs),y
                                php             ;save carry for subtract
                                lda ad1
                                adc (adiy2),y   ;perform add
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                php             ;save carry for next add
                                lda ad1
                                sbc (sbiy2),y   ;perform subtract
                                php          
                                cmp adrl        ;check result
                                trap_ne         ;bad result
                                pla             ;check flags
                                and #1          ;mask carry
                                cmp adrh
                                trap_ne         ;bad carry
                                plp
                                rts
                            endif
                        
                        ; core subroutine of the full binary add/subtract test
                        ; iterates through all combinations of operands and carry input
                        ; uses increments/decrements to predict result & result flags
3393 : a511             chkadd  lda adrf        ;add V-flag if overflow
3395 : 2983                     and #$83        ;keep N-----ZC / clear V
3397 : 48                       pha
3398 : a50d                     lda ad1         ;test sign unequal between operands
339a : 450e                     eor ad2
339c : 300a                     bmi ckad1       ;no overflow possible - operands have different sign
339e : a50d                     lda ad1         ;test sign equal between operands and result
33a0 : 450f                     eor adrl
33a2 : 1004                     bpl ckad1       ;no overflow occured - operand and result have same sign
33a4 : 68                       pla
33a5 : 0940                     ora #$40        ;set V
33a7 : 48                       pha
33a8 : 68               ckad1   pla
33a9 : 8511                     sta adrf        ;save expected flags
                        ; binary ADC / SBC zp
33ab : 08                       php             ;save carry for subtract
33ac : a50d                     lda ad1
33ae : 650e                     adc ad2         ;perform add
33b0 : 08                       php          
33b1 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
33b3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
33b5 : 68                       pla             ;check flags
33b6 : 29c3                     and #$c3        ;mask NV----ZC
33b8 : c511                     cmp adrf
                                trap_ne         ;bad flags
33ba : d0fe            >        bne *           ;failed not equal (non zero)
                        
33bc : 28                       plp
33bd : 08                       php             ;save carry for next add
33be : a50d                     lda ad1
33c0 : e512                     sbc sb2         ;perform subtract
33c2 : 08                       php          
33c3 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
33c5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
33c7 : 68                       pla             ;check flags
33c8 : 29c3                     and #$c3        ;mask NV----ZC
33ca : c511                     cmp adrf
                                trap_ne         ;bad flags
33cc : d0fe            >        bne *           ;failed not equal (non zero)
                        
33ce : 28                       plp
                        ; binary ADC / SBC abs
33cf : 08                       php             ;save carry for subtract
33d0 : a50d                     lda ad1
33d2 : 6d0302                   adc ada2        ;perform add
33d5 : 08                       php          
33d6 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
33d8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
33da : 68                       pla             ;check flags
33db : 29c3                     and #$c3        ;mask NV----ZC
33dd : c511                     cmp adrf
                                trap_ne         ;bad flags
33df : d0fe            >        bne *           ;failed not equal (non zero)
                        
33e1 : 28                       plp
33e2 : 08                       php             ;save carry for next add
33e3 : a50d                     lda ad1
33e5 : ed0402                   sbc sba2        ;perform subtract
33e8 : 08                       php          
33e9 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
33eb : d0fe            >        bne *           ;failed not equal (non zero)
                        
33ed : 68                       pla             ;check flags
33ee : 29c3                     and #$c3        ;mask NV----ZC
33f0 : c511                     cmp adrf
                                trap_ne         ;bad flags
33f2 : d0fe            >        bne *           ;failed not equal (non zero)
                        
33f4 : 28                       plp
                        ; binary ADC / SBC #
33f5 : 08                       php             ;save carry for subtract
33f6 : a50e                     lda ad2
33f8 : 8d1202                   sta ex_adci+1   ;set ADC # operand
33fb : a50d                     lda ad1
33fd : 201102                   jsr ex_adci     ;execute ADC # in RAM
3400 : 08                       php          
3401 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3403 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3405 : 68                       pla             ;check flags
3406 : 29c3                     and #$c3        ;mask NV----ZC
3408 : c511                     cmp adrf
                                trap_ne         ;bad flags
340a : d0fe            >        bne *           ;failed not equal (non zero)
                        
340c : 28                       plp
340d : 08                       php             ;save carry for next add
340e : a512                     lda sb2
3410 : 8d1502                   sta ex_sbci+1   ;set SBC # operand
3413 : a50d                     lda ad1
3415 : 201402                   jsr ex_sbci     ;execute SBC # in RAM
3418 : 08                       php          
3419 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
341b : d0fe            >        bne *           ;failed not equal (non zero)
                        
341d : 68                       pla             ;check flags
341e : 29c3                     and #$c3        ;mask NV----ZC
3420 : c511                     cmp adrf
                                trap_ne         ;bad flags
3422 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3424 : 28                       plp
                        ; binary ADC / SBC zp,x
3425 : 08                       php             ;save carry for subtract
3426 : a50d                     lda ad1
3428 : 7500                     adc 0,x         ;perform add
342a : 08                       php          
342b : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
342d : d0fe            >        bne *           ;failed not equal (non zero)
                        
342f : 68                       pla             ;check flags
3430 : 29c3                     and #$c3        ;mask NV----ZC
3432 : c511                     cmp adrf
                                trap_ne         ;bad flags
3434 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3436 : 28                       plp
3437 : 08                       php             ;save carry for next add
3438 : a50d                     lda ad1
343a : f504                     sbc sb2-ad2,x   ;perform subtract
343c : 08                       php          
343d : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
343f : d0fe            >        bne *           ;failed not equal (non zero)
                        
3441 : 68                       pla             ;check flags
3442 : 29c3                     and #$c3        ;mask NV----ZC
3444 : c511                     cmp adrf
                                trap_ne         ;bad flags
3446 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3448 : 28                       plp
                        ; binary ADC / SBC abs,x
3449 : 08                       php             ;save carry for subtract
344a : a50d                     lda ad1
344c : 7df501                   adc ada2-ad2,x  ;perform add
344f : 08                       php          
3450 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3452 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3454 : 68                       pla             ;check flags
3455 : 29c3                     and #$c3        ;mask NV----ZC
3457 : c511                     cmp adrf
                                trap_ne         ;bad flags
3459 : d0fe            >        bne *           ;failed not equal (non zero)
                        
345b : 28                       plp
345c : 08                       php             ;save carry for next add
345d : a50d                     lda ad1
345f : fdf601                   sbc sba2-ad2,x  ;perform subtract
3462 : 08                       php          
3463 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3465 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3467 : 68                       pla             ;check flags
3468 : 29c3                     and #$c3        ;mask NV----ZC
346a : c511                     cmp adrf
                                trap_ne         ;bad flags
346c : d0fe            >        bne *           ;failed not equal (non zero)
                        
346e : 28                       plp
                        ; binary ADC / SBC abs,y
346f : 08                       php             ;save carry for subtract
3470 : a50d                     lda ad1
3472 : 790401                   adc ada2-$ff,y  ;perform add
3475 : 08                       php          
3476 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
3478 : d0fe            >        bne *           ;failed not equal (non zero)
                        
347a : 68                       pla             ;check flags
347b : 29c3                     and #$c3        ;mask NV----ZC
347d : c511                     cmp adrf
                                trap_ne         ;bad flags
347f : d0fe            >        bne *           ;failed not equal (non zero)
                        
3481 : 28                       plp
3482 : 08                       php             ;save carry for next add
3483 : a50d                     lda ad1
3485 : f90501                   sbc sba2-$ff,y  ;perform subtract
3488 : 08                       php          
3489 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
348b : d0fe            >        bne *           ;failed not equal (non zero)
                        
348d : 68                       pla             ;check flags
348e : 29c3                     and #$c3        ;mask NV----ZC
3490 : c511                     cmp adrf
                                trap_ne         ;bad flags
3492 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3494 : 28                       plp
                        ; binary ADC / SBC (zp,x)
3495 : 08                       php             ;save carry for subtract
3496 : a50d                     lda ad1
3498 : 6144                     adc (lo adi2-ad2,x) ;perform add
349a : 08                       php          
349b : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
349d : d0fe            >        bne *           ;failed not equal (non zero)
                        
349f : 68                       pla             ;check flags
34a0 : 29c3                     and #$c3        ;mask NV----ZC
34a2 : c511                     cmp adrf
                                trap_ne         ;bad flags
34a4 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34a6 : 28                       plp
34a7 : 08                       php             ;save carry for next add
34a8 : a50d                     lda ad1
34aa : e146                     sbc (lo sbi2-ad2,x) ;perform subtract
34ac : 08                       php          
34ad : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
34af : d0fe            >        bne *           ;failed not equal (non zero)
                        
34b1 : 68                       pla             ;check flags
34b2 : 29c3                     and #$c3        ;mask NV----ZC
34b4 : c511                     cmp adrf
                                trap_ne         ;bad flags
34b6 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34b8 : 28                       plp
                        ; binary ADC / SBC (abs),y
34b9 : 08                       php             ;save carry for subtract
34ba : a50d                     lda ad1
34bc : 7156                     adc (adiy2),y   ;perform add
34be : 08                       php          
34bf : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
34c1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34c3 : 68                       pla             ;check flags
34c4 : 29c3                     and #$c3        ;mask NV----ZC
34c6 : c511                     cmp adrf
                                trap_ne         ;bad flags
34c8 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34ca : 28                       plp
34cb : 08                       php             ;save carry for next add
34cc : a50d                     lda ad1
34ce : f158                     sbc (sbiy2),y   ;perform subtract
34d0 : 08                       php          
34d1 : c50f                     cmp adrl        ;check result
                                trap_ne         ;bad result
34d3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34d5 : 68                       pla             ;check flags
34d6 : 29c3                     and #$c3        ;mask NV----ZC
34d8 : c511                     cmp adrf
                                trap_ne         ;bad flags
34da : d0fe            >        bne *           ;failed not equal (non zero)
                        
34dc : 28                       plp
34dd : 60                       rts
                        
                        ; target for the jump absolute test
34de : 88                       dey
34df : 88                       dey
34e0 :                  test_far
34e0 : 08                       php             ;either SP or Y count will fail, if we do not hit
34e1 : 88                       dey
34e2 : 88                       dey
34e3 : 88                       dey
34e4 : 28                       plp
                                trap_cs         ;flags loaded?
34e5 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
34e7 : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
34e9 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq 
34eb : f0fe            >        beq *           ;failed equal (zero)
                        
34ed : c946                     cmp #'F'        ;registers loaded?
                                trap_ne
34ef : d0fe            >        bne *           ;failed not equal (non zero)
                        
34f1 : e041                     cpx #'A'
                                trap_ne        
34f3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34f5 : c04f                     cpy #('R'-3)
                                trap_ne
34f7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
34f9 : 48                       pha             ;save a,x
34fa : 8a                       txa
34fb : 48                       pha
34fc : ba                       tsx
34fd : e0fd                     cpx #$fd        ;check SP
                                trap_ne
34ff : d0fe            >        bne *           ;failed not equal (non zero)
                        
3501 : 68                       pla             ;restore x
3502 : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
3503 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
3505 : 48              >            pha         ;use stack to load status
3506 : 28              >            plp
                        
3507 : 68                       pla             ;restore a
3508 : e8                       inx             ;return registers with modifications
3509 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
350b : 4c2f09                   jmp far_ret
                                
                        ; target for the jump indirect test
                                align
350e : 1735             ptr_tst_ind dw test_ind
3510 : 8409             ptr_ind_ret dw ind_ret
                                trap            ;runover protection
3512 : 4c1235          >        jmp *           ;failed anyway
                        
3515 : 88                       dey
3516 : 88                       dey
3517 :                  test_ind
3517 : 08                       php             ;either SP or Y count will fail, if we do not hit
3518 : 88                       dey
3519 : 88                       dey
351a : 88                       dey
351b : 28                       plp
                                trap_cs         ;flags loaded?
351c : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
351e : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
3520 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq 
3522 : f0fe            >        beq *           ;failed equal (zero)
                        
3524 : c949                     cmp #'I'        ;registers loaded?
                                trap_ne
3526 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3528 : e04e                     cpx #'N'
                                trap_ne        
352a : d0fe            >        bne *           ;failed not equal (non zero)
                        
352c : c041                     cpy #('D'-3)
                                trap_ne
352e : d0fe            >        bne *           ;failed not equal (non zero)
                        
3530 : 48                       pha             ;save a,x
3531 : 8a                       txa
3532 : 48                       pha
3533 : ba                       tsx
3534 : e0fd                     cpx #$fd        ;check SP
                                trap_ne
3536 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3538 : 68                       pla             ;restore x
3539 : aa                       tax
                                set_stat $ff
                       >            load_flag $ff
353a : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
353c : 48              >            pha         ;use stack to load status
353d : 28              >            plp
                        
353e : 68                       pla             ;restore a
353f : e8                       inx             ;return registers with modifications
3540 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
3542 : 6c1035                   jmp (ptr_ind_ret)
                                trap            ;runover protection
3545 : 4c4535          >        jmp *           ;failed anyway
                        
3548 : 4c0004                   jmp start       ;catastrophic error - cannot continue
                        
                        ; target for the jump subroutine test
354b : 88                       dey
354c : 88                       dey
354d :                  test_jsr
354d : 08                       php             ;either SP or Y count will fail, if we do not hit
354e : 88                       dey
354f : 88                       dey
3550 : 88                       dey
3551 : 28                       plp
                                trap_cs         ;flags loaded?
3552 : b0fe            >        bcs *           ;failed carry set
                        
                                trap_vs
3554 : 70fe            >        bvs *           ;failed overflow set
                        
                                trap_mi
3556 : 30fe            >        bmi *           ;failed minus (bit 7 set)
                        
                                trap_eq 
3558 : f0fe            >        beq *           ;failed equal (zero)
                        
355a : c94a                     cmp #'J'        ;registers loaded?
                                trap_ne
355c : d0fe            >        bne *           ;failed not equal (non zero)
                        
355e : e053                     cpx #'S'
                                trap_ne        
3560 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3562 : c04f                     cpy #('R'-3)
                                trap_ne
3564 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3566 : 48                       pha             ;save a,x
3567 : 8a                       txa
3568 : 48                       pha       
3569 : ba                       tsx             ;sp -4? (return addr,a,x)
356a : e0fb                     cpx #$fb
                                trap_ne
356c : d0fe            >        bne *           ;failed not equal (non zero)
                        
356e : adff01                   lda $1ff        ;propper return on stack
3571 : c909                     cmp #hi(jsr_ret)
                                trap_ne
3573 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3575 : adfe01                   lda $1fe
3578 : c9ba                     cmp #lo(jsr_ret)
                                trap_ne
357a : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                set_stat $ff
                       >            load_flag $ff
357c : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                       >
357e : 48              >            pha         ;use stack to load status
357f : 28              >            plp
                        
3580 : 68                       pla             ;pull x,a
3581 : aa                       tax
3582 : 68                       pla
3583 : e8                       inx             ;return registers with modifications
3584 : 49aa                     eor #$aa        ;N=1, V=1, Z=0, C=1
3586 : 60                       rts
                                trap            ;runover protection
3587 : 4c8735          >        jmp *           ;failed anyway
                        
358a : 4c0004                   jmp start       ;catastrophic error - cannot continue
                                
                        ;trap in case of unexpected IRQ, NMI, BRK, RESET - BRK test target
358d :                  nmi_trap
                                trap            ;check stack for conditions at NMI
358d : 4c8d35          >        jmp *           ;failed anyway
                        
3590 : 4c0004                   jmp start       ;catastrophic error - cannot continue
3593 :                  res_trap
                                trap            ;unexpected RESET
3593 : 4c9335          >        jmp *           ;failed anyway
                        
3596 : 4c0004                   jmp start       ;catastrophic error - cannot continue
                                
3599 : 88                       dey
359a : 88                       dey
359b :                  irq_trap                ;BRK test or unextpected BRK or IRQ
359b : 08                       php             ;either SP or Y count will fail, if we do not hit
359c : 88                       dey
359d : 88                       dey
359e : 88                       dey
                                ;next traps could be caused by unexpected BRK or IRQ
                                ;check stack for BREAK and originating location
                                ;possible jump/branch into weeds (uninitialized space)
359f : c9bd                     cmp #$ff-'B'    ;BRK pass 2 registers loaded?
35a1 : f042                     beq break2
35a3 : c942                     cmp #'B'        ;BRK pass 1 registers loaded?
                                trap_ne
35a5 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35a7 : e052                     cpx #'R'
                                trap_ne        
35a9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35ab : c048                     cpy #'K'-3
                                trap_ne
35ad : d0fe            >        bne *           ;failed not equal (non zero)
                        
35af : 850a                     sta irq_a       ;save registers during break test
35b1 : 860b                     stx irq_x
35b3 : ba                       tsx             ;test break on stack
35b4 : bd0201                   lda $102,x
                                cmp_flag 0      ;break test should have B=1 & unused=1 on stack
35b7 : c930            >            cmp #(0      |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne         ; - no break flag on stack
35b9 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35bb : 68                       pla
                                cmp_flag intdis ;should have added interrupt disable
35bc : c934            >            cmp #(intdis |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
35be : d0fe            >        bne *           ;failed not equal (non zero)
                        
35c0 : ba                       tsx
35c1 : e0fc                     cpx #$fc        ;sp -3? (return addr, flags)
                                trap_ne
35c3 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35c5 : adff01                   lda $1ff        ;propper return on stack
35c8 : c909                     cmp #hi(brk_ret0)
                                trap_ne
35ca : d0fe            >        bne *           ;failed not equal (non zero)
                        
35cc : adfe01                   lda $1fe
35cf : c9f1                     cmp #lo(brk_ret0)
                                trap_ne
35d1 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                load_flag $ff
35d3 : a9ff            >            lda #$ff             ;allow test to change I-flag (no mask)
                        
35d5 : 48                       pha
35d6 : a60b                     ldx irq_x
35d8 : e8                       inx             ;return registers with modifications
35d9 : a50a                     lda irq_a
35db : 49aa                     eor #$aa
35dd : 28                       plp             ;N=1, V=1, Z=1, C=1 but original flags should be restored
35de : 40                       rti
                                trap            ;runover protection
35df : 4cdf35          >        jmp *           ;failed anyway
                        
35e2 : 4c0004                   jmp start       ;catastrophic error - cannot continue
                                
35e5 :                  break2                  ;BRK pass 2        
35e5 : e0ad                     cpx #$ff-'R'
                                trap_ne        
35e7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35e9 : c0b1                     cpy #$ff-'K'-3
                                trap_ne
35eb : d0fe            >        bne *           ;failed not equal (non zero)
                        
35ed : 850a                     sta irq_a       ;save registers during break test
35ef : 860b                     stx irq_x
35f1 : ba                       tsx             ;test break on stack
35f2 : bd0201                   lda $102,x
                                cmp_flag $ff    ;break test should have B=1
35f5 : c9ff            >            cmp #($ff    |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne         ; - no break flag on stack
35f7 : d0fe            >        bne *           ;failed not equal (non zero)
                        
35f9 : 68                       pla
35fa : 0908                     ora #decmode    ;ignore decmode cleared if 65c02
                                cmp_flag $ff    ;actual passed flags
35fc : c9ff            >            cmp #($ff    |fao)&m8    ;expected flags + always on bits
                        
                                trap_ne
35fe : d0fe            >        bne *           ;failed not equal (non zero)
                        
3600 : ba                       tsx
3601 : e0fc                     cpx #$fc        ;sp -3? (return addr, flags)
                                trap_ne
3603 : d0fe            >        bne *           ;failed not equal (non zero)
                        
3605 : adff01                   lda $1ff        ;propper return on stack
3608 : c90a                     cmp #hi(brk_ret1)
                                trap_ne
360a : d0fe            >        bne *           ;failed not equal (non zero)
                        
360c : adfe01                   lda $1fe
360f : c917                     cmp #lo(brk_ret1)
                                trap_ne
3611 : d0fe            >        bne *           ;failed not equal (non zero)
                        
                                load_flag intdis
3613 : a904            >            lda #intdis             ;allow test to change I-flag (no mask)
                        
3615 : 48                       pha      
3616 : a60b                     ldx irq_x
3618 : e8                       inx             ;return registers with modifications
3619 : a50a                     lda irq_a
361b : 49aa                     eor #$aa
361d : 28                       plp             ;N=0, V=0, Z=0, C=0 but original flags should be restored
361e : 40                       rti
                                trap            ;runover protection
361f : 4c1f36          >        jmp *           ;failed anyway
                        
3622 : 4c0004                   jmp start       ;catastrophic error - cannot continue
                        
                            if report = 1
                                include "report.i65"
                            endif
                                
                        ;copy of data to initialize BSS segment
                            if load_data_direct != 1
3625 :                  zp_init
3625 : c3824100         zp1_    db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
3629 : 7f               zp7f_   db  $7f             ;test pattern for compare
                        ;logical zeropage operands
362a : 001f7180         zpOR_   db  0,$1f,$71,$80   ;test pattern for OR
362e : 0fff7f80         zpAN_   db  $0f,$ff,$7f,$80 ;test pattern for AND
3632 : ff0f8f8f         zpEO_   db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;indirect addressing pointers
3636 : 1702             ind1_   dw  abs1            ;indirect pointer to pattern in absolute memory
3638 : 1802                     dw  abs1+1
363a : 1902                     dw  abs1+2
363c : 1a02                     dw  abs1+3
363e : 1b02                     dw  abs7f
3640 : 1f01             inw1_   dw  abs1-$f8        ;indirect pointer for wrap-test pattern
3642 : 0302             indt_   dw  abst            ;indirect pointer to store area in absolute memory
3644 : 0402                     dw  abst+1
3646 : 0502                     dw  abst+2
3648 : 0602                     dw  abst+3
364a : 0b01             inwt_   dw  abst-$f8        ;indirect pointer for wrap-test store
364c : 4e02             indAN_  dw  absAN           ;indirect pointer to AND pattern in absolute memory
364e : 4f02                     dw  absAN+1
3650 : 5002                     dw  absAN+2
3652 : 5102                     dw  absAN+3
3654 : 5202             indEO_  dw  absEO           ;indirect pointer to EOR pattern in absolute memory
3656 : 5302                     dw  absEO+1
3658 : 5402                     dw  absEO+2
365a : 5502                     dw  absEO+3
365c : 4a02             indOR_  dw  absOR           ;indirect pointer to OR pattern in absolute memory
365e : 4b02                     dw  absOR+1
3660 : 4c02                     dw  absOR+2
3662 : 4d02                     dw  absOR+3
                        ;add/subtract indirect pointers
3664 : 0302             adi2_   dw  ada2            ;indirect pointer to operand 2 in absolute memory
3666 : 0402             sbi2_   dw  sba2            ;indirect pointer to complemented operand 2 (SBC)
3668 : 0401             adiy2_  dw  ada2-$ff        ;with offset for indirect indexed
366a : 0501             sbiy2_  dw  sba2-$ff
366c :                  zp_end
                            if (zp_end - zp_init) != (zp_bss_end - zp_bss)   
                                ;force assembler error if size is different   
                                ERROR ERROR ERROR   ;mismatch between bss and zeropage data
                            endif 
366c :                  data_init
366c : 2900             ex_and_ and #0              ;execute immediate opcodes
366e : 60                       rts
366f : 4900             ex_eor_ eor #0              ;execute immediate opcodes
3671 : 60                       rts
3672 : 0900             ex_ora_ ora #0              ;execute immediate opcodes
3674 : 60                       rts
3675 : 6900             ex_adc_ adc #0              ;execute immediate opcodes
3677 : 60                       rts
3678 : e900             ex_sbc_ sbc #0              ;execute immediate opcodes
367a : 60                       rts
367b : c3824100         abs1_   db  $c3,$82,$41,0   ;test patterns for LDx BIT ROL ROR ASL LSR
367f : 7f               abs7f_  db  $7f             ;test pattern for compare
                        ;loads
3680 : 80800002         fLDx_   db  fn,fn,0,fz      ;expected flags for load
                        ;shifts
3684 :                  rASL_                       ;expected result ASL & ROL -carry
3684 : 86048200         rROL_   db  $86,$04,$82,0   ; "
3688 : 87058301         rROLc_  db  $87,$05,$83,1   ;expected result ROL +carry
368c :                  rLSR_                       ;expected result LSR & ROR -carry
368c : 61412000         rROR_   db  $61,$41,$20,0   ; "
3690 : e1c1a080         rRORc_  db  $e1,$c1,$a0,$80 ;expected result ROR +carry
3694 :                  fASL_                       ;expected flags for shifts
3694 : 81018002         fROL_   db  fnc,fc,fn,fz    ;no carry in
3698 : 81018000         fROLc_  db  fnc,fc,fn,0     ;carry in
369c :                  fLSR_
369c : 01000102         fROR_   db  fc,0,fc,fz      ;no carry in
36a0 : 81808180         fRORc_  db  fnc,fn,fnc,fn   ;carry in
                        ;increments (decrements)
36a4 : 7f80ff0001       rINC_   db  $7f,$80,$ff,0,1 ;expected result for INC/DEC
36a9 : 0080800200       fINC_   db  0,fn,fn,fz,0    ;expected flags for INC/DEC
                        ;logical memory operand
36ae : 001f7180         absOR_  db  0,$1f,$71,$80   ;test pattern for OR
36b2 : 0fff7f80         absAN_  db  $0f,$ff,$7f,$80 ;test pattern for AND
36b6 : ff0f8f8f         absEO_  db  $ff,$0f,$8f,$8f ;test pattern for EOR
                        ;logical accu operand
36ba : 00f11f00         absORa_ db  0,$f1,$1f,0     ;test pattern for OR
36be : f0ffffff         absANa_ db  $f0,$ff,$ff,$ff ;test pattern for AND
36c2 : fff0f00f         absEOa_ db  $ff,$f0,$f0,$0f ;test pattern for EOR
                        ;logical results
36c6 : 00ff7f80         absrlo_ db  0,$ff,$7f,$80
36ca : 02800080         absflo_ db  fz,fn,0,fn
36ce :                  data_end
                            if (data_end - data_init) != (data_bss_end - data_bss)
                                ;force assembler error if size is different   
                                ERROR ERROR ERROR   ;mismatch between bss and data
                            endif 
                        
36ce :                  vec_init
36ce : 8d35                     dw  nmi_trap
36d0 : 9335                     dw  res_trap
36d2 : 9b35                     dw  irq_trap
fffa =                  vec_bss equ $fffa
                            endif                   ;end of RAM init data
                            
                            if (load_data_direct = 1) & (ROM_vectors = 1)  
                                org $fffa       ;vectors
                                dw  nmi_trap
                                dw  res_trap
                                dw  irq_trap
                            endif
                        
fffa =                          end start
                                    
No errors in pass 2.
Wrote binary from address $0400 through $36d3.
Total size 13012 bytes.
Program start address is at $0400 (1024).
